<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Cambridge SMT System: ucam::hifst Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Cambridge SMT System
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('namespaceucam_1_1hifst.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">ucam::hifst Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1AlilatsToSparseWeightLatsData.html">AlilatsToSparseWeightLatsData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data class containing relevant variables. To be used as template for task classes using it.  <a href="classucam_1_1hifst_1_1AlilatsToSparseWeightLatsData.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1HifstTaskData.html">HifstTaskData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data class containing relevant variables. To be used as template for task classes using it.  <a href="classucam_1_1hifst_1_1HifstTaskData.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1HifstClientTaskData.html">HifstClientTaskData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data class containing relevant variables. To be used as template for task classes using it.  <a href="classucam_1_1hifst_1_1HifstClientTaskData.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1RuleIdsToSparseWeightLatsData.html">RuleIdsToSparseWeightLatsData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data class containing relevant variables. To be used as template for task classes using it.  <a href="classucam_1_1hifst_1_1RuleIdsToSparseWeightLatsData.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1CYKbackpointers.html">CYKbackpointers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">functor that provides cyk backpointers  <a href="classucam_1_1hifst_1_1CYKbackpointers.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1CYKgrid.html">CYKgrid</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">functor that provides cykgrid access methods  <a href="classucam_1_1hifst_1_1CYKgrid.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structucam_1_1hifst_1_1CYKdata.html">CYKdata</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Data structure containing all cyk-related information.  <a href="structucam_1_1hifst_1_1CYKdata.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structucam_1_1hifst_1_1posindex.html">posindex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct containing rule positions and offsets.  <a href="structucam_1_1hifst_1_1posindex.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1CompareTool.html">CompareTool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that provides basic string comparison between two const char *.  <a href="classucam_1_1hifst_1_1CompareTool.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1PosIndexCompare.html">PosIndexCompare</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Functor Class that provides comparison accross the posindex structure. This is typically used e.g. with a priority queue. It can use <a class="el" href="classucam_1_1hifst_1_1CompareTool.html" title="Class that provides basic string comparison between two const char *. ">CompareTool</a> or any inherited class.  <a href="classucam_1_1hifst_1_1PosIndexCompare.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1PatternCompareTool.html">PatternCompareTool</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class that provides "pattern" comparison between two const char *. The "patterns" are an abstraction of any non-terminal A-Z. So for instance, consider non_terminals A and Z. A rule with source 3_A_5 and another one with source 3_Z_5 are equivalent and need to be listed together (with any other equivalent sources). This class can be used with <a class="el" href="classucam_1_1hifst_1_1PosIndexCompare.html" title="Functor Class that provides comparison accross the posindex structure. This is typically used e...">PosIndexCompare</a> as it inherits from <a class="el" href="classucam_1_1hifst_1_1CompareTool.html" title="Class that provides basic string comparison between two const char *. ">CompareTool</a>.  <a href="classucam_1_1hifst_1_1PatternCompareTool.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structucam_1_1hifst_1_1GrammarData.html">GrammarData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Struct containing grammar rules.  <a href="structucam_1_1hifst_1_1GrammarData.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structucam_1_1hifst_1_1SentenceSpecificGrammarData.html">SentenceSpecificGrammarData</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for sentence-specific grammar Rules will be queried by cyk per position and number of elements in the right-hand-side (source) of the rule Therefore indices are stored in this fashion so queries can be done directly. Note: a more efficient implementation could be to store these rule indices in a structure much closer even to the cyk grid. For instance, if an instanced pattern has never been seen below span 5, there is no need for the cyk to query and reject it.  <a href="structucam_1_1hifst_1_1SentenceSpecificGrammarData.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1SingleThreadedAliLatsToSparseVecLatsTask.html">SingleThreadedAliLatsToSparseVecLatsTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full single-threaded Alignment lattices to Sparse lattices.  <a href="classucam_1_1hifst_1_1SingleThreadedAliLatsToSparseVecLatsTask.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1MultiThreadedAliLatsToSparseVecLatsTask.html">MultiThreadedAliLatsToSparseVecLatsTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Multithreaded implementation of alilats2splats pipeline.  <a href="classucam_1_1hifst_1_1MultiThreadedAliLatsToSparseVecLatsTask.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1SingleThreadedCreateSentenceSpecificGrammarTask.html">SingleThreadedCreateSentenceSpecificGrammarTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full single-threaded Translation system.  <a href="classucam_1_1hifst_1_1SingleThreadedCreateSentenceSpecificGrammarTask.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1MultiThreadedCreateSentenceSpecificGrammarTask.html">MultiThreadedCreateSentenceSpecificGrammarTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full multi-threaded Translation system.  <a href="classucam_1_1hifst_1_1MultiThreadedCreateSentenceSpecificGrammarTask.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1SingleThreadedHifstClientTask.html">SingleThreadedHifstClientTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full single-threaded Translation system.  <a href="classucam_1_1hifst_1_1SingleThreadedHifstClientTask.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1SingleThreadedHifstTask.html">SingleThreadedHifstTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full single-threaded Translation system.  <a href="classucam_1_1hifst_1_1SingleThreadedHifstTask.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1MultiThreadedHifstTask.html">MultiThreadedHifstTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full multi-threaded Translation system.  <a href="classucam_1_1hifst_1_1MultiThreadedHifstTask.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1HifstServerTask.html">HifstServerTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translation Server.  <a href="classucam_1_1hifst_1_1HifstServerTask.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structucam_1_1hifst_1_1RulesToWeightsMapperObject.html">RulesToWeightsMapperObject</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1SingleThreadededRulesToWeightsSparseLatsTask.html">SingleThreadededRulesToWeightsSparseLatsTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full single-threaded Alignment lattices to Sparse lattices.  <a href="classucam_1_1hifst_1_1SingleThreadededRulesToWeightsSparseLatsTask.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1CYKParserTask.html">CYKParserTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements cyk+ parser.  <a href="classucam_1_1hifst_1_1CYKParserTask.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1DumpNbestFeaturesTask.html">DumpNbestFeaturesTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task that dumps nbest and feature file. Templated on specific Data object and Fst Arc.  <a href="classucam_1_1hifst_1_1DumpNbestFeaturesTask.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1GrammarTask.html">GrammarTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task class that loads a grammar into memory.  <a href="classucam_1_1hifst_1_1GrammarTask.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1NonTerminalHierarchy.html">NonTerminalHierarchy</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a functor with additional methods to include relevant rules (i.e. identify SCFG rules, S -&gt; X X, X -&gt; V V ) and determine the hierarchy of non-terminals within the grammar.  <a href="classucam_1_1hifst_1_1NonTerminalHierarchy.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1HifstStatsTask.html">HifstStatsTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads StatsData and dumps all stats to (sentence-specific) file. Provides a special method for cyk data: dumps a grid in text format with relevant information per cell.  <a href="classucam_1_1hifst_1_1HifstStatsTask.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1ExpandedNumStatesRTN.html">ExpandedNumStatesRTN</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class that, given an <a class="el" href="classucam_1_1hifst_1_1RTN.html" title="Convenience class that stores pointers to cell FSAs. These pointers are organized through a hash usin...">RTN</a> with root at (cc,x,y), estimates the number of states of an expanded FSA The <a class="el" href="classucam_1_1hifst_1_1RTN.html" title="Convenience class that stores pointers to cell FSAs. These pointers are organized through a hash usin...">RTN</a> is not explicitly passed to this class. Instead, it is updated sequentially as individual FSAs are created.  <a href="classucam_1_1hifst_1_1ExpandedNumStatesRTN.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1HiFSTTask.html">HiFSTTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Core of Hifst. Implements the lattice-building procedure for a cyk-parsed sentence.  <a href="classucam_1_1hifst_1_1HiFSTTask.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structucam_1_1hifst_1_1conditions.html">conditions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">struct containing the elements that trigger local pruning.  <a href="structucam_1_1hifst_1_1conditions.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1LocalPruningConditions.html">LocalPruningConditions</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">convenience class that takes care of local pruning conditions. Conditions are indexed by 1000*cc+y, so you can search through all conditions and get to the closest set of conditions that apply.  <a href="classucam_1_1hifst_1_1LocalPruningConditions.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structucam_1_1hifst_1_1MakeWeightHifst.html">MakeWeightHifst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structucam_1_1hifst_1_1MakeWeightHifst_3_01fst_1_1LexStdArc_01_4.html">MakeWeightHifst&lt; fst::LexStdArc &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structucam_1_1hifst_1_1MakeWeightHifst_3_01TupleArc32_01_4.html">MakeWeightHifst&lt; TupleArc32 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structucam_1_1hifst_1_1MakeWeightHifstLocalLm.html">MakeWeightHifstLocalLm</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structucam_1_1hifst_1_1MakeWeightHifstLocalLm_3_01fst_1_1LexStdArc_01_4.html">MakeWeightHifstLocalLm&lt; fst::LexStdArc &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structucam_1_1hifst_1_1MakeWeightHifstLocalLm_3_01TupleArc32_01_4.html">MakeWeightHifstLocalLm&lt; TupleArc32 &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1OptimizeMachine.html">OptimizeMachine</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1OptimizeMachineNoDetMin.html">OptimizeMachineNoDetMin</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structucam_1_1hifst_1_1GenerateTrivialFst.html">GenerateTrivialFst</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1ReplaceFstByArc.html">ReplaceFstByArc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates FST replacement or not depending on conditions.  <a href="classucam_1_1hifst_1_1ReplaceFstByArc.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1ManualReplaceFstByArc.html">ManualReplaceFstByArc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates FST replacement or not depending on conditions including program options.  <a href="classucam_1_1hifst_1_1ManualReplaceFstByArc.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1RTN.html">RTN</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience class that stores pointers to cell FSAs. These pointers are organized through a hash using a label built from (cc,x,y) as key.  <a href="classucam_1_1hifst_1_1RTN.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1LoadSparseWeightFlowerLatticeTask.html">LoadSparseWeightFlowerLatticeTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Implements a class that loads the grammar sparseweight flower lattice and stores a pointer on the data object.  <a href="classucam_1_1hifst_1_1LoadSparseWeightFlowerLatticeTask.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1LoadSparseWeightsTask.html">LoadSparseWeightsTask</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1PatternsToInstancesTask.html">PatternsToInstancesTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts patterns to instanced patterns.  <a href="classucam_1_1hifst_1_1PatternsToInstancesTask.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1PostProTask.html">PostProTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Task that writes translation to a text file. This translation might be recased, wordmapped and tokenized.  <a href="classucam_1_1hifst_1_1PostProTask.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1PreProTask.html">PreProTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads text file, performs tokenization and integer-mapping.  <a href="classucam_1_1hifst_1_1PreProTask.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1ReferenceFilterTask.html">ReferenceFilterTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a substring version of a reference translation lattice and associated vocabulary. This substring fst is typically used to guide translation towards a particular search space. The associated vocabulary can be used e.g. to restrict parsing algorithms.  <a href="classucam_1_1hifst_1_1ReferenceFilterTask.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1SparseWeightVectorLatticesTask.html">SparseWeightVectorLatticesTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates lattices using tropical tuple weight semiring &ndash; each arc containing separate feature weight contributions. Note that the semiring is tropical under dot product of all these features with its scales.  <a href="classucam_1_1hifst_1_1SparseWeightVectorLatticesTask.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classucam_1_1hifst_1_1SentenceSpecificGrammarTask.html">SentenceSpecificGrammarTask</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class uses instantiated patterns to analyze the grammar and deliver two hashes providing candidate rules for a (cyk) parser to validate them. The first hash is for rules with only one element (e.g. A-&gt;word, A-&gt;B). The second hash is for rules with two or more elements. Both hashes require two keys: the word position in the sentence (x) and the first element of the rule (which can be either a word or non-terminal).  <a href="classucam_1_1hifst_1_1SentenceSpecificGrammarTask.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ab007ac96afa338fc37f900b1da39a401"><td class="memItemLeft" align="right" valign="top">typedef std::basic_string&lt; uint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceucam_1_1hifst.html#ab007ac96afa338fc37f900b1da39a401">cykparser_sentence_t</a></td></tr>
<tr class="separator:ab007ac96afa338fc37f900b1da39a401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01b9c529312e86039832820d55e0d9a5"><td class="memItemLeft" align="right" valign="top">typedef std::basic_string&lt; uint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceucam_1_1hifst.html#a01b9c529312e86039832820d55e0d9a5">cykparser_rulebpcoordinates_t</a></td></tr>
<tr class="separator:a01b9c529312e86039832820d55e0d9a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5ba3a2ca688b37bef4536298ae73786"><td class="memItemLeft" align="right" valign="top">typedef std::vector<br class="typebreak"/>
&lt; <a class="el" href="namespaceucam_1_1hifst.html#a01b9c529312e86039832820d55e0d9a5">cykparser_rulebpcoordinates_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceucam_1_1hifst.html#ac5ba3a2ca688b37bef4536298ae73786">cykparser_ruledependencies_t</a></td></tr>
<tr class="separator:ac5ba3a2ca688b37bef4536298ae73786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05624d2d090a6ab449444eea1ed99293"><td class="memItemLeft" align="right" valign="top">typedef unordered_map<br class="typebreak"/>
&lt; std::string, uint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceucam_1_1hifst.html#a05624d2d090a6ab449444eea1ed99293">grammar_categories_t</a></td></tr>
<tr class="separator:a05624d2d090a6ab449444eea1ed99293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68e3a0e387869e0f295d588f22eeaf5d"><td class="memItemLeft" align="right" valign="top">typedef unordered_map&lt; uint, <br class="typebreak"/>
std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceucam_1_1hifst.html#a68e3a0e387869e0f295d588f22eeaf5d">grammar_inversecategories_t</a></td></tr>
<tr class="separator:a68e3a0e387869e0f295d588f22eeaf5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a891727f4796bf42673d80a30a0ba1dcf"><td class="memItemLeft" align="right" valign="top">typedef std::basic_string&lt; uint &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceucam_1_1hifst.html#a891727f4796bf42673d80a30a0ba1dcf">ssgrammar_listofrules_t</a></td></tr>
<tr class="separator:a891727f4796bf42673d80a30a0ba1dcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69c11bea0fbf10cc148380f636cf52ef"><td class="memItemLeft" align="right" valign="top">typedef unordered_map<br class="typebreak"/>
&lt; std::string, <br class="typebreak"/>
<a class="el" href="namespaceucam_1_1hifst.html#a891727f4796bf42673d80a30a0ba1dcf">ssgrammar_listofrules_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceucam_1_1hifst.html#a69c11bea0fbf10cc148380f636cf52ef">ssgrammar_firstelementmap_t</a></td></tr>
<tr class="separator:a69c11bea0fbf10cc148380f636cf52ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84271efa0747f385889b2af25cddef00"><td class="memItemLeft" align="right" valign="top">typedef unordered_map&lt; uint, <br class="typebreak"/>
<a class="el" href="namespaceucam_1_1hifst.html#a69c11bea0fbf10cc148380f636cf52ef">ssgrammar_firstelementmap_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceucam_1_1hifst.html#a84271efa0747f385889b2af25cddef00">ssgrammar_rulesmap_t</a></td></tr>
<tr class="separator:a84271efa0747f385889b2af25cddef00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca13ef351499f9ae4eec2ee47ed88ddc"><td class="memItemLeft" align="right" valign="top">typedef unordered_map<br class="typebreak"/>
&lt; std::string, std::vector<br class="typebreak"/>
&lt; pair&lt; uint, uint &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceucam_1_1hifst.html#aca13ef351499f9ae4eec2ee47ed88ddc">ssgrammar_instancemap_t</a></td></tr>
<tr class="separator:aca13ef351499f9ae4eec2ee47ed88ddc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8acc19e118080adf976fae08b99bbe16"><td class="memItemLeft" align="right" valign="top">typedef boost::shared_ptr<br class="typebreak"/>
&lt; tcp::socket &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceucam_1_1hifst.html#a8acc19e118080adf976fae08b99bbe16">socket_ptr</a></td></tr>
<tr class="separator:a8acc19e118080adf976fae08b99bbe16"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:af716f6a26dc2c97d50cc1b6dcc039ec1"><td class="memItemLeft" align="right" valign="top">const uint&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceucam_1_1hifst.html#af716f6a26dc2c97d50cc1b6dcc039ec1">getSize</a> (const std::string &amp;rhs)</td></tr>
<tr class="memdesc:af716f6a26dc2c97d50cc1b6dcc039ec1"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic element counter that can be used to any string. It is intended to use with either source or target side of a rule (right-hand side parts of the synchronous rule).  <a href="#af716f6a26dc2c97d50cc1b6dcc039ec1">More...</a><br/></td></tr>
<tr class="separator:af716f6a26dc2c97d50cc1b6dcc039ec1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c6647523bd1c5f5ccb97ca84ce7c32"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceucam_1_1hifst.html#a40c6647523bd1c5f5ccb97ca84ce7c32">isTerminal</a> (const std::string &amp;word)</td></tr>
<tr class="memdesc:a40c6647523bd1c5f5ccb97ca84ce7c32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the element is a terminal (i.e. a word, represented by a number) or a non-terminal (i.e. ^[A-Z]+(0-9)?). Only first position is checked.  <a href="#a40c6647523bd1c5f5ccb97ca84ce7c32">More...</a><br/></td></tr>
<tr class="separator:a40c6647523bd1c5f5ccb97ca84ce7c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49402f564911c3d716fa98bbb388c3c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceucam_1_1hifst.html#a49402f564911c3d716fa98bbb388c3c0">getFilteredNonTerminal</a> (std::string &amp;word)</td></tr>
<tr class="memdesc:a49402f564911c3d716fa98bbb388c3c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the filtered non-terminal name. For example, for the rule Z 3_XT2_5 XT2, getFilteredNonTerminal("XT2") should return XT.  <a href="#a49402f564911c3d716fa98bbb388c3c0">More...</a><br/></td></tr>
<tr class="separator:a49402f564911c3d716fa98bbb388c3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a73977a1362a91cb27cff5abcb90d92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceucam_1_1hifst.html#a2a73977a1362a91cb27cff5abcb90d92">getRuleMappings</a> (const std::vector&lt; std::string &gt; &amp;source, const std::vector&lt; std::string &gt; &amp;translation, unordered_map&lt; uint, uint &gt; *mappings)</td></tr>
<tr class="memdesc:a2a73977a1362a91cb27cff5abcb90d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given a source and translation of the same rule, sharing the same non-terminals in RHS, returns correspondences between source and target non-terminal indices. For example: X a_Y_Z_b c_Z_Y_d: mappings[0]=1; mappings[1]=0.  <a href="#a2a73977a1362a91cb27cff5abcb90d92">More...</a><br/></td></tr>
<tr class="separator:a2a73977a1362a91cb27cff5abcb90d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e43dd38d664aa8701b48168758a66e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceucam_1_1hifst.html#a6e43dd38d664aa8701b48168758a66e0">phraseIsTerminalWord</a> (const std::string &amp;phrase)</td></tr>
<tr class="separator:a6e43dd38d664aa8701b48168758a66e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d183a19ce39056940dc5a607523ed01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceucam_1_1hifst.html#a2d183a19ce39056940dc5a607523ed01">setScales</a> (const <a class="el" href="classucam_1_1util_1_1RegistryPO.html">ucam::util::RegistryPO</a> &amp;rg, unsigned *offset, const std::string &amp;lmscales=<a class="el" href="namespaceHifstConstants.html#a41f9243c4b6a35530c5b8e1c76c1104f">HifstConstants::kLmFeatureweights</a>, const std::string &amp;grammarscales=<a class="el" href="namespaceHifstConstants.html#a4b971ec2c3a86807f5fc4bdf0ca90317">HifstConstants::kRuleflowerlatticeFeatureweights</a>, const std::string &amp;featureweights=<a class="el" href="namespaceHifstConstants.html#af706d863d7dce966d3dd48ec6ff56f4b">HifstConstants::kFeatureweights</a>, const std::string &amp;lmload=<a class="el" href="namespaceHifstConstants.html#a37a650ce4c4cf67354de7b1466d60ae0">HifstConstants::kLmLoad</a>)</td></tr>
<tr class="memdesc:a2d183a19ce39056940dc5a607523ed01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets scales using environment parameter (see sparse tuple weight semiring file), or grammar scales and language model scales. If these are active, the environment parameter will not be used.  <a href="#a2d183a19ce39056940dc5a607523ed01">More...</a><br/></td></tr>
<tr class="separator:a2d183a19ce39056940dc5a607523ed01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7debb1362710b645de1a7b7b6b991e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceucam_1_1hifst.html#a1a7debb1362710b645de1a7b7b6b991e">getLocalLmIndex</a> (<a class="el" href="classucam_1_1util_1_1RegistryPO.html">ucam::util::RegistryPO</a> const *rg=NULL)</td></tr>
<tr class="separator:a1a7debb1362710b645de1a7b7b6b991e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a19b24ba8c4e8921cbea11859fdb5fb71"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceucam_1_1hifst.html#a19b24ba8c4e8921cbea11859fdb5fb71">max_length</a> = 1024</td></tr>
<tr class="separator:a19b24ba8c4e8921cbea11859fdb5fb71"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a01b9c529312e86039832820d55e0d9a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::basic_string&lt;uint&gt; <a class="el" href="namespaceucam_1_1hifst.html#a01b9c529312e86039832820d55e0d9a5">ucam::hifst::cykparser_rulebpcoordinates_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="defs_8cykparser_8hpp_source.html#l00028">28</a> of file <a class="el" href="defs_8cykparser_8hpp_source.html">defs.cykparser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac5ba3a2ca688b37bef4536298ae73786"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::vector&lt; <a class="el" href="namespaceucam_1_1hifst.html#a01b9c529312e86039832820d55e0d9a5">cykparser_rulebpcoordinates_t</a> &gt; <a class="el" href="namespaceucam_1_1hifst.html#ac5ba3a2ca688b37bef4536298ae73786">ucam::hifst::cykparser_ruledependencies_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="defs_8cykparser_8hpp_source.html#l00030">30</a> of file <a class="el" href="defs_8cykparser_8hpp_source.html">defs.cykparser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab007ac96afa338fc37f900b1da39a401"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::basic_string&lt;uint&gt; <a class="el" href="namespaceucam_1_1hifst.html#ab007ac96afa338fc37f900b1da39a401">ucam::hifst::cykparser_sentence_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="defs_8cykparser_8hpp_source.html#l00027">27</a> of file <a class="el" href="defs_8cykparser_8hpp_source.html">defs.cykparser.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a05624d2d090a6ab449444eea1ed99293"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unordered_map&lt;std::string, uint&gt; <a class="el" href="namespaceucam_1_1hifst.html#a05624d2d090a6ab449444eea1ed99293">ucam::hifst::grammar_categories_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="defs_8grammar_8hpp_source.html#l00027">27</a> of file <a class="el" href="defs_8grammar_8hpp_source.html">defs.grammar.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a68e3a0e387869e0f295d588f22eeaf5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unordered_map&lt; uint, std::string &gt; <a class="el" href="namespaceucam_1_1hifst.html#a68e3a0e387869e0f295d588f22eeaf5d">ucam::hifst::grammar_inversecategories_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="defs_8grammar_8hpp_source.html#l00028">28</a> of file <a class="el" href="defs_8grammar_8hpp_source.html">defs.grammar.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8acc19e118080adf976fae08b99bbe16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef boost::shared_ptr&lt; tcp::socket &gt; <a class="el" href="namespaceucam_1_1hifst.html#a8acc19e118080adf976fae08b99bbe16">ucam::hifst::socket_ptr</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="main-run_8createssgrammar_8hpp_source.html#l00030">30</a> of file <a class="el" href="main-run_8createssgrammar_8hpp_source.html">main-run.createssgrammar.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a69c11bea0fbf10cc148380f636cf52ef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unordered_map&lt;std::string, <a class="el" href="namespaceucam_1_1hifst.html#a891727f4796bf42673d80a30a0ba1dcf">ssgrammar_listofrules_t</a> &gt; <a class="el" href="namespaceucam_1_1hifst.html#a69c11bea0fbf10cc148380f636cf52ef">ucam::hifst::ssgrammar_firstelementmap_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="defs_8ssgrammar_8hpp_source.html#l00031">31</a> of file <a class="el" href="defs_8ssgrammar_8hpp_source.html">defs.ssgrammar.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aca13ef351499f9ae4eec2ee47ed88ddc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unordered_map&lt;std::string, std::vector&lt; pair &lt;uint, uint&gt; &gt; &gt; <a class="el" href="namespaceucam_1_1hifst.html#aca13ef351499f9ae4eec2ee47ed88ddc">ucam::hifst::ssgrammar_instancemap_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="defs_8ssgrammar_8hpp_source.html#l00034">34</a> of file <a class="el" href="defs_8ssgrammar_8hpp_source.html">defs.ssgrammar.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a891727f4796bf42673d80a30a0ba1dcf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::basic_string&lt;uint&gt; <a class="el" href="namespaceucam_1_1hifst.html#a891727f4796bf42673d80a30a0ba1dcf">ucam::hifst::ssgrammar_listofrules_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="defs_8ssgrammar_8hpp_source.html#l00029">29</a> of file <a class="el" href="defs_8ssgrammar_8hpp_source.html">defs.ssgrammar.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a84271efa0747f385889b2af25cddef00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unordered_map&lt;uint, <a class="el" href="namespaceucam_1_1hifst.html#a69c11bea0fbf10cc148380f636cf52ef">ssgrammar_firstelementmap_t</a> &gt; <a class="el" href="namespaceucam_1_1hifst.html#a84271efa0747f385889b2af25cddef00">ucam::hifst::ssgrammar_rulesmap_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="defs_8ssgrammar_8hpp_source.html#l00032">32</a> of file <a class="el" href="defs_8ssgrammar_8hpp_source.html">defs.ssgrammar.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a49402f564911c3d716fa98bbb388c3c0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ucam::hifst::getFilteredNonTerminal </td>
          <td>(</td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>word</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the filtered non-terminal name. For example, for the rule Z 3_XT2_5 XT2, getFilteredNonTerminal("XT2") should return XT. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">word</td><td>The non-terminal we want to filter. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="data_8grammar_8utilities_8hpp_source.html#l00056">56</a> of file <a class="el" href="data_8grammar_8utilities_8hpp_source.html">data.grammar.utilities.hpp</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceucam_1_1hifst_a49402f564911c3d716fa98bbb388c3c0_cgraph.png" border="0" usemap="#namespaceucam_1_1hifst_a49402f564911c3d716fa98bbb388c3c0_cgraph" alt=""/></div>
<map name="namespaceucam_1_1hifst_a49402f564911c3d716fa98bbb388c3c0_cgraph" id="namespaceucam_1_1hifst_a49402f564911c3d716fa98bbb388c3c0_cgraph">
<area shape="rect" id="node3" href="namespaceucam_1_1hifst.html#a40c6647523bd1c5f5ccb97ca84ce7c32" title="Determine if the element is a terminal (i.e. a word, represented by a number) or a non&#45;terminal (i..." alt="" coords="207,13,356,41"/></map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceucam_1_1hifst_a49402f564911c3d716fa98bbb388c3c0_icgraph.png" border="0" usemap="#namespaceucam_1_1hifst_a49402f564911c3d716fa98bbb388c3c0_icgraph" alt=""/></div>
<map name="namespaceucam_1_1hifst_a49402f564911c3d716fa98bbb388c3c0_icgraph" id="namespaceucam_1_1hifst_a49402f564911c3d716fa98bbb388c3c0_icgraph">
<area shape="rect" id="node3" href="hifst_8task_8grammar_8gtest_8cpp.html#a271cf0fb4127da9be4f1416924aa206d" title="TEST" alt="" coords="207,13,260,41"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a1a7debb1362710b645de1a7b7b6b991e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ucam::hifst::getLocalLmIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classucam_1_1util_1_1RegistryPO.html">ucam::util::RegistryPO</a> const *&#160;</td>
          <td class="paramname"><em>rg</em> = <code>NULL</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="task_8hifst_8makeweights_8hpp_source.html#l00144">144</a> of file <a class="el" href="task_8hifst_8makeweights_8hpp_source.html">task.hifst.makeweights.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2a73977a1362a91cb27cff5abcb90d92"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ucam::hifst::getRuleMappings </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>translation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_map&lt; uint, uint &gt; *&#160;</td>
          <td class="paramname"><em>mappings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given a source and translation of the same rule, sharing the same non-terminals in RHS, returns correspondences between source and target non-terminal indices. For example: X a_Y_Z_b c_Z_Y_d: mappings[0]=1; mappings[1]=0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">source</td><td>RHS source of a rule </td></tr>
    <tr><td class="paramname">translation</td><td>RHS target of a rule </td></tr>
    <tr><td class="paramname">mappings</td><td>After finished, contains correspondences between source and target non-terminal indexes </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="data_8grammar_8utilities_8hpp_source.html#l00073">73</a> of file <a class="el" href="data_8grammar_8utilities_8hpp_source.html">data.grammar.utilities.hpp</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceucam_1_1hifst_a2a73977a1362a91cb27cff5abcb90d92_cgraph.png" border="0" usemap="#namespaceucam_1_1hifst_a2a73977a1362a91cb27cff5abcb90d92_cgraph" alt=""/></div>
<map name="namespaceucam_1_1hifst_a2a73977a1362a91cb27cff5abcb90d92_cgraph" id="namespaceucam_1_1hifst_a2a73977a1362a91cb27cff5abcb90d92_cgraph">
<area shape="rect" id="node3" href="namespaceucam_1_1hifst.html#a40c6647523bd1c5f5ccb97ca84ce7c32" title="Determine if the element is a terminal (i.e. a word, represented by a number) or a non&#45;terminal (i..." alt="" coords="247,5,396,33"/></map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceucam_1_1hifst_a2a73977a1362a91cb27cff5abcb90d92_icgraph.png" border="0" usemap="#namespaceucam_1_1hifst_a2a73977a1362a91cb27cff5abcb90d92_icgraph" alt=""/></div>
<map name="namespaceucam_1_1hifst_a2a73977a1362a91cb27cff5abcb90d92_icgraph" id="namespaceucam_1_1hifst_a2a73977a1362a91cb27cff5abcb90d92_icgraph">
<area shape="rect" id="node3" href="structucam_1_1hifst_1_1GrammarData.html#aedbb12acdb0b8eee047c0ca71b466987" title="Returns the non&#45;terminal mappings. For more details see getRuleMappings function. ..." alt="" coords="247,63,417,107"/><area shape="rect" id="node5" href="structucam_1_1hifst_1_1SentenceSpecificGrammarData.html#aa251678f01ec03a4cf92e0c63b6c77ce" title="Returns the non&#45;terminal mappings for a rule. For more details see getRuleMappings function..." alt="" coords="467,5,659,49"/><area shape="rect" id="node9" href="hifst_8task_8grammar_8gtest_8cpp.html#a83fd73f97d5ed6a83efa0888289fffbe" title="TEST" alt="" coords="536,71,589,99"/><area shape="rect" id="node7" href="hifst_8task_8ssgrammar_8gtest_8cpp.html#ae2ba325e99de079e5f9ad98cbfe5e68a" title="TEST" alt="" coords="708,13,761,41"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="af716f6a26dc2c97d50cc1b6dcc039ec1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint ucam::hifst::getSize </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A generic element counter that can be used to any string. It is intended to use with either source or target side of a rule (right-hand side parts of the synchronous rule). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td>source or target. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="data_8grammar_8utilities_8hpp_source.html#l00033">33</a> of file <a class="el" href="data_8grammar_8utilities_8hpp_source.html">data.grammar.utilities.hpp</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceucam_1_1hifst_af716f6a26dc2c97d50cc1b6dcc039ec1_cgraph.png" border="0" usemap="#namespaceucam_1_1hifst_af716f6a26dc2c97d50cc1b6dcc039ec1_cgraph" alt=""/></div>
<map name="namespaceucam_1_1hifst_af716f6a26dc2c97d50cc1b6dcc039ec1_cgraph" id="namespaceucam_1_1hifst_af716f6a26dc2c97d50cc1b6dcc039ec1_cgraph">
<area shape="rect" id="node3" href="namespaceucam_1_1util.html#afb792dafa597a1f56085fc27511c5ac1" title="Convenience function that counts the number of times a needle appears. " alt="" coords="191,5,356,33"/></map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceucam_1_1hifst_af716f6a26dc2c97d50cc1b6dcc039ec1_icgraph.png" border="0" usemap="#namespaceucam_1_1hifst_af716f6a26dc2c97d50cc1b6dcc039ec1_icgraph" alt=""/></div>
<map name="namespaceucam_1_1hifst_af716f6a26dc2c97d50cc1b6dcc039ec1_icgraph" id="namespaceucam_1_1hifst_af716f6a26dc2c97d50cc1b6dcc039ec1_icgraph">
<area shape="rect" id="node3" href="hifst_8task_8grammar_8gtest_8cpp.html#af0a7103caadb7d3716754cf55eb7bcb4" title="getSize function " alt="" coords="191,5,244,33"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a40c6647523bd1c5f5ccb97ca84ce7c32"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ucam::hifst::isTerminal </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>word</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the element is a terminal (i.e. a word, represented by a number) or a non-terminal (i.e. ^[A-Z]+(0-9)?). Only first position is checked. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">word</td><td>the element we are checking. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="data_8grammar_8utilities_8hpp_source.html#l00044">44</a> of file <a class="el" href="data_8grammar_8utilities_8hpp_source.html">data.grammar.utilities.hpp</a>.</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceucam_1_1hifst_a40c6647523bd1c5f5ccb97ca84ce7c32_icgraph.png" border="0" usemap="#namespaceucam_1_1hifst_a40c6647523bd1c5f5ccb97ca84ce7c32_icgraph" alt=""/></div>
<map name="namespaceucam_1_1hifst_a40c6647523bd1c5f5ccb97ca84ce7c32_icgraph" id="namespaceucam_1_1hifst_a40c6647523bd1c5f5ccb97ca84ce7c32_icgraph">
<area shape="rect" id="node3" href="structucam_1_1hifst_1_1GrammarData.html#a4adc88e09b5c373f5a98d2da8513d3ed" title="Determines whether a particular rule is allowed within a vocabulary, i.e. all target words of the rul..." alt="" coords="216,5,387,49"/><area shape="rect" id="node7" href="namespaceucam_1_1hifst.html#a49402f564911c3d716fa98bbb388c3c0" title="Return the filtered non&#45;terminal name. For example, for the rule Z 3_XT2_5 XT2, getFilteredNonTermina..." alt="" coords="225,71,377,115"/><area shape="rect" id="node11" href="namespaceucam_1_1hifst.html#a2a73977a1362a91cb27cff5abcb90d92" title="Given a source and translation of the same rule, sharing the same non&#45;terminals in RHS..." alt="" coords="207,138,396,166"/><area shape="rect" id="node22" href="hifst_8task_8grammar_8gtest_8cpp.html#ab16b7930399e7c6e89a40c8f032369bd" title="TEST" alt="" coords="275,189,328,217"/><area shape="rect" id="node5" href="structucam_1_1hifst_1_1SentenceSpecificGrammarData.html#a65040a9cf10c0215a71028a56f1e00af" title="ucam::hifst::SentenceSpecific\lGrammarData::isAcceptedByVocabulary" alt="" coords="445,5,699,49"/><area shape="rect" id="node9" href="hifst_8task_8grammar_8gtest_8cpp.html#a271cf0fb4127da9be4f1416924aa206d" title="TEST" alt="" coords="545,79,599,107"/><area shape="rect" id="node13" href="structucam_1_1hifst_1_1GrammarData.html#aedbb12acdb0b8eee047c0ca71b466987" title="Returns the non&#45;terminal mappings. For more details see getRuleMappings function. ..." alt="" coords="487,185,657,229"/><area shape="rect" id="node15" href="structucam_1_1hifst_1_1SentenceSpecificGrammarData.html#aa251678f01ec03a4cf92e0c63b6c77ce" title="Returns the non&#45;terminal mappings for a rule. For more details see getRuleMappings function..." alt="" coords="747,126,939,170"/><area shape="rect" id="node19" href="hifst_8task_8grammar_8gtest_8cpp.html#a83fd73f97d5ed6a83efa0888289fffbe" title="TEST" alt="" coords="816,193,869,221"/><area shape="rect" id="node17" href="hifst_8task_8ssgrammar_8gtest_8cpp.html#ae2ba325e99de079e5f9ad98cbfe5e68a" title="TEST" alt="" coords="988,134,1041,162"/></map>
</div>
</p>

</div>
</div>
<a class="anchor" id="a6e43dd38d664aa8701b48168758a66e0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ucam::hifst::phraseIsTerminalWord </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>phrase</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convenience function to detect whether a phrase is actually a single word. IMPORTANT: By convention, non-terminals have a first capital letter followed by any number of letters/numbers. If the last character is a number, it will be considered as an index, not therefore in the definition of the non-terminal, e.g. X,X1,X2 are all X. </p>

<p>Definition at line <a class="el" href="data_8ssgrammar_8hpp_source.html#l00234">234</a> of file <a class="el" href="data_8ssgrammar_8hpp_source.html">data.ssgrammar.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2d183a19ce39056940dc5a607523ed01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ucam::hifst::setScales </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classucam_1_1util_1_1RegistryPO.html">ucam::util::RegistryPO</a> &amp;&#160;</td>
          <td class="paramname"><em>rg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned *&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lmscales</em> = <code><a class="el" href="namespaceHifstConstants.html#a41f9243c4b6a35530c5b8e1c76c1104f">HifstConstants::kLmFeatureweights</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>grammarscales</em> = <code><a class="el" href="namespaceHifstConstants.html#a4b971ec2c3a86807f5fc4bdf0ca90317">HifstConstants::kRuleflowerlatticeFeatureweights</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>featureweights</em> = <code><a class="el" href="namespaceHifstConstants.html#af706d863d7dce966d3dd48ec6ff56f4b">HifstConstants::kFeatureweights</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>lmload</em> = <code><a class="el" href="namespaceHifstConstants.html#a37a650ce4c4cf67354de7b1466d60ae0">HifstConstants::kLmLoad</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets scales using environment parameter (see sparse tuple weight semiring file), or grammar scales and language model scales. If these are active, the environment parameter will not be used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">offset</td><td>The number of language models will be stored here, as an offset for the grammar scales in the sparse tropical tuple weight semiring </td></tr>
    <tr><td class="paramname">lmscales</td><td>Key to access registry object with commandline parameter for language model scales </td></tr>
    <tr><td class="paramname">grammarscales</td><td>Key to access registry object with commandline parameter for grammar scales </td></tr>
  </table>
  </dd>
</dl>
<p>Dump scales </p>

<p>Definition at line <a class="el" href="main-run_8alilats2splats_8hpp_source.html#l00037">37</a> of file <a class="el" href="main-run_8alilats2splats_8hpp_source.html">main-run.alilats2splats.hpp</a>.</p>

<p><div class="dynheader">
Here is the call graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceucam_1_1hifst_a2d183a19ce39056940dc5a607523ed01_cgraph.png" border="0" usemap="#namespaceucam_1_1hifst_a2d183a19ce39056940dc5a607523ed01_cgraph" alt=""/></div>
<map name="namespaceucam_1_1hifst_a2d183a19ce39056940dc5a607523ed01_cgraph" id="namespaceucam_1_1hifst_a2d183a19ce39056940dc5a607523ed01_cgraph">
<area shape="rect" id="node3" href="classucam_1_1util_1_1RegistryPO.html#ab0608436641ce579fbfe53480df0d5af" title="Returns parsed value associated to key. " alt="" coords="203,5,376,33"/><area shape="rect" id="node7" href="classfst_1_1TropicalSparseTupleWeight.html#abfb92203c1bc7fb54414671a2aac2e6d" title="fst::TropicalSparseTuple\lWeight::Params" alt="" coords="208,55,371,99"/><area shape="rect" id="node9" href="classucam_1_1util_1_1RegistryPO.html#a181d19bcfff8b119c23fc2661f823923" title="Performs get&lt;string&gt; and checks whether the real value is to be loaded from file (–param=file://.....) " alt="" coords="215,122,364,166"/><area shape="rect" id="node13" href="classucam_1_1util_1_1RegistryPO.html#a498b76353f978a417809cc13bdce9954" title="Convenience method that returns a vector of strings taking &quot;,&quot; as the separator character. " alt="" coords="215,189,364,233"/><area shape="rect" id="node15" href="classucam_1_1util_1_1RegistryPO.html#a72d753211a30f0a1720a52e609780b37" title="Determines whether a program option (key) has been defined by the user. " alt="" coords="215,255,364,299"/><area shape="rect" id="node5" href="namespaceucam_1_1util.html#a63f2e665e982de5cc1e2a601cb559de1" title="Convenience function to find out whether a needle exists in a text. " alt="" coords="427,5,544,33"/><area shape="rect" id="node11" href="namespaceucam_1_1util.html#aef82883338c5fc4ac93ee7ce8a72b683" title="ucam::util::getline" alt="" coords="425,130,545,158"/></map>
</div>
</p>

<p><div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="namespaceucam_1_1hifst_a2d183a19ce39056940dc5a607523ed01_icgraph.png" border="0" usemap="#namespaceucam_1_1hifst_a2d183a19ce39056940dc5a607523ed01_icgraph" alt=""/></div>
<map name="namespaceucam_1_1hifst_a2d183a19ce39056940dc5a607523ed01_icgraph" id="namespaceucam_1_1hifst_a2d183a19ce39056940dc5a607523ed01_icgraph">
<area shape="rect" id="node3" href="classucam_1_1hifst_1_1SingleThreadedAliLatsToSparseVecLatsTask.html#ab467354e6703f4e59792dcc7f08b8229" title="Reads an input sentence, tokenizes and integer&#45;maps. " alt="" coords="203,54,424,98"/><area shape="rect" id="node9" href="classucam_1_1hifst_1_1MultiThreadedAliLatsToSparseVecLatsTask.html#a20f7da724c08a4123cd52356615cd085" title="ucam::hifst::MultiThreaded\lAliLatsToSparseVecLatsTask::run" alt="" coords="203,121,424,165"/><area shape="rect" id="node5" href="classucam_1_1hifst_1_1SingleThreadedAliLatsToSparseVecLatsTask.html#adb2430e4c32393732ad0ad22ea439a6a" title="ucam::hifst::SingleThreaded\lAliLatsToSparseVecLatsTask\l::operator()" alt="" coords="472,5,669,65"/><area shape="rect" id="node7" href="classucam_1_1hifst_1_1MultiThreadedAliLatsToSparseVecLatsTask.html#a6d3184a0c84c8bd77133ffba9f2678a2" title="ucam::hifst::MultiThreaded\lAliLatsToSparseVecLatsTask\l::operator()" alt="" coords="472,87,669,147"/></map>
</div>
</p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a class="anchor" id="a19b24ba8c4e8921cbea11859fdb5fb71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int ucam::hifst::max_length = 1024</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="main-run_8createssgrammar_8hpp_source.html#l00029">29</a> of file <a class="el" href="main-run_8createssgrammar_8hpp_source.html">main-run.createssgrammar.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceucam.html">ucam</a></li><li class="navelem"><a class="el" href="namespaceucam_1_1hifst.html">hifst</a></li>
    <li class="footer">Generated on Sat Sep 19 2015 19:03:16 for Cambridge SMT System by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
