<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Cambridge SMT System: Appendices</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Cambridge SMT System
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('appendices.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Appendices </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="gext"></a>
Using Grammars From Open Source SMT Systems</h1>
<p>The current release of HiFST does not include our rule extraction system. For this tutorial, we demonstrate how to convert grammars obtained from other systems into the HiFST format. All files following the above format can be used in HiFST. Here we briefly introduce ways for adapting SCFGs generated by several existing SMT systems to the HiFST format.</p>
<h2><a class="anchor" id="gext_moses"></a>
Moses</h2>
<p><a href="http://www.statmt.org/moses/">http://www.statmt.org/moses/</a></p>
<p>The Moses package provides utilities for both phrase extraction and hierarchical rule extraction. Suppose that we have a pair of sentences and the word-level alignment between them: </p><pre class="fragment"> SOURCE    = 61 10717 3267 486 3 6501 3 53 1230 44 4 902 7631 2213 16 2265 319 5
 TARGET    = 71 29 5558 5494 831 3 1331 2242 7 1250 5 1003 13 439 8 5663 601 4 712 4 7 86 6
 ALIGNMENT = 0-0 0-1 1-2 2-3 8-3 1-4 10-5 11-6 12-7 13-7 14-8 16-9 15-11 16-13 1-15 3-16 4-17 5-18 6-19 7-21 17-22
</pre><p>We can obtain a phrase translation table using Moses, like this,</p>
<pre class="fragment">  ...
  44 4 902 7631 2213 ||| 3 1331 2242 ||| 0.5 0.25 1 1 2.718 ||| ||| 2 1
  44 4 902 ||| 3 1331 ||| 0.5 1 1 1 2.718 ||| ||| 2 1
  44 4 ||| 3 ||| 0.5 1 1 1 2.718 ||| ||| 2 1
  ...
</pre><p>It is trivial to transform the above phrase pairs into the HiFST rules: we only need to introduce a non-terminal symbol into the LHSs of the rules. Here we take X as the only one non-terminal symbol. Then we concatenate the sequence of words with an underscore <code>_</code> on both language sides, e.g., <code>44 4 902 7631 2213</code> =&gt; <code>44_4_902_7631_2213</code>. Then the weights can be used by performing a -log() computation to fit for the tropical semiring used in HiFST.</p>
<p>Note that HiFST prefers the use of target-word count as a feature in the SCFG to eliminate the bias towards short sentences caused by the use of n-gram language model. So here we add the negative target-word count into the weight vector as a new feature, e.g, for the first phrase pair, the first weight should be -3 (i.e., minus target-word number). By using the above methods, we get the rules in the HiFST format, as follows </p><pre class="fragment"> ...
 X 44_4_902_7631_2213 3_1331_2242 -3 0.693 1.386 0 0 -1
 X 44_4_902 3_1331 -2 -0.693 0 0 0 -1
 X 44_4 3 -1 -0.693 0 0 0 -1
 ...
</pre><p>In addition to the phrasal translations, Moses provides a tool for hierarchical phrasal rule extraction. For the above example, the Moses hierarchical rule extractor can generate a rule file:</p>
<pre class="fragment"> ...
 44 [X][X] 16 [X] ||| [X][X] 7 [X] ||| 0.084 0.5 1 1 2.718 ||| 1-0 ||| 1.074 0.090
 44 [X][X] 16 [X][X] [X] ||| [X][X] 7 [X][X] 8 [X] ||| 0.125 0.5 0.275 0.25 2.718 ||| 1-0 3-2 ||| 0.307 0.139
 44 [X][X] 16 [X][X] [X] ||| [X][X] 7 [X][X] [X] ||| 0.128 0.5 0.724 1 2.718 ||| 1-0 3-2 ||| 0.786 0.139
 ...
</pre><p>On each language side of a rule, <code>[X]</code> represents the non-terminal symbol X of the left hand side (Note: both languages share the same LHS). <code>[X][X]</code> represents a non-terminal with a non-terminal symbol <code>X</code>. If more than one non-terminals are involved, we need the alignment information to determine the relative order of non-terminals. This can be found in the 4-th field of each rule. E.g., for the second rule in the above example, we can access the alignment information "1-0 3-2" and know that it is a monotonic translation rule. Hence all these hierarchical phrasal rules in Moses can be transformed into the rules used in HiFST, like so </p><pre class="fragment"> ...
 X 44_X_16 X_7 -1 2.476 0.693 0 0 -1
 X 44_X1_16_X2 X1_7_X2_8 -2 2.079 0.693 1.290 1.386 -1
 X 44_X1_16_X2 X1_7_X2 -1 2.055 0.693 0.322 0 -1
 ...
</pre><p>As HiFST uses a single grammar file as input, we can concatenate the phrase translation file and the hierarchical rule file to form the final SCFG file.</p>
<h2><a class="anchor" id="gext_joshua"></a>
Joshua and cdec</h2>
<p><a href="http://joshua-decoder.org/">http://joshua-decoder.org/</a> and <a href="http://cdec-decoder.org/index.php?title=Main_Page">http://cdec-decoder.org/index.php?title=Main_Page</a></p>
<p>Joshua and cdec support a different definition of SCFG files, where each rule follows the format of </p><pre class="fragment">[LHS] ||| RHS_SOURCE ||| RHS_TARGET ||| FEATURES(WEIGHTS)
</pre><p>For the above example, one can obtain the following rule file in the Joshua format.</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;...</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;[X] ||| 44 4 902 7631 2213 ||| 3 1331 2242 ||| -0.693 -1.386 0 0 1</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;[X] ||| 44 4 902 ||| 3 1331 ||| 0.693 0 0 0 1</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;[X] ||| 44 4 ||| 3 ||| 0.693 0 0 0 1</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;...</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;[X] ||| 44 [X,1] 16 ||| [X,1] 7 ||| -2.476 -0.693 0 0 1</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;[X] ||| 44 [X,1] 16 [X,2] ||| [X,1] 7 [X,2] 8 ||| -2.079 -0.693 -1.290 -1.386 1</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;[X] ||| 44 [X,1] 16 [X,2] ||| [X,1] 7 [X,2] ||| -2.055 -0.693 -0.322 0  1</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;...</div></div><!-- fragment --><p>Here <code>[X]</code> represents the non-terminal symbol on the left-hand side of a rule. <code>[X,n]</code> represents a non-terminal on the right hand side, where n is an index to determine the non-terminal order. All features(weights) are in log-scale. So we use minus operation to fit them into the weight definition preferred by HiFST. Also, the (minus) target-word number is added as an additional feature. For this Joshua version of the SCFG file, we can transform it into the HiFST-style file:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;...</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;X 44_4_902_7631_2213 3_1331_2242 -3 0.693 1.386 0 0 -1</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;X 44_4_902 3_1331 -2 -0.693 0 0 0 -1</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;X 44_4 3 -1 -0.693 0 0 0 -1</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;...</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;X 44_X_16 X_7 -1 2.476 0.693 0 0 -1</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;X 44_X1_16_X2 X1_7_X2_8 -2 2.079 0.693 1.290 1.386 -1</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;X 44_X1_16_X2 X1_7_X2 -1 2.055 0.693 0.322 0 -1</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;...</div></div><!-- fragment --><h2><a class="anchor" id="gext_niutrans"></a>
NiuTrans</h2>
<p><a href="http://www.nlplab.com/NiuPlan/NiuTrans.html">http://www.nlplab.com/NiuPlan/NiuTrans.html</a></p>
<p>NiuTrans uses another format for SCFG files, like</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;RHS_SOURCE ||| RHS_TARGT ||| LHS ||| FEATURE (WEIGHTS)</div></div><!-- fragment --><p>Based on the NiuTrans format, the above sample grammar can be written, as follows:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;...</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;44 4 902 7631 2213 ||| 3 1331 2242 ||| X ||| -0.693 -1.386 0 0 1</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;44 4 902 ||| 3 1331 ||| X ||| 0.693 0 0 0 1</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;44 4 ||| 3 ||| X ||| 0.693 0 0 0 1</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;...</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;44 #X 16 ||| #1 7 ||| X ||| -2.476 -0.693 0 0 1</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;44 #X 16 #X ||| #1 7 #2 8 ||| X ||| -2.079 -0.693 -1.290 -1.386 1</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;44 #X 16 #X ||| #1 7 #2 ||| X ||| -2.055 -0.693 -0.322 0  1</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;...</div></div><!-- fragment --><p>On the source-language side, each non-terminal is marked with '#', followed by its symbol. E.g., '#X' is a non-terminal with the symbol X. On the target-language side, each non-terminal is also marked with '#' but uses an integer to indicate the index of the corresponding non-terminal in the source-language side. E.g., in the last rule of the above example, #2 is a non-terminal on the target-language side. It is aligned with the second non-terminal on the source-language side and shares the symbol X with its counterpart.</p>
<p>It is not difficult to transform a NiuTrans-style grammar file into a HiFST-style grammar file. For this example, we have (the same result again)</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;...</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;X 44_4_902_7631_2213 3_1331_2242 -3 0.693 1.386 0 0 -1</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;X 44_4_902 3_1331 -2 -0.693 0 0 0 -1</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;X 44_4 3 -1 -0.693 0 0 0 -1</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;...</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;X 44_X_16 X_7 -1 2.476 0.693 0 0 -1</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;X 44_X1_16_X2 X1_7_X2_8 -2 2.079 0.693 1.290 1.386 -1</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;X 44_X1_16_X2 X1_7_X2 -1 2.055 0.693 0.322 0 -1</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;...</div></div><!-- fragment --><h1><a class="anchor" id="grammarpruning"></a>
Translation Grammar Pruning</h1>
<p>Once the grammar is obtained, one may consider to prune it for a more compact model as well as a more efficient decoding process. Note that grammar pruning is widely used in SMT systems. This is especially important for some large-scale translation tasks, e.g., training a Chinese-English SMT system on millions of sentence pairs. Without appropriate pruning, the translation speed might be unacceptable in some cases. Here we present a few tips on grammar pruning for better use of HiFST.</p>
<ol type="1">
<li>For the source-language of each phrase/rule, we can keep the top-n target-sides in terms of (source-to-target) translation probability. This method is adopted in most open source systems by default. Generally setting n = 10~30 is enough for most tasks.</li>
<li>We can prune away low frequency phrases/rules. For example, there is generally much noise in hierarchical phrase translation rules that occur once in the training data. So it is relatively "safe" to discard this type of rule.</li>
<li>Also, we can only keep hierarchical phrase rules that are extracted on a good-quality portion of the parallel corpus, that is, we still obtain phrasal translations from the whole corpus but extract hierarchical phrase rules from a smaller set of sentences.</li>
<li>Another method is to filter rules according to rule patterns. For example, both rule patterns "X -&gt; X w, X w" and "X -&gt; w X, w X" explain monotonic translation phenomena (where X is a variable and w is a sequence of words). In this case, we can throw away one of this patterns because they are actually doing the same thing.</li>
<li>In addition to rule filtering, we can also write the grammar to another form for more efficient decoding. For example, we can transform an SCFG to a sallow grammar which avoids unlimited nested structures and makes the decoding much faster. Please see next section for more discussion on shallow grammars.</li>
</ol>
<p>The reader can refer to <a class="el" href="intro.html#Iglesias2009b">Iglesias2009b</a> for more methods for grammar pruning. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed May 25 2016 10:13:37 for Cambridge SMT System by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
