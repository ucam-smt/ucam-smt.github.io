<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>Cambridge SMT System: Translation with Push-Down Automata</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Cambridge SMT System
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('pda.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Translation with Push-Down Automata </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This HiFST package can also perform decoding using Push-Down Automata (PDA) as described in [<a class="el" href="intro.html#Iglesias2011">Iglesias2011</a>, <a class="el" href="intro.html#Allauzen2014">Allauzen2014</a>]. We call this the HiPDT decoder. A brief overview of it and an example on how to use it is given next.</p>
<p>In this framework, the RTN at the top-most cell of the CYK grid is converted into a PDA (via the Replace operation in the <a class="el" href="intro.html#OpenFst">OpenFst</a> Extensions) and efficiently composed with a language model to produce another PDA. To obtain the final output FSA, the PDA is expanded to an FSA either entirely (if memory is sufficient and the language model is small enough) or via pruned expansion (for larger language models). This is useful in exploring large and complex translation grammars where HiFST requires a lot of local pruning. However, it requires the language model to be 'small' (for example, entropy-pruned as in [<a class="el" href="intro.html#Iglesias2011">Iglesias2011</a>, <a class="el" href="intro.html#Allauzen2014">Allauzen2014</a>]). Therefore, we then typically rescore the pruned output FSA with a stronger language model.</p>
<p>This whole setup can be accomplished in one single command as follows: </p>
<pre class="fragment">&gt; hifst.${TGTBINMK}.bin --config=configs/CF.hiero.pdt &amp;&gt; log/log.hiero.pdt
</pre><p>Please see the config file for the parameters needed, along with explanatory comments.</p>
<p>In this particular example, the output 1-best for the first two sentences is identical to the baseline Hiero case (with translation via RTN replacement followed by composition). However, the output lattices differ as they contain different hypotheses (due to the different pruning strategy).</p>
<h1><a class="anchor" id="pda_rtns"></a>
Recursive Transition Networks</h1>
<p>As already discussed with respect to <a class="el" href="basictrans.html#lpruning">Inadmissible Pruning</a>, HiFST generates an initial representation of the space of translation in the form of an RTN, which is then transformed either to WFSAs or to PDAs using the <a class="el" href="intro.html#OpenFst">OpenFst</a> <a href="http://openfst.org/twiki/bin/view/FST/ReplaceDoc">Replace</a> operation prior to application of the language model.</p>
<p>HiFST can save the RTNs to disk, and the language model application and shortest path operations can be carried out using the <a class="el" href="intro.html#OpenFst">OpenFst</a> command line tools.</p>
<p>For example, consider generation of the baseline lattices with the Shallow-1 translation grammar and the 4-gram language model. The command can be re-run, but with added instructions to save the RTNs to disk: </p>
<pre class="fragment">&gt; hifst.${TGTBINMK}.bin --config=configs/CF.baseline --hifst.writertn=output/exp.baseline/rtn/?/%%rtn_label%%.fst --grammar.storentorder=output/exp.baseline/rtn/ntmap  --hifst.rtnopt=yes &amp;&gt; log/log.baseline.rtn
</pre><p>The RTNs are written to the directory <code>output/exp.baseline/rtn/*</code> as </p>
<pre class="fragment">&gt; ls output/exp.baseline/rtn/1/
1001000007.fst  1003001002.fst  1003003000.fst  1003004001.fst  1003006000.fst  1004002000.fst  1004005000.fst
1003001000.fst  1003002000.fst  1003003001.fst  1003005000.fst  1003007000.fst  1004003000.fst  1004006000.fst
1003001001.fst  1003002001.fst  1003004000.fst  1003005001.fst  1004001000.fst  1004004000.fst
</pre><p>and the non-terminal mapping is written to output/exp.baseline/rtn/ntmap : </p>
<pre class="fragment">&gt; cat output/exp.baseline/rtn/ntmap
S   1
D   2
X   3
V   4
</pre><p>Each RTN name is of the form 1ABC.fst , where A, B, and C are 3-digit strings.</p>
<ul>
<li>A is the numerical code for a non-terminal in the grammar; in this case, 001 corresponds to S.</li>
<li>B indicates a position in the source sentence: 0 &lt;= B &lt; I, where I is the source sentence length</li>
<li>C indicates the offset to the end of a span, 0 &lt;= C and B+C &lt; I</li>
<li>The automata 1ABC.fst corresponds to T_(A,B,B+C) in the formulation of <a class="el" href="basictrans.html#lpruning">Inadmissible Pruning</a></li>
</ul>
<p>In this example, the automata 1003001002.fst contains all derivations headed by X, the third non-terminal, and spanning source positions 1 to 3 (=1+2).</p>
<p>The root automata is 1001000007.fst, since A=001 (the S non-terminal), B=0 (the first source position), and C=7 (the sentence has 8 words). This automata is a representation of all possible translations of the source sentence under this grammar, as can be seen by printing its paths (here the first 2): </p>
<pre class="fragment">&gt; cat output/exp.baseline/rtn/1/1001000007.fst | printstrings.${TGTBINMK}.bin --semiring=lexstdarc -u --nbest=2 2&gt;/dev/null
1 1004001000 11 384 1004003000 1004004000 1004005000 1004006000 2
1 1004001000 11 384 1003003001 1004005000 1004006000 2
</pre><p>As can be seen, the symbols are a mix of target language symbols (1,2,11,384,...) and pointers to other automata (1004001000, 1004003000, ...). Conversion of the RTN is done by recursive substitution of these symbols by the FSTs to which they point, starting from the root automata.</p>
<h1><a class="anchor" id="pda_replace"></a>
Replacement: Translation by Converting RTNs to WFSAs</h1>
<pre class="fragment"> &gt; fstreplace | head -n 3
 Recursively replaces FST arcs with other FST(s).

 Usage: fstreplace root.fst rootlabel [rule1.fst label1 ...] [out.fst]
</pre><p>Note that the root FST and root label are always of the form 1001000C, where C = I - 1 , where I is the source sentence length.</p>
<p>HiFST uses the same names for rules and labels, so we get get the filenames and labels in the right form by, e.g. </p>
<pre class="fragment"> &gt; ls output/exp.baseline/rtn/1/1*.fst | sed 's,\(.*\)/\(.*\).fst,\1/\2.fst \2,' | head -n 5
 output/exp.baseline/rtn/1/1001000007.fst 1001000007
 output/exp.baseline/rtn/1/1003001000.fst 1003001000
 output/exp.baseline/rtn/1/1003001001.fst 1003001001
 output/exp.baseline/rtn/1/1003001002.fst 1003001002
 output/exp.baseline/rtn/1/1003002000.fst 1003002000
</pre><p>The following will expand the RTN into an FSA: </p>
<pre class="fragment"> &gt; fstreplace `ls output/exp.baseline/rtn/1/1*.fst | sed 's,\(.*\)/\(.*\).fst,\1/\2.fst \2,'` &gt; output/exp.baseline/rtn/1/T.fst
</pre><p>The WFSA T is the replacement of the RTN that was generated in translation.</p>
<h1><a class="anchor" id="rtn_lm_app"></a>
Composition and Shortest Path</h1>
<p>The applylm tool can be used to apply the baseline 4-gram language model to T via composition. This generates a new WFSA containing both grammar and language model scores:</p>
<ul>
<li>Input<ul>
<li>M/lm.4g.mmap : n-gram LM</li>
<li>output/exp.baseline/rtn/1/T.fst : WFSA containing translation grammar scores</li>
</ul>
</li>
<li>Output<ul>
<li>output/exp.baseline/rtn/1/TG.fst.gz : WFSA containing translation grammar and LM scores</li>
</ul>
</li>
</ul>
<p>The output is written in the form of a transducer, with the RTN labels as the input symbols and the target language words on the output symbols:</p>
<pre class="fragment"> &gt; applylm.${TGTBINMK}.bin --lm.load=M/lm.4g.mmap --semiring=lexstdarc --lattice.load=output/exp.baseline/rtn/1/T.fst --lattice.store=output/exp.baseline/rtn/1/TG.fst.gz

 &gt; zcat output/exp.baseline/rtn/1/TG.fst.gz | fstshortestpath | fstrmepsilon | fsttopsort | fstprint
 0    1     1               1       -2.609375,-2.609375
 1    2     9121            9121    9.33318996,-1.26074219
 2    3     1004002000      0
 3    4     384             384     7.13530731,-2.609375
 4    5     1004003000      0       1.28222656,1.28222656
 5    6     6               6       -0.390115976,-3.328125
 6    7     2756            2756    9.45967484,0.288085938
 7    8     7               7       1.79730964,0
 8    9     1004004000      0
 9    10    3               3       -0.395056069,-1.23925781
 10   11    4144            4144    9.78138161,0
 11   12    6               6       0.201819927,0
 12   13    1003005001      0       3.29199219,3.29199219
 13   14    1458528         1458528 10.2062063,-1.0703125
 14   15    1004005000      0
 15   16    1341            1341    6.04568958,1.55957031
 16   17    2               2       2.33047056,-2.34277344
 17
</pre><p>To see the translation alone, we project to the output symbols: </p>
<pre class="fragment">&gt; zcat output/exp.baseline/rtn/1/TG.fst.gz | fstproject --project_output | printstrings.${TGTBINMK}.bin --semiring=lexstdarc -w -m wmaps/wmt13.en.wmap 2&gt;/dev/null
&lt;s&gt; republican strategy of resistance to the renewal of obamas election &lt;/s&gt;                        57.4707,-8.03809
</pre><p>which should agree with the previously generated contents of output/exp.baseline/LATS/1.fst.gz produced by the baseline system: </p>
<pre class="fragment">&gt; zcat output/exp.baseline/LATS/1.fst.gz | printstrings.${TGTBINMK}.bin --semiring=lexstdarc -w -m wmaps/wmt13.en.wmap 2&gt;/dev/null
&lt;s&gt; republican strategy of resistance to the renewal of obamas election &lt;/s&gt;             57.4707,-8.03809
</pre><h1><a class="anchor" id="pda_expand"></a>
Expansion: Translation by Composition of PDAs and WFSAs followed by Pruned Expansion</h1>
<p>When using PDTs, the decoding process differs from the above in that the RTN is not expanded to an FSA prior to composition with the LM. Instead, HiPDT replaces the RTN by a PDA, which is efficiently composed with the LM to produce another PDA. Finally, this resulting PDA is converted to the final translation FSA via pruned expansion.</p>
<p>As explained in the example of <a class="el" href="pda.html">Translation with Push-Down Automata</a>, this process is done by the decoder in one go. For explanatory reasons, here we reproduce it externally for one sentence via the command line.</p>
<p>(Note: as of March 2014 we have not managed to make the OpenFST PDT command line operations work well with our lexicographic library, so the standard tropical semirring must be used in this example. This makes it slightly more complex than it should be, but we believe it is useful to understand HiPDT anyway)</p>
<p>First, we dump the RTN for the full hiero grammar as follows: </p>
<pre class="fragment">&gt; hifst.${TGTBINMK}.bin --config=configs/CF.hiero --hifst.writertn=output/exp.hiero/rtn/?/%%rtn_label%%.fst --grammar.storentorder=output/exp.hiero/rtn/ntmap --hifst.rtnopt=yes &amp;&gt; log/log.hiero.rtn
</pre><p>Then, we ensure that the RTN files are in the tropical semiring: </p>
<pre class="fragment">&gt; mkdir -p output/exp.hiero/rtn-tp/1 output/exp.hiero/rtn-tp/2
&gt; pushd output/exp.hiero/rtn/ ; for f in ?/100*.fst; do cat $f | lexmap.${TGTBINMK}.bin --action=lex2std &gt; ../rtn-tp/$f; done; popd
</pre><p>The PDT is then created as follows: </p>
<pre class="fragment">&gt; for f in 1 2; do pdtreplace --pdt_parentheses=output/exp.hiero/rtn-tp/$f/parens.txt `ls output/exp.hiero/rtn-tp/$f/1*.fst | sed 's,\(.*\)/\(.*\).fst,\1/\2.fst \2,'` &gt; output/exp.hiero/rtn-tp/$f/T.pdt; done
</pre><p>where the `pdt_parentheses' option indicates that the open/close parentheses symbols are to be stored into a file. This is used later in order to expand the PDA to an FSA.</p>
<p>Then the PDA is composed with the weak language model. This is done via the standard composition algorithm, but making sure that open/close parentheses symbols are treated as epsilons by the composition algorithm. To accomplish this, their respective output symbols need to be relabel to 0 before applying the LM: </p>
<pre class="fragment">&gt; for f in 1 2; do cat output/exp.hiero/rtn-tp/1/parens.txt | tr '\t' '\n' | sed 's/$/\t0/' &gt; output/exp.hiero/rtn-tp/$f/parens-to-epsilon.txt ;
&gt; cat output/exp.hiero/rtn-tp/$f/T.pdt | fstrelabel -relabel_opairs=output/exp.hiero/rtn-tp/$f/parens-to-epsilon.txt &gt; output/exp.hiero/rtn-tp/$f/Tb.pdt
&gt; applylm.${TGTBINMK}.bin --lm.load=M/lm.4g.eprnd.mmap --lattice.load=output/exp.hiero/rtn-tp/$f/Tb.pdt --lattice.store=output/exp.hiero/rtn-tp/$f/TG.pdt ;
&gt; done
</pre><p>Then the resulting PDT is expanded into an FSA while applying a pruning weight of 9: </p>
<pre class="fragment">&gt; for f in 1 2; do fstproject output/exp.hiero/rtn-tp/$f/TG.pdt | pdtexpand --pdt_parentheses=output/exp.hiero/rtn-tp/$f/parens.txt --weight=9 &gt; output/exp.hiero/rtn-tp/$f/TG.fst ; done
</pre><p>Finally, the weak LM is removed and the full LM is applied: </p>
<pre class="fragment">&gt; for f in 1 2; do applylm.${TGTBINMK}.bin --lm.load=M/lm.4g.eprnd.mmap --lm.featureweights=-1 --lattice.load=output/exp.hiero/rtn-tp/$f/TG.fst --lattice.store=output/exp.hiero/rtn-tp/$f/TG-nolm.fst ; applylm.${TGTBINMK}.bin --lm.load=M/lm.4g.mmap --lattice.load=output/exp.hiero/rtn-tp/$f/TG-nolm.fst --lattice.store=output/exp.hiero/rtn-tp/$f/TG-final.fst ; done
</pre><p>The final FSA that results from this process (<code>output/exp.hiero/rtn-tp/1/TG-final.fst</code>) should be equivalent to the one obtained by HiPDT (<code>output/exp.hiero.pdt/LATS/1.fst.gz</code>) except for numerical differences. Their 1-best hypothesis can be obtained as follows: </p>
<pre class="fragment">&gt; zcat output/exp.hiero.pdt/LATS/1.fst.gz | printstrings.${TGTBINMK}.bin --semiring=lexstdarc -w -m wmaps/wmt13.en.wmap 2&gt;/dev/null
&lt;s&gt; the republican strategy of resistance to the renewal of obama 's election &lt;/s&gt;  55.2515,-11.6445

&gt; cat output/exp.hiero/rtn-tp/1/TG-final.fst | printstrings.${TGTBINMK}.bin -w -m wmaps/wmt13.en.wmap 2&gt;/dev/null
    &lt;s&gt; the republican strategy of resistance to the renewal of obama 's election &lt;/s&gt;      55.2515</pre> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated on Wed Feb 18 2015 01:42:51 for Cambridge SMT System by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
