

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>cam.sgnmt.predictors.automata &mdash; SGNMT 0.5 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../../_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="../../../../_static/custom.css" type="text/css" />
  

  
    <link rel="top" title="SGNMT 0.5 documentation" href="../../../../index.html"/>
        <link rel="up" title="Module code" href="../../../index.html"/> 

  
  <script src="../../../../_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="../../../../index.html" class="icon icon-home"> SGNMT
          

          
          </a>

          
            
            
              <div class="version">
                0.5
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../../setup.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../tutorial.html">Tutorial: Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../adding_components.html">Tutorial: Adding new components</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../kyoto_nmt.html">Tutorial:  NMT decoding strategies</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../command_line.html">Command-line reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../predictors.html">Predictors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../decoders.html">Decoders</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../faq.html">Common issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../publications.html">Publications</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../../cam.sgnmt.html">All modules</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../../index.html">SGNMT</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          





<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../../index.html">Docs</a> &raquo;</li>
      
          <li><a href="../../../index.html">Module code</a> &raquo;</li>
      
    <li>cam.sgnmt.predictors.automata</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <h1>Source code for cam.sgnmt.predictors.automata</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;This module encapsulates the predictor interface to OpenFST. This</span>
<span class="sd">module depends on OpenFST. To enable Python support in OpenFST, use a </span>
<span class="sd">recent version (&gt;=1.5.4) and compile with ``--enable_python``. </span>
<span class="sd">Further information can be found here:</span>

<span class="sd">http://www.openfst.org/twiki/bin/view/FST/PythonExtension </span>

<span class="sd">This file includes the fst, nfst, and rtn predictors.</span>

<span class="sd">Note: If we use arc weights in FSTs, we multiply them by -1 as </span>
<span class="sd">everything in SGNMT is logprob, not -logprob as in FSTs log </span>
<span class="sd">or tropical semirings. You can disable this behavior with --fst_to_log</span>

<span class="sd">Note2: The FSTs and RTNs are assumed to have both &lt;S&gt; and &lt;/S&gt;. This </span>
<span class="sd">has compatibility reasons, as lattices generated by HiFST have these</span>
<span class="sd">symbols.</span>
<span class="sd">&quot;&quot;&quot;</span>

<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>

<span class="kn">from</span> <span class="nn">cam.sgnmt</span> <span class="kn">import</span> <span class="n">utils</span>
<span class="kn">from</span> <span class="nn">cam.sgnmt.predictors.core</span> <span class="kn">import</span> <span class="n">Predictor</span>
<span class="kn">from</span> <span class="nn">cam.sgnmt.utils</span> <span class="kn">import</span> <span class="n">w2f</span><span class="p">,</span> <span class="n">load_fst</span>
<span class="kn">import</span> <span class="nn">pywrapfst</span> <span class="kn">as</span> <span class="nn">fst</span>


<span class="n">EPS_ID</span> <span class="o">=</span> <span class="mi">0</span>
<span class="sd">&quot;&quot;&quot;OpenFST&#39;s reserved ID for epsilon arcs. &quot;&quot;&quot;</span>


<div class="viewcode-block" id="FstPredictor"><a class="viewcode-back" href="../../../../predictors.html#cam.sgnmt.predictors.automata.FstPredictor">[docs]</a><span class="k">class</span> <span class="nc">FstPredictor</span><span class="p">(</span><span class="n">Predictor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This predictor can read determinized translation lattices. The</span>
<span class="sd">    predictor state consists of the current node. This is unique as the</span>
<span class="sd">    lattices are determinized.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">fst_path</span><span class="p">,</span>
                 <span class="n">use_weights</span><span class="p">,</span>
                 <span class="n">normalize_scores</span><span class="p">,</span>
                 <span class="n">skip_bos_weight</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span>
                 <span class="n">to_log</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a new fst predictor.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            fst_path (string): Path to the FST file</span>
<span class="sd">            use_weights (bool): If false, replace all arc weights with</span>
<span class="sd">                                0 (=log 1).</span>
<span class="sd">            normalize_scores (bool): If true, we normalize the weights</span>
<span class="sd">                                     on all outgoing arcs such that</span>
<span class="sd">                                     they sum up to 1</span>
<span class="sd">            skip_bos_weight (bool): Add the score at the &lt;S&gt; arc to the</span>
<span class="sd">                                    &lt;/S&gt; arc if this is false. This results</span>
<span class="sd">                                    in scores consistent with </span>
<span class="sd">                                    OpenFST&#39;s replace operation,</span>
<span class="sd">                                    as &lt;S&gt; scores are normally</span>
<span class="sd">                                    ignored by SGNMT.</span>
<span class="sd">            to_log (bool): SGNMT uses normal log probs (scores) while</span>
<span class="sd">                           arc weights in FSTs normally have cost (i.e.</span>
<span class="sd">                           neg. log values) semantics. Therefore, if</span>
<span class="sd">                           true, we multiply arc weights by -1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">FstPredictor</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fst_path</span> <span class="o">=</span> <span class="n">fst_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight_factor</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="k">if</span> <span class="n">to_log</span> <span class="k">else</span> <span class="mf">1.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_weights</span> <span class="o">=</span> <span class="n">use_weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normalize_scores</span> <span class="o">=</span> <span class="n">normalize_scores</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cur_fst</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">add_bos_to_eos_score</span> <span class="o">=</span> <span class="ow">not</span> <span class="n">skip_bos_weight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cur_node</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        
<div class="viewcode-block" id="FstPredictor.get_unk_probability"><a class="viewcode-back" href="../../../../predictors.html#cam.sgnmt.predictors.automata.FstPredictor.get_unk_probability">[docs]</a>    <span class="k">def</span> <span class="nf">get_unk_probability</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">posterior</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Always returns negative infinity: Words outside the </span>
<span class="sd">        translation lattice are not possible according to this</span>
<span class="sd">        predictor.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            float. Negative infinity</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">NEG_INF</span> </div>
    
<div class="viewcode-block" id="FstPredictor.predict_next"><a class="viewcode-back" href="../../../../predictors.html#cam.sgnmt.predictors.automata.FstPredictor.predict_next">[docs]</a>    <span class="k">def</span> <span class="nf">predict_next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Uses the outgoing arcs from the current node to build up the</span>
<span class="sd">        scores for the next word.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            dict. Set of words on outgoing arcs from the current node</span>
<span class="sd">            together with their scores, or an empty set if we currently</span>
<span class="sd">            have no active node or fst.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cur_node</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="p">{</span><span class="n">arc</span><span class="o">.</span><span class="n">olabel</span><span class="p">:</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_factor</span><span class="o">*</span><span class="n">w2f</span><span class="p">(</span><span class="n">arc</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">arc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cur_fst</span><span class="o">.</span><span class="n">arcs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cur_node</span><span class="p">)}</span>
        <span class="k">if</span> <span class="n">utils</span><span class="o">.</span><span class="n">EOS_ID</span> <span class="ow">in</span> <span class="n">scores</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">add_bos_to_eos_score</span><span class="p">:</span>
            <span class="n">scores</span><span class="p">[</span><span class="n">utils</span><span class="o">.</span><span class="n">EOS_ID</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bos_score</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">finalize_posterior</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">use_weights</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalize_scores</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="FstPredictor.initialize"><a class="viewcode-back" href="../../../../predictors.html#cam.sgnmt.predictors.automata.FstPredictor.initialize">[docs]</a>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_sentence</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Loads the FST from the file system and consumes the start</span>
<span class="sd">        of sentence symbol. </span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            src_sentence (list):  Not used</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cur_fst</span> <span class="o">=</span> <span class="n">load_fst</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">get_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fst_path</span><span class="p">,</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">current_sen_id</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cur_node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cur_fst</span><span class="o">.</span><span class="n">start</span><span class="p">()</span> <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cur_fst</span> <span class="k">else</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">bos_score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">consume</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">GO_ID</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">bos_score</span><span class="p">:</span> <span class="c1"># Override None</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">bos_score</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cur_node</span> <span class="ow">is</span> <span class="bp">None</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The lattice for sentence </span><span class="si">%d</span><span class="s2"> does not contain any &quot;</span>
                         <span class="s2">&quot;valid path. Please double-check that the lattice &quot;</span>
                         <span class="s2">&quot;is not empty and that paths the begin-of-&quot;</span>
                         <span class="s2">&quot;sentence symbol </span><span class="si">%d</span><span class="s2">. If you are using a different &quot;</span>
                         <span class="s2">&quot;begin-of-sentence symbol, double-check --indexing_&quot;</span>
                         <span class="s2">&quot;scheme.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_sen_id</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">utils</span><span class="o">.</span><span class="n">GO_ID</span><span class="p">))</span></div>
    
<div class="viewcode-block" id="FstPredictor.consume"><a class="viewcode-back" href="../../../../predictors.html#cam.sgnmt.predictors.automata.FstPredictor.consume">[docs]</a>    <span class="k">def</span> <span class="nf">consume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Updates the current node by following the arc labelled with</span>
<span class="sd">        ``word``. If there is no such arc, we set ``cur_node`` to -1,</span>
<span class="sd">        indicating that the predictor is in an invalid state. In this</span>
<span class="sd">        case, all subsequent ``predict_next`` calls will return the</span>
<span class="sd">        empty set.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            word (int): Word on an outgoing arc from the current node</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            float. Weight on the traversed arc</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cur_node</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">from_state</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cur_node</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cur_node</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">for</span> <span class="n">arc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cur_fst</span><span class="o">.</span><span class="n">arcs</span><span class="p">(</span><span class="n">from_state</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">arc</span><span class="o">.</span><span class="n">olabel</span> <span class="o">==</span> <span class="n">word</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cur_node</span> <span class="o">=</span> <span class="n">arc</span><span class="o">.</span><span class="n">nextstate</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_factor</span><span class="o">*</span><span class="n">w2f</span><span class="p">(</span><span class="n">arc</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="FstPredictor.get_state"><a class="viewcode-back" href="../../../../predictors.html#cam.sgnmt.predictors.automata.FstPredictor.get_state">[docs]</a>    <span class="k">def</span> <span class="nf">get_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the current node. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cur_node</span></div>
    
<div class="viewcode-block" id="FstPredictor.set_state"><a class="viewcode-back" href="../../../../predictors.html#cam.sgnmt.predictors.automata.FstPredictor.set_state">[docs]</a>    <span class="k">def</span> <span class="nf">set_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the current node. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cur_node</span> <span class="o">=</span> <span class="n">state</span></div>

<div class="viewcode-block" id="FstPredictor.initialize_heuristic"><a class="viewcode-back" href="../../../../predictors.html#cam.sgnmt.predictors.automata.FstPredictor.initialize_heuristic">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_heuristic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_sentence</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a matrix of shortest distances between nodes. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distances</span> <span class="o">=</span> <span class="n">fst</span><span class="o">.</span><span class="n">shortestdistance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cur_fst</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="FstPredictor.estimate_future_cost"><a class="viewcode-back" href="../../../../predictors.html#cam.sgnmt.predictors.automata.FstPredictor.estimate_future_cost">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_future_cost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hypo</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The FST predictor comes with its own heuristic function. We</span>
<span class="sd">        use the shortest path in the fst as future cost estimator. &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">cur_node</span><span class="p">:</span>
            <span class="k">return</span> <span class="mf">0.0</span>
        <span class="n">last_word</span> <span class="o">=</span> <span class="n">hypo</span><span class="o">.</span><span class="n">trgt_sentence</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">arc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cur_fst</span><span class="o">.</span><span class="n">arcs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cur_node</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">arc</span><span class="o">.</span><span class="n">olabel</span> <span class="o">==</span> <span class="n">last_word</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">w2f</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">[</span><span class="n">arc</span><span class="o">.</span><span class="n">nextstate</span><span class="p">])</span>
        <span class="k">return</span> <span class="mf">0.0</span></div>
    
<div class="viewcode-block" id="FstPredictor.is_equal"><a class="viewcode-back" href="../../../../predictors.html#cam.sgnmt.predictors.automata.FstPredictor.is_equal">[docs]</a>    <span class="k">def</span> <span class="nf">is_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state1</span><span class="p">,</span> <span class="n">state2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns true if the current node is the same &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">state1</span> <span class="o">==</span> <span class="n">state2</span></div></div>


<div class="viewcode-block" id="NondeterministicFstPredictor"><a class="viewcode-back" href="../../../../predictors.html#cam.sgnmt.predictors.automata.NondeterministicFstPredictor">[docs]</a><span class="k">class</span> <span class="nc">NondeterministicFstPredictor</span><span class="p">(</span><span class="n">Predictor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;This predictor can handle non-deterministic translation </span>
<span class="sd">    lattices. In contrast to the fst predictor for deterministic</span>
<span class="sd">    lattices, we store a set of nodes which are all reachable from</span>
<span class="sd">    the start node through the current history.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                 <span class="n">fst_path</span><span class="p">,</span> 
                 <span class="n">use_weights</span><span class="p">,</span> 
                 <span class="n">normalize_scores</span><span class="p">,</span> 
                 <span class="n">skip_bos_weight</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span> 
                 <span class="n">to_log</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a new nfst predictor.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            fst_path (string): Path to the FST file</span>
<span class="sd">            use_weights (bool): If false, replace all arc weights with</span>
<span class="sd">                                0 (=log 1).</span>
<span class="sd">            normalize_scores (bool): If true, we normalize the weights</span>
<span class="sd">                                     on all outgoing arcs such that</span>
<span class="sd">                                     they sum up to 1</span>
<span class="sd">            skip_bos_weight (bool): If true, set weights on &lt;S&gt; arcs</span>
<span class="sd">                                    to 0 (= log1)</span>
<span class="sd">            to_log (bool): SGNMT uses normal log probs (scores) while</span>
<span class="sd">                           arc weights in FSTs normally have cost (i.e.</span>
<span class="sd">                           neg. log values) semantics. Therefore, if</span>
<span class="sd">                           true, we multiply arc weights by -1.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">NondeterministicFstPredictor</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fst_path</span> <span class="o">=</span> <span class="n">fst_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight_factor</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="k">if</span> <span class="n">to_log</span> <span class="k">else</span> <span class="mf">1.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">score_max_func</span> <span class="o">=</span> <span class="nb">max</span> <span class="k">if</span> <span class="n">to_log</span> <span class="k">else</span> <span class="nb">min</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_weights</span> <span class="o">=</span> <span class="n">use_weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">skip_bos_weight</span> <span class="o">=</span> <span class="n">skip_bos_weight</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normalize_scores</span> <span class="o">=</span> <span class="n">normalize_scores</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cur_fst</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cur_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        
<div class="viewcode-block" id="NondeterministicFstPredictor.get_unk_probability"><a class="viewcode-back" href="../../../../predictors.html#cam.sgnmt.predictors.automata.NondeterministicFstPredictor.get_unk_probability">[docs]</a>    <span class="k">def</span> <span class="nf">get_unk_probability</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">posterior</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Always returns negative infinity: Words outside the </span>
<span class="sd">        translation lattice are not possible according to this</span>
<span class="sd">        predictor.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            float. Negative infinity</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">NEG_INF</span> </div>
    
<div class="viewcode-block" id="NondeterministicFstPredictor.predict_next"><a class="viewcode-back" href="../../../../predictors.html#cam.sgnmt.predictors.automata.NondeterministicFstPredictor.predict_next">[docs]</a>    <span class="k">def</span> <span class="nf">predict_next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Uses the outgoing arcs from all current node to build up the</span>
<span class="sd">        scores for the next word. This method does not follow epsilon</span>
<span class="sd">        arcs: ``consume`` updates ``cur_nodes`` such that all reachable</span>
<span class="sd">        arcs with word ids are connected directly with a node in</span>
<span class="sd">        ``cur_nodes``. If there are multiple arcs with the same word,</span>
<span class="sd">        we use the log sum of the arc weights as score.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            dict. Set of words on outgoing arcs from the current node</span>
<span class="sd">            together with their scores, or an empty set if we currently</span>
<span class="sd">            have no active nodes or fst.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">scores</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">weight</span><span class="p">,</span><span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cur_nodes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">arc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cur_fst</span><span class="o">.</span><span class="n">arcs</span><span class="p">(</span><span class="n">node</span><span class="p">):</span> 
                <span class="k">if</span> <span class="n">arc</span><span class="o">.</span><span class="n">olabel</span> <span class="o">!=</span> <span class="n">EPS_ID</span><span class="p">:</span>
                    <span class="n">score</span> <span class="o">=</span> <span class="n">weight</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_factor</span><span class="o">*</span><span class="n">w2f</span><span class="p">(</span><span class="n">arc</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span> 
                    <span class="k">if</span> <span class="n">arc</span><span class="o">.</span><span class="n">olabel</span> <span class="ow">in</span> <span class="n">scores</span><span class="p">:</span>
                        <span class="n">scores</span><span class="p">[</span><span class="n">arc</span><span class="o">.</span><span class="n">olabel</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">score_max_func</span><span class="p">(</span>
                                        <span class="n">scores</span><span class="p">[</span><span class="n">arc</span><span class="o">.</span><span class="n">olabel</span><span class="p">],</span> <span class="n">score</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">scores</span><span class="p">[</span><span class="n">arc</span><span class="o">.</span><span class="n">olabel</span><span class="p">]</span> <span class="o">=</span> <span class="n">score</span> 
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">finalize_posterior</span><span class="p">(</span><span class="n">scores</span><span class="p">,</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">use_weights</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">normalize_scores</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="NondeterministicFstPredictor.initialize"><a class="viewcode-back" href="../../../../predictors.html#cam.sgnmt.predictors.automata.NondeterministicFstPredictor.initialize">[docs]</a>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_sentence</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Loads the FST from the file system and consumes the start</span>
<span class="sd">        of sentence symbol. </span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            src_sentence (list):  Not used</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cur_fst</span> <span class="o">=</span> <span class="n">load_fst</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">get_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fst_path</span><span class="p">,</span>
                                               <span class="bp">self</span><span class="o">.</span><span class="n">current_sen_id</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cur_nodes</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">cur_fst</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cur_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_follow_eps</span><span class="p">({</span><span class="bp">self</span><span class="o">.</span><span class="n">cur_fst</span><span class="o">.</span><span class="n">start</span><span class="p">():</span> <span class="mf">0.0</span><span class="p">})</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">consume</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">GO_ID</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">cur_nodes</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;The lattice for sentence </span><span class="si">%d</span><span class="s2"> does not contain any &quot;</span>
                         <span class="s2">&quot;valid path. Please double-check that the lattice &quot;</span>
                         <span class="s2">&quot;is not empty and that paths start with the begin-of-&quot;</span>
                         <span class="s2">&quot;sentence symbol.&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">current_sen_id</span><span class="o">+</span><span class="mi">1</span><span class="p">))</span></div>
    
<div class="viewcode-block" id="NondeterministicFstPredictor.consume"><a class="viewcode-back" href="../../../../predictors.html#cam.sgnmt.predictors.automata.NondeterministicFstPredictor.consume">[docs]</a>    <span class="k">def</span> <span class="nf">consume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Updates the current nodes by searching for all nodes which</span>
<span class="sd">        are reachable from the current nodes by a path consisting of </span>
<span class="sd">        any number of epsilons and exactly one ``word`` label. If there</span>
<span class="sd">        is no such arc, we set the predictor in an invalid state. In </span>
<span class="sd">        this case, all subsequent ``predict_next`` calls will return </span>
<span class="sd">        the empty set.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            word (int): Word on an outgoing arc from the current node</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">d_unconsumed</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Collect distances to nodes reachable by word</span>
        <span class="k">for</span> <span class="n">weight</span><span class="p">,</span><span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cur_nodes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">arc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cur_fst</span><span class="o">.</span><span class="n">arcs</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">arc</span><span class="o">.</span><span class="n">olabel</span> <span class="o">==</span> <span class="n">word</span><span class="p">:</span>
                    <span class="n">next_node</span> <span class="o">=</span> <span class="n">arc</span><span class="o">.</span><span class="n">nextstate</span>
                    <span class="n">next_score</span> <span class="o">=</span> <span class="n">weight</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_factor</span><span class="o">*</span><span class="n">w2f</span><span class="p">(</span><span class="n">arc</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">d_unconsumed</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">next_node</span><span class="p">,</span> <span class="n">utils</span><span class="o">.</span><span class="n">NEG_INF</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">next_score</span><span class="p">:</span>
                        <span class="n">d_unconsumed</span><span class="p">[</span><span class="n">next_node</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_score</span>
        <span class="c1"># Subtract the word score from the last predict_next </span>
        <span class="n">consumed_score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">score_max_func</span><span class="p">(</span><span class="n">d_unconsumed</span><span class="o">.</span><span class="n">itervalues</span><span class="p">())</span> \
             <span class="k">if</span> <span class="p">(</span><span class="n">word</span> <span class="o">!=</span> <span class="n">utils</span><span class="o">.</span><span class="n">GO_ID</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">skip_bos_weight</span><span class="p">)</span> <span class="k">else</span> <span class="mf">0.0</span>
        <span class="c1"># Add epsilon reachable states</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cur_nodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_follow_eps</span><span class="p">({</span><span class="n">node</span><span class="p">:</span> <span class="n">score</span> <span class="o">-</span> <span class="n">consumed_score</span>
                    <span class="k">for</span> <span class="n">node</span><span class="p">,</span><span class="n">score</span> <span class="ow">in</span> <span class="n">d_unconsumed</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()})</span></div>
    
    <span class="k">def</span> <span class="nf">_follow_eps</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">roots</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;BFS to find nodes reachable from root through eps arcs. This</span>
<span class="sd">        traversal strategy is efficient if the triangle inquality holds </span>
<span class="sd">        for weights in the graphs, i.e. for all vertices v1,v2,v3: </span>
<span class="sd">        (v1,v2),(v2,v3),(v1,v3) in E =&gt; d(v1,v2)+d(v2,v3) &gt;= d(v1,v3).</span>
<span class="sd">        The method still returns the correct results if the triangle</span>
<span class="sd">        inequality does not hold, but edges may be traversed multiple</span>
<span class="sd">        times which makes it more inefficient.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">open_nodes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span>
        <span class="n">d</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">visited</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">roots</span><span class="p">)</span>
        <span class="k">while</span> <span class="n">open_nodes</span><span class="p">:</span>
            <span class="n">next_open</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="k">for</span> <span class="n">node</span><span class="p">,</span><span class="n">score</span> <span class="ow">in</span> <span class="n">open_nodes</span><span class="o">.</span><span class="n">iteritems</span><span class="p">():</span>
                <span class="n">has_noneps</span> <span class="o">=</span> <span class="bp">False</span>
                <span class="k">for</span> <span class="n">arc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cur_fst</span><span class="o">.</span><span class="n">arcs</span><span class="p">(</span><span class="n">node</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">arc</span><span class="o">.</span><span class="n">olabel</span> <span class="o">==</span> <span class="n">EPS_ID</span><span class="p">:</span>
                        <span class="n">next_node</span> <span class="o">=</span> <span class="n">arc</span><span class="o">.</span><span class="n">nextstate</span>
                        <span class="n">next_score</span> <span class="o">=</span> <span class="n">score</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_factor</span><span class="o">*</span><span class="n">w2f</span><span class="p">(</span><span class="n">arc</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">visited</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">next_node</span><span class="p">,</span> <span class="n">utils</span><span class="o">.</span><span class="n">NEG_INF</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">next_score</span><span class="p">:</span>
                            <span class="n">visited</span><span class="p">[</span><span class="n">next_node</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_score</span>
                            <span class="n">next_open</span><span class="p">[</span><span class="n">next_node</span><span class="p">]</span> <span class="o">=</span> <span class="n">next_score</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">has_noneps</span> <span class="o">=</span> <span class="bp">True</span>
                <span class="k">if</span> <span class="n">has_noneps</span><span class="p">:</span>
                    <span class="n">d</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">score</span>
            <span class="n">open_nodes</span> <span class="o">=</span> <span class="n">next_open</span>
        <span class="k">return</span> <span class="p">[(</span><span class="n">weight</span><span class="p">,</span> <span class="n">node</span><span class="p">)</span> <span class="k">for</span> <span class="n">node</span><span class="p">,</span> <span class="n">weight</span> <span class="ow">in</span> <span class="n">d</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()]</span>
        
<div class="viewcode-block" id="NondeterministicFstPredictor.get_state"><a class="viewcode-back" href="../../../../predictors.html#cam.sgnmt.predictors.automata.NondeterministicFstPredictor.get_state">[docs]</a>    <span class="k">def</span> <span class="nf">get_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the set of current nodes &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cur_nodes</span></div>
    
<div class="viewcode-block" id="NondeterministicFstPredictor.set_state"><a class="viewcode-back" href="../../../../predictors.html#cam.sgnmt.predictors.automata.NondeterministicFstPredictor.set_state">[docs]</a>    <span class="k">def</span> <span class="nf">set_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the set of current nodes &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cur_nodes</span> <span class="o">=</span> <span class="n">state</span></div>

<div class="viewcode-block" id="NondeterministicFstPredictor.initialize_heuristic"><a class="viewcode-back" href="../../../../predictors.html#cam.sgnmt.predictors.automata.NondeterministicFstPredictor.initialize_heuristic">[docs]</a>    <span class="k">def</span> <span class="nf">initialize_heuristic</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_sentence</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a matrix of shortest distances between all nodes &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">distances</span> <span class="o">=</span> <span class="n">fst</span><span class="o">.</span><span class="n">shortestdistance</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cur_fst</span><span class="p">,</span> <span class="n">reverse</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="NondeterministicFstPredictor.estimate_future_cost"><a class="viewcode-back" href="../../../../predictors.html#cam.sgnmt.predictors.automata.NondeterministicFstPredictor.estimate_future_cost">[docs]</a>    <span class="k">def</span> <span class="nf">estimate_future_cost</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">hypo</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;The FST predictor comes with its own heuristic function. We</span>
<span class="sd">        use the shortest path in the fst as future cost estimator. &quot;&quot;&quot;</span>
        <span class="n">last_word</span> <span class="o">=</span> <span class="n">hypo</span><span class="o">.</span><span class="n">trgt_sentence</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">dists</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cur_nodes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">arc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cur_fst</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">arcs</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">arc</span><span class="o">.</span><span class="n">olabel</span> <span class="o">==</span> <span class="n">last_word</span><span class="p">:</span>
                    <span class="n">dists</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">w2f</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">distances</span><span class="p">[</span><span class="n">arc</span><span class="o">.</span><span class="n">nextstate</span><span class="p">]))</span>
                    <span class="k">break</span>
        <span class="k">return</span> <span class="mf">0.0</span> <span class="k">if</span> <span class="ow">not</span> <span class="n">dists</span> <span class="k">else</span> <span class="nb">min</span><span class="p">(</span><span class="n">dists</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="NondeterministicFstPredictor.is_equal"><a class="viewcode-back" href="../../../../predictors.html#cam.sgnmt.predictors.automata.NondeterministicFstPredictor.is_equal">[docs]</a>    <span class="k">def</span> <span class="nf">is_equal</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state1</span><span class="p">,</span> <span class="n">state2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns true if the current nodes are the same &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">n</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span><span class="n">n</span> <span class="ow">in</span> <span class="n">state1</span><span class="p">])</span> <span class="o">==</span> <span class="nb">sorted</span><span class="p">([</span><span class="n">n</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span><span class="n">n</span> <span class="ow">in</span> <span class="n">state2</span><span class="p">])</span></div></div>


<div class="viewcode-block" id="RtnPredictor"><a class="viewcode-back" href="../../../../predictors.html#cam.sgnmt.predictors.automata.RtnPredictor">[docs]</a><span class="k">class</span> <span class="nc">RtnPredictor</span><span class="p">(</span><span class="n">Predictor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Predictor for RTNs (recurrent transition networks). This </span>
<span class="sd">    predictor assumes a directory structure as produced by HiFST. You </span>
<span class="sd">    can use this predictor for non-deterministic lattices too. This</span>
<span class="sd">    implementation supports late expansion: RTNs are only expanded as</span>
<span class="sd">    far as necessary to retrieve all currently reachable states.</span>
<span class="sd">    </span>
<span class="sd">    ``cur_nodes`` contains the accumulated weights from the last </span>
<span class="sd">    consumed word (if ambiguous, the largest)</span>
<span class="sd">    </span>
<span class="sd">    This implementation does not maintain a list of active nodes like </span>
<span class="sd">    the other automata predictors. Instead, we store the current </span>
<span class="sd">    history and search for the active nodes at each expansion. This is</span>
<span class="sd">    more expensive, but fstreplace might change state IDs so a list of</span>
<span class="sd">    active nodes might get corrupted.</span>
<span class="sd">    </span>
<span class="sd">    Note that this predictor does not support FSTs in gzip format.</span>
<span class="sd">    &quot;&quot;&quot;</span>
    
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">rtn_path</span><span class="p">,</span>
                 <span class="n">use_weights</span><span class="p">,</span>
                 <span class="n">normalize_scores</span><span class="p">,</span>
                 <span class="n">to_log</span> <span class="o">=</span> <span class="bp">True</span><span class="p">,</span>
                 <span class="n">minimize_rtns</span> <span class="o">=</span> <span class="bp">False</span><span class="p">,</span>
                 <span class="n">rmeps</span> <span class="o">=</span> <span class="bp">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Creates a new RTN predictor.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            rtn_path (string): Path to the RTN directory</span>
<span class="sd">            use_weights (bool): If false, replace all arc weights with</span>
<span class="sd">                                0 (=log 1).</span>
<span class="sd">            normalize_scores (bool): If true, we normalize the weights</span>
<span class="sd">                                     on all outgoing arcs such that</span>
<span class="sd">                                     they sum up to 1</span>
<span class="sd">            to_log (bool): SGNMT uses normal log probs (scores) while</span>
<span class="sd">                           arc weights in FSTs normally have cost (i.e.</span>
<span class="sd">                           neg. log values) semantics. Therefore, if</span>
<span class="sd">                           true, we multiply arc weights by -1.</span>
<span class="sd">            minimize_rtns (bool): Minimize the FST after each replace</span>
<span class="sd">                                  operation</span>
<span class="sd">            rmeps (bool): Remove epsilons in the FST after each replace</span>
<span class="sd">                          operation </span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">RtnPredictor</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root_path</span> <span class="o">=</span> <span class="n">rtn_path</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">minimize_rtns</span> <span class="o">=</span> <span class="n">minimize_rtns</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">rmeps</span> <span class="o">=</span> <span class="n">rmeps</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">use_weights</span> <span class="o">=</span> <span class="n">use_weights</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">normalize_scores</span> <span class="o">=</span> <span class="n">normalize_scores</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">weight_factor</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.0</span> <span class="k">if</span> <span class="n">to_log</span> <span class="k">else</span> <span class="mf">1.0</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cur_fst</span> <span class="o">=</span> <span class="bp">None</span> <span class="c1"># current root fst</span>
        <span class="n">start_id</span> <span class="o">=</span> <span class="s1">&#39;1&#39;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/ntmap&quot;</span> <span class="o">%</span> <span class="bp">self</span><span class="o">.</span><span class="n">root_path</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                <span class="n">ntmap</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="bp">None</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">f</span><span class="p">)</span>
                <span class="n">start_id</span> <span class="o">=</span> <span class="n">ntmap</span><span class="p">[</span><span class="s1">&#39;S&#39;</span><span class="p">]</span>
        <span class="k">except</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Could not find NT S in ntmap. Assuming its ID 1&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">root_fst_prefix</span> <span class="o">=</span> <span class="s2">&quot;1</span><span class="si">%s</span><span class="s2">000&quot;</span> <span class="o">%</span> <span class="n">start_id</span><span class="o">.</span><span class="n">zfill</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
        
<div class="viewcode-block" id="RtnPredictor.get_unk_probability"><a class="viewcode-back" href="../../../../predictors.html#cam.sgnmt.predictors.automata.RtnPredictor.get_unk_probability">[docs]</a>    <span class="k">def</span> <span class="nf">get_unk_probability</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">posterior</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Always returns negative infinity: Words outside the </span>
<span class="sd">        RTN are not possible according to this predictor.</span>
<span class="sd">        </span>
<span class="sd">        Returns:</span>
<span class="sd">            float. Negative infinity</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="n">utils</span><span class="o">.</span><span class="n">NEG_INF</span></div>
    
<div class="viewcode-block" id="RtnPredictor.initialize"><a class="viewcode-back" href="../../../../predictors.html#cam.sgnmt.predictors.automata.RtnPredictor.initialize">[docs]</a>    <span class="k">def</span> <span class="nf">initialize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">src_sentence</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Loads the root RTN and consumes the start of sentence </span>
<span class="sd">        symbol.</span>
<span class="sd">        </span>
<span class="sd">        Args:</span>
<span class="sd">            src_sentence (list):  Not used</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">file_name</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/</span><span class="si">%d</span><span class="s2">.fst&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root_path</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">current_sen_id</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">access</span><span class="p">(</span><span class="n">file_name</span><span class="p">,</span> <span class="n">os</span><span class="o">.</span><span class="n">R_OK</span><span class="p">):</span> <span class="c1"># Find root FST</span>
                <span class="n">search_pattern</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">/</span><span class="si">%d</span><span class="s1">/</span><span class="si">%s</span><span class="s1">*.fst&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root_path</span><span class="p">,</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">current_sen_id</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                                                    <span class="bp">self</span><span class="o">.</span><span class="n">root_fst_prefix</span><span class="p">)</span>
                <span class="n">candidates</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">search_pattern</span><span class="p">)</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">candidates</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Could not find root fst in </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> 
                                    <span class="n">search_pattern</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">cur_fst</span> <span class="o">=</span> <span class="bp">None</span>
                    <span class="k">return</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">logging</span><span class="o">.</span><span class="n">warn</span><span class="p">(</span><span class="s2">&quot;Ambiguous root fst for </span><span class="si">%s</span><span class="s2">. Take the one &quot;</span>
                                 <span class="s2">&quot;with largest span.&quot;</span> <span class="o">%</span> <span class="n">search_pattern</span><span class="p">)</span>
                    <span class="n">candidates</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">candidates</span><span class="p">)</span>
                <span class="n">file_name</span> <span class="o">=</span> <span class="n">candidates</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cur_fst</span> <span class="o">=</span> <span class="n">fst</span><span class="o">.</span><span class="n">Fst</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">file_name</span><span class="p">)</span> 
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Read (root)fst from </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">file_name</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> error reading fst from </span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                <span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">1</span><span class="p">],</span> <span class="n">file_name</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cur_fst</span> <span class="o">=</span> <span class="bp">None</span>
        <span class="k">finally</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cur_history</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sub_fsts</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">consume</span><span class="p">(</span><span class="n">utils</span><span class="o">.</span><span class="n">GO_ID</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="RtnPredictor.expand_rtn"><a class="viewcode-back" href="../../../../predictors.html#cam.sgnmt.predictors.automata.RtnPredictor.expand_rtn">[docs]</a>    <span class="k">def</span> <span class="nf">expand_rtn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This method expands the RTN as far as necessary. This means</span>
<span class="sd">        that the RTN is expanded s.t. we can build the posterior for </span>
<span class="sd">        ``cur_history``. In practice, this means that we follow all </span>
<span class="sd">        epsilon edges and replaces all NT edges until all paths with </span>
<span class="sd">        the prefix ``cur_history`` in the RTN have at least one more </span>
<span class="sd">        terminal token. Then, we apply ``func`` to all reachable nodes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">updated</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">while</span> <span class="n">updated</span><span class="p">:</span>
            <span class="n">updated</span> <span class="o">=</span> <span class="bp">False</span>
            <span class="n">label_fst_map</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">visited_nodes</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cur_fst</span><span class="o">.</span><span class="n">arcsort</span><span class="p">(</span><span class="n">sort_type</span><span class="o">=</span><span class="s2">&quot;olabel&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_to_label_fst_map_recursive</span><span class="p">(</span><span class="n">label_fst_map</span><span class="p">,</span>
                                                <span class="p">{},</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">cur_fst</span><span class="o">.</span><span class="n">start</span><span class="p">(),</span> 
                                                <span class="mf">0.0</span><span class="p">,</span>
                                                <span class="bp">self</span><span class="o">.</span><span class="n">cur_history</span><span class="p">,</span> <span class="n">func</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">label_fst_map</span><span class="p">:</span>
                <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Replace </span><span class="si">%d</span><span class="s2"> NT arcs for history </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span>
                                                            <span class="nb">len</span><span class="p">(</span><span class="n">label_fst_map</span><span class="p">),</span>
                                                            <span class="bp">self</span><span class="o">.</span><span class="n">cur_history</span><span class="p">))</span>
                <span class="c1"># First in the list is the root FST and label</span>
                <span class="n">replaced_fst</span> <span class="o">=</span> <span class="n">fst</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span>
                        <span class="p">[(</span><span class="nb">len</span><span class="p">(</span><span class="n">label_fst_map</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2000000000</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">cur_fst</span><span class="p">)]</span> 
                        <span class="o">+</span> <span class="p">[(</span><span class="n">nt_label</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> 
                            <span class="k">for</span> <span class="p">(</span><span class="n">nt_label</span><span class="p">,</span> <span class="n">f</span><span class="p">)</span> <span class="ow">in</span> <span class="n">label_fst_map</span><span class="o">.</span><span class="n">iteritems</span><span class="p">()],</span>
                        <span class="n">epsilon_on_replace</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">cur_fst</span> <span class="o">=</span> <span class="n">replaced_fst</span>
                <span class="n">updated</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">rmeps</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimize_rtns</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cur_fst</span><span class="o">.</span><span class="n">rmepsilon</span><span class="p">()</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">minimize_rtns</span><span class="p">:</span>
            <span class="n">tmp</span> <span class="o">=</span> <span class="n">fst</span><span class="o">.</span><span class="n">determinize</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cur_fst</span><span class="o">.</span><span class="n">determinize</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cur_fst</span> <span class="o">=</span> <span class="n">tmp</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">cur_fst</span><span class="o">.</span><span class="n">minimize</span><span class="p">()</span></div>
    
<div class="viewcode-block" id="RtnPredictor.add_to_label_fst_map_recursive"><a class="viewcode-back" href="../../../../predictors.html#cam.sgnmt.predictors.automata.RtnPredictor.add_to_label_fst_map_recursive">[docs]</a>    <span class="k">def</span> <span class="nf">add_to_label_fst_map_recursive</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                                       <span class="n">label_fst_map</span><span class="p">,</span> 
                                       <span class="n">visited_nodes</span><span class="p">,</span> 
                                       <span class="n">root_node</span><span class="p">,</span> 
                                       <span class="n">acc_weight</span><span class="p">,</span> 
                                       <span class="n">history</span><span class="p">,</span> 
                                       <span class="n">func</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds arcs to ``label_fst_map`` if they are labeled with an</span>
<span class="sd">        NT symbol and reachable from ``root_node`` via ``history``.</span>
<span class="sd">          </span>
<span class="sd">        Note: visited_nodes is maintained for each history separately</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">root_node</span> <span class="ow">in</span> <span class="n">visited_nodes</span><span class="p">:</span>
            <span class="c1"># This introduces some error as we take the score of the first best</span>
            <span class="c1"># path with a certain history, not the globally best path. For now,</span>
            <span class="c1"># this error should not be significant</span>
            <span class="k">return</span>
        <span class="n">visited_nodes</span><span class="p">[</span><span class="n">root_node</span><span class="p">]</span> <span class="o">=</span> <span class="bp">True</span>
        <span class="k">for</span> <span class="n">arc</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cur_fst</span><span class="o">.</span><span class="n">arcs</span><span class="p">(</span><span class="n">root_node</span><span class="p">):</span>
            <span class="n">arc_acc_weight</span> <span class="o">=</span> <span class="n">acc_weight</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">weight_factor</span><span class="o">*</span><span class="n">w2f</span><span class="p">(</span><span class="n">arc</span><span class="o">.</span><span class="n">weight</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">arc</span><span class="o">.</span><span class="n">olabel</span> <span class="o">==</span> <span class="n">EPS_ID</span><span class="p">:</span> <span class="c1"># Follow epsilon edges</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_to_label_fst_map_recursive</span><span class="p">(</span><span class="n">label_fst_map</span><span class="p">,</span>
                                                    <span class="n">visited_nodes</span><span class="p">,</span>
                                                    <span class="n">arc</span><span class="o">.</span><span class="n">nextstate</span><span class="p">,</span>
                                                    <span class="n">arc_acc_weight</span><span class="p">,</span> 
                                                    <span class="n">history</span><span class="p">,</span>
                                                    <span class="n">func</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">history</span><span class="p">:</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">is_nt_label</span><span class="p">(</span><span class="n">arc</span><span class="o">.</span><span class="n">olabel</span><span class="p">):</span> <span class="c1"># Add to label_fst_map</span>
                    <span class="n">replace_label</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">label_fst_map</span><span class="p">)</span> <span class="o">+</span> <span class="mi">2000000000</span>
                    <span class="n">label_fst_map</span><span class="p">[</span><span class="n">replace_label</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_sub_fst</span><span class="p">(</span>
                                                                    <span class="n">arc</span><span class="o">.</span><span class="n">olabel</span><span class="p">)</span>
                    <span class="n">arc</span><span class="o">.</span><span class="n">ilabel</span> <span class="o">=</span> <span class="n">replace_label</span>
                    <span class="n">arc</span><span class="o">.</span><span class="n">olabel</span> <span class="o">=</span> <span class="n">replace_label</span>
                <span class="k">else</span><span class="p">:</span> <span class="c1"># This is a regular arc and we have no history left</span>
                    <span class="n">func</span><span class="p">(</span><span class="n">arc</span><span class="o">.</span><span class="n">nextstate</span><span class="p">,</span> <span class="n">arc</span><span class="o">.</span><span class="n">olabel</span><span class="p">,</span> <span class="n">arc_acc_weight</span><span class="p">)</span> <span class="c1"># apply func</span>
            <span class="k">elif</span> <span class="n">arc</span><span class="o">.</span><span class="n">olabel</span> <span class="o">==</span> <span class="n">history</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="c1"># history is not empty</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_to_label_fst_map_recursive</span><span class="p">(</span><span class="n">label_fst_map</span><span class="p">,</span>
                                                    <span class="p">{},</span>
                                                    <span class="n">arc</span><span class="o">.</span><span class="n">nextstate</span><span class="p">,</span>
                                                    <span class="n">arc_acc_weight</span><span class="p">,</span>
                                                    <span class="n">history</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
                                                    <span class="n">func</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">arc</span><span class="o">.</span><span class="n">olabel</span> <span class="o">&gt;</span> <span class="n">history</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span> <span class="c1"># FST is arc sorted, we can stop here</span>
                <span class="k">break</span></div>
        
    
<div class="viewcode-block" id="RtnPredictor.is_nt_label"><a class="viewcode-back" href="../../../../predictors.html#cam.sgnmt.predictors.automata.RtnPredictor.is_nt_label">[docs]</a>    <span class="k">def</span> <span class="nf">is_nt_label</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">label</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns true if ``label`` is a non-terminal. &quot;&quot;&quot;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="nb">str</span><span class="p">(</span><span class="n">label</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">==</span> <span class="mi">10</span> <span class="ow">and</span> <span class="n">s</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;1&#39;</span></div>

<div class="viewcode-block" id="RtnPredictor.get_sub_fst"><a class="viewcode-back" href="../../../../predictors.html#cam.sgnmt.predictors.automata.RtnPredictor.get_sub_fst">[docs]</a>    <span class="k">def</span> <span class="nf">get_sub_fst</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">fst_id</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Load sub fst from the file system or the cache &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">fst_id</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_fsts</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sub_fsts</span><span class="p">[</span><span class="n">fst_id</span><span class="p">]</span>
        <span class="n">sub_fst_path</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">/</span><span class="si">%d</span><span class="s2">/</span><span class="si">%d</span><span class="s2">.fst&quot;</span> <span class="o">%</span>  <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">root_path</span><span class="p">,</span>
                                          <span class="bp">self</span><span class="o">.</span><span class="n">current_sen_id</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span>
                                          <span class="n">fst_id</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">sub_fst</span> <span class="o">=</span> <span class="n">fst</span><span class="o">.</span><span class="n">Fst</span><span class="o">.</span><span class="n">read</span><span class="p">(</span><span class="n">sub_fst_path</span><span class="p">)</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Read sub fst from </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="n">sub_fst_path</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sub_fsts</span><span class="p">[</span><span class="n">fst_id</span><span class="p">]</span> <span class="o">=</span> <span class="n">sub_fst</span>
            <span class="k">return</span> <span class="n">sub_fst</span>
        <span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
            <span class="n">logging</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">%s</span><span class="s2"> error reading sub fst from </span><span class="si">%s</span><span class="s2">: </span><span class="si">%s</span><span class="s2">&quot;</span> <span class="o">%</span>
                <span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">1</span><span class="p">],</span> <span class="n">sub_fst_path</span><span class="p">,</span> <span class="n">e</span><span class="p">))</span></div>
        
    <span class="k">def</span> <span class="nf">_add_to_cur_posterior</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">label</span><span class="p">,</span> <span class="n">weight</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Can be used as ``func`` argument in ``expand_rtn`` to build</span>
<span class="sd">        up the posterior for the next target token  in ``predict_next``</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cur_posterior</span><span class="p">[</span><span class="n">label</span><span class="p">]</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cur_posterior</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">label</span><span class="p">,</span> <span class="n">utils</span><span class="o">.</span><span class="n">NEG_INF</span><span class="p">),</span>
                                        <span class="n">weight</span><span class="p">)</span>
    
<div class="viewcode-block" id="RtnPredictor.predict_next"><a class="viewcode-back" href="../../../../predictors.html#cam.sgnmt.predictors.automata.RtnPredictor.predict_next">[docs]</a>    <span class="k">def</span> <span class="nf">predict_next</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Expands RTN as far as possible and uses the outgoing edges </span>
<span class="sd">        from nodes reachable by the current history to build up</span>
<span class="sd">        the posterior for the next word. If there are no such nodes</span>
<span class="sd">        or arcs, or no root FST is loaded, return the empty set.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">cur_fst</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cur_posterior</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">expand_rtn</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_add_to_cur_posterior</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">finalize_posterior</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">cur_posterior</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">use_weights</span><span class="p">,</span>
                                       <span class="bp">self</span><span class="o">.</span><span class="n">normalize_scores</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="RtnPredictor.consume"><a class="viewcode-back" href="../../../../predictors.html#cam.sgnmt.predictors.automata.RtnPredictor.consume">[docs]</a>    <span class="k">def</span> <span class="nf">consume</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">word</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Adds ``word`` to the current history. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cur_history</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">word</span><span class="p">)</span></div>
    
<div class="viewcode-block" id="RtnPredictor.get_state"><a class="viewcode-back" href="../../../../predictors.html#cam.sgnmt.predictors.automata.RtnPredictor.get_state">[docs]</a>    <span class="k">def</span> <span class="nf">get_state</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the current history. &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">cur_history</span></div>
    
<div class="viewcode-block" id="RtnPredictor.set_state"><a class="viewcode-back" href="../../../../predictors.html#cam.sgnmt.predictors.automata.RtnPredictor.set_state">[docs]</a>    <span class="k">def</span> <span class="nf">set_state</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">state</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sets the current history. &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">cur_history</span> <span class="o">=</span> <span class="n">state</span></div></div>

</pre></div>

           </div>
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, University of Cambridge.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../../',
            VERSION:'0.5',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../../_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="../../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>