

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>cam.sgnmt.blocks package &mdash; SGNMT 0.3.2 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
    <link rel="top" title="SGNMT 0.3.2 documentation" href="index.html"/>
        <link rel="up" title="cam.sgnmt package" href="cam.sgnmt.html"/>
        <link rel="next" title="cam.sgnmt.blocks.alignment package" href="cam.sgnmt.blocks.alignment.html"/>
        <link rel="prev" title="cam.sgnmt package" href="cam.sgnmt.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> SGNMT
          

          
          </a>

          
            
            
              <div class="version">
                0.3.2
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="setup.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="adding_components.html">Tutorial: Adding new components</a></li>
<li class="toctree-l1"><a class="reference internal" href="command_line.html">Command-line reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="predictors.html">Predictors</a></li>
<li class="toctree-l1"><a class="reference internal" href="decoders.html">Decoders</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">Common issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="publications.html">Publications</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="cam.sgnmt.html">All modules</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="cam.sgnmt.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">cam.sgnmt.blocks package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#subpackages">Subpackages</a></li>
<li class="toctree-l4"><a class="reference internal" href="#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cam-sgnmt-blocks-align-module">cam.sgnmt.blocks.align module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-cam.sgnmt.blocks.attention">cam.sgnmt.blocks.attention module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cam-sgnmt-blocks-batch-decode-module">cam.sgnmt.blocks.batch_decode module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-cam.sgnmt.blocks.checkpoint">cam.sgnmt.blocks.checkpoint module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-cam.sgnmt.blocks.decoder">cam.sgnmt.blocks.decoder module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-cam.sgnmt.blocks.encoder">cam.sgnmt.blocks.encoder module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-cam.sgnmt.blocks.model">cam.sgnmt.blocks.model module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-cam.sgnmt.blocks.nmt">cam.sgnmt.blocks.nmt module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-cam.sgnmt.blocks.pruning">cam.sgnmt.blocks.pruning module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-cam.sgnmt.blocks.sampling">cam.sgnmt.blocks.sampling module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-cam.sgnmt.blocks.sparse_search">cam.sgnmt.blocks.sparse_search module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-cam.sgnmt.blocks.stream">cam.sgnmt.blocks.stream module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#cam-sgnmt-blocks-train-module">cam.sgnmt.blocks.train module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-cam.sgnmt.blocks.vanilla_decoder">cam.sgnmt.blocks.vanilla_decoder module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-cam.sgnmt.blocks">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="cam.sgnmt.decoding.html">cam.sgnmt.decoding package</a></li>
<li class="toctree-l3"><a class="reference internal" href="cam.sgnmt.misc.html">cam.sgnmt.misc package</a></li>
<li class="toctree-l3"><a class="reference internal" href="cam.sgnmt.predictors.html">cam.sgnmt.predictors package</a></li>
<li class="toctree-l3"><a class="reference internal" href="cam.sgnmt.tf.html">cam.sgnmt.tf package</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="cam.sgnmt.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="cam.sgnmt.html#cam-sgnmt-decode-module">cam.sgnmt.decode module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cam.sgnmt.html#module-cam.sgnmt.decode_utils">cam.sgnmt.decode_utils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cam.sgnmt.html#module-cam.sgnmt.output">cam.sgnmt.output module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cam.sgnmt.html#module-cam.sgnmt.ui">cam.sgnmt.ui module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cam.sgnmt.html#module-cam.sgnmt.utils">cam.sgnmt.utils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cam.sgnmt.html#module-cam.sgnmt">Module contents</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">SGNMT</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
          <li><a href="cam.sgnmt.html">cam.sgnmt package</a> &raquo;</li>
      
    <li>cam.sgnmt.blocks package</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/cam.sgnmt.blocks.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="cam-sgnmt-blocks-package">
<h1>cam.sgnmt.blocks package<a class="headerlink" href="#cam-sgnmt-blocks-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="cam.sgnmt.blocks.alignment.html">cam.sgnmt.blocks.alignment package</a><ul>
<li class="toctree-l2"><a class="reference internal" href="cam.sgnmt.blocks.alignment.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="cam.sgnmt.blocks.alignment.html#module-cam.sgnmt.blocks.alignment.nam">cam.sgnmt.blocks.alignment.nam module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cam.sgnmt.blocks.alignment.html#module-cam.sgnmt.blocks.alignment.nmt">cam.sgnmt.blocks.alignment.nmt module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cam.sgnmt.blocks.alignment.html#module-cam.sgnmt.blocks.alignment">Module contents</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="cam-sgnmt-blocks-align-module">
<h2>cam.sgnmt.blocks.align module<a class="headerlink" href="#cam-sgnmt-blocks-align-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-cam.sgnmt.blocks.attention">
<span id="cam-sgnmt-blocks-attention-module"></span><h2>cam.sgnmt.blocks.attention module<a class="headerlink" href="#module-cam.sgnmt.blocks.attention" title="Permalink to this headline">¶</a></h2>
<p>This module contains implementations of the attention model in NMT.
In addition to the vanilla content based attention from Bahdanau we
support thresholded attention for resharpening the focus and
parameterized for the Neural Alignment Model (NAM) in which the
attention is defined by a trainable alignment matrix. We also consider
using an external memory like a neural stack as part of the attention.</p>
<dl class="class">
<dt id="cam.sgnmt.blocks.attention.AlignmentAttention">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.attention.</code><code class="descname">AlignmentAttention</code><span class="sig-paren">(</span><em>seq_len</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/attention.html#AlignmentAttention"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.attention.AlignmentAttention" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">blocks.bricks.attention.GenericSequenceAttention</span></code>, <code class="xref py py-class docutils literal"><span class="pre">blocks.bricks.interfaces.Initializable</span></code></p>
<p>This is the parameterized attention for the neural alignment
model. Instead of using a feedforward network as in Bahdanau to
decide on the energies, we use a trainable alignment matrix. This
attention is intended to be used for alignment. During training,
the sentence pair should not change, otherwise the alignment matrix
will be a mixture of multiple alignments. Therefore, the alignment
matrix parameter should be reset to the initial value after each
optimization. In the neural alignment model, this is done by the
<code class="docutils literal"><span class="pre">NextSentenceExtension</span></code> extension.</p>
<dl class="method">
<dt id="cam.sgnmt.blocks.attention.AlignmentAttention.get_dim">
<code class="descname">get_dim</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/attention.html#AlignmentAttention.get_dim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.attention.AlignmentAttention.get_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Get dimensions of variables. Delegates to super class if
<code class="docutils literal"><span class="pre">name</span></code> is not used in this class.</p>
</dd></dl>

<dl class="attribute">
<dt id="cam.sgnmt.blocks.attention.AlignmentAttention.initial_glimpses">
<code class="descname">initial_glimpses</code><a class="headerlink" href="#cam.sgnmt.blocks.attention.AlignmentAttention.initial_glimpses" title="Permalink to this definition">¶</a></dt>
<dd><p>Initial glimpses are set to zero.</p>
</dd></dl>

<dl class="attribute">
<dt id="cam.sgnmt.blocks.attention.AlignmentAttention.take_glimpses">
<code class="descname">take_glimpses</code><a class="headerlink" href="#cam.sgnmt.blocks.attention.AlignmentAttention.take_glimpses" title="Permalink to this definition">¶</a></dt>
<dd><p>In addition to the glimpses <code class="docutils literal"><span class="pre">weighted_averages</span></code> and
<code class="docutils literal"><span class="pre">weights</span></code> as in <code class="docutils literal"><span class="pre">SequenceContentAttention</span></code>, we use the
variable <code class="docutils literal"><span class="pre">matrix_col</span></code> to refer to the current column in the
alignment matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>attended</strong> (<em>Variable</em>) &#8211; Source annotations</li>
<li><strong>preprocessed_attended</strong> (<em>Variable</em>) &#8211; Not used, but required by
certain bricks in Blocks.</li>
<li><strong>attended_mask</strong> (<em>Variable</em>) &#8211; Source mask</li>
<li><strong>matrix_col</strong> (<em>Variable</em>) &#8211; Current column in the alignment
matrix</li>
<li><strong>**states</strong> (<em>Variable</em>) &#8211; Decoder state</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Tuple. The glimpses <code class="docutils literal"><span class="pre">weighted_averages</span></code>, <code class="docutils literal"><span class="pre">weights</span></code>, and
<code class="docutils literal"><span class="pre">matrix_col</span></code>. The first one is used as context vector.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.attention.AlignmentAttention.take_glimpses_inputs">
<code class="descname">take_glimpses_inputs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/attention.html#AlignmentAttention.take_glimpses_inputs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.attention.AlignmentAttention.take_glimpses_inputs" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the <code class="docutils literal"><span class="pre">inputs</span></code> decoration for <code class="docutils literal"><span class="pre">take_glimpses</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.blocks.attention.CoverageContentAttention">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.attention.</code><code class="descname">CoverageContentAttention</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/attention.html#CoverageContentAttention"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.attention.CoverageContentAttention" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">blocks.bricks.attention.GenericSequenceAttention</span></code>, <code class="xref py py-class docutils literal"><span class="pre">blocks.bricks.interfaces.Initializable</span></code></p>
<p>This is the &#8216;linguistic&#8217; coverage model from Tu et al., 2016.
The fertility of each source annotation is estimated with a linear
transform followed by a sigmoid times N (N is the maximum fertility)
The coverage model keeps track of the attention record for each
annotation and feeds the cumulative record divided by the fertility
to the match vector which eventually determines the attention
weight.</p>
<p>This code base of this implementation is close to
<code class="docutils literal"><span class="pre">SequenceContentAttention</span></code>.</p>
<dl class="attribute">
<dt id="cam.sgnmt.blocks.attention.CoverageContentAttention.compute_energies">
<code class="descname">compute_energies</code><a class="headerlink" href="#cam.sgnmt.blocks.attention.CoverageContentAttention.compute_energies" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.attention.CoverageContentAttention.get_dim">
<code class="descname">get_dim</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/attention.html#CoverageContentAttention.get_dim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.attention.CoverageContentAttention.get_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="cam.sgnmt.blocks.attention.CoverageContentAttention.initial_glimpses">
<code class="descname">initial_glimpses</code><a class="headerlink" href="#cam.sgnmt.blocks.attention.CoverageContentAttention.initial_glimpses" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="cam.sgnmt.blocks.attention.CoverageContentAttention.preprocess">
<code class="descname">preprocess</code><a class="headerlink" href="#cam.sgnmt.blocks.attention.CoverageContentAttention.preprocess" title="Permalink to this definition">¶</a></dt>
<dd><p>Preprocess the sequence for computing attention weights.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>attended</strong> (<em>TensorVariable</em>) &#8211; The attended sequence, time is
the 1-st dimension.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="cam.sgnmt.blocks.attention.CoverageContentAttention.take_glimpses">
<code class="descname">take_glimpses</code><a class="headerlink" href="#cam.sgnmt.blocks.attention.CoverageContentAttention.take_glimpses" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.attention.CoverageContentAttention.take_glimpses_inputs">
<code class="descname">take_glimpses_inputs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/attention.html#CoverageContentAttention.take_glimpses_inputs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.attention.CoverageContentAttention.take_glimpses_inputs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.blocks.attention.MultiShallowEnergyComputer">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.attention.</code><code class="descname">MultiShallowEnergyComputer</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/attention.html#MultiShallowEnergyComputer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.attention.MultiShallowEnergyComputer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">blocks.bricks.sequences.Sequence</span></code>, <code class="xref py py-class docutils literal"><span class="pre">blocks.bricks.interfaces.Initializable</span></code>, <code class="xref py py-class docutils literal"><span class="pre">blocks.bricks.interfaces.Feedforward</span></code></p>
<p>A simple energy computer: first tanh, then weighted sum.</p>
<dl class="attribute">
<dt id="cam.sgnmt.blocks.attention.MultiShallowEnergyComputer.input_dim">
<code class="descname">input_dim</code><a class="headerlink" href="#cam.sgnmt.blocks.attention.MultiShallowEnergyComputer.input_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="cam.sgnmt.blocks.attention.MultiShallowEnergyComputer.output_dim">
<code class="descname">output_dim</code><a class="headerlink" href="#cam.sgnmt.blocks.attention.MultiShallowEnergyComputer.output_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.blocks.attention.PushDownSequenceContentAttention">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.attention.</code><code class="descname">PushDownSequenceContentAttention</code><span class="sig-paren">(</span><em>stack_dim=500</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/attention.html#PushDownSequenceContentAttention"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.attention.PushDownSequenceContentAttention" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">blocks.bricks.attention.SequenceContentAttention</span></code>, <code class="xref py py-class docutils literal"><span class="pre">blocks.bricks.interfaces.Initializable</span></code></p>
<p>Adds an external memory structure in form of a neural stack to
the decoder. The neural stack is operated through a pop operation,
a push operation, and an input variable, which all are computed
from the decoder state. This neural stack implementation is similar
to Mikolovs model:</p>
<ul class="simple">
<li>Apply the (continuous) pop operation if the pop gate is on</li>
<li>Read the top element on the stack</li>
<li>Push the stack input vector if the push gate is on</li>
<li>Concatenate the read element from the stack to the weighted
averages of source annotations to obtain the final context
vector</li>
</ul>
<p>Note that this implementation realizes a stack with limited depth
because Blocks didn&#8217;t allow to have glimpses of varying size. In
practice, however, we think that a limited size is appropriate for
machine translation.</p>
<dl class="method">
<dt id="cam.sgnmt.blocks.attention.PushDownSequenceContentAttention.get_dim">
<code class="descname">get_dim</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/attention.html#PushDownSequenceContentAttention.get_dim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.attention.PushDownSequenceContentAttention.get_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Get dimensions of variables. Delegates to super class if
<code class="docutils literal"><span class="pre">name</span></code> is not used in this class.</p>
</dd></dl>

<dl class="attribute">
<dt id="cam.sgnmt.blocks.attention.PushDownSequenceContentAttention.initial_glimpses">
<code class="descname">initial_glimpses</code><a class="headerlink" href="#cam.sgnmt.blocks.attention.PushDownSequenceContentAttention.initial_glimpses" title="Permalink to this definition">¶</a></dt>
<dd><p>The stack is initialized with the default entry. All other
glimpses are initialized with zero.</p>
</dd></dl>

<dl class="attribute">
<dt id="cam.sgnmt.blocks.attention.PushDownSequenceContentAttention.take_glimpses">
<code class="descname">take_glimpses</code><a class="headerlink" href="#cam.sgnmt.blocks.attention.PushDownSequenceContentAttention.take_glimpses" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is an extension to <code class="docutils literal"><span class="pre">take_glimpses</span></code> in
<code class="docutils literal"><span class="pre">SequenceContentAttention</span></code>. After computing the weighted
averages of source annotations, it operates the stack, i.e.
pops the top element, reads out the top of the stack, and
pushes a new element. The first glimpse <code class="docutils literal"><span class="pre">context_vector</span></code> is
the concatenation of weighted source annotations and stack
output.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>attended</strong> (<em>Variable</em>) &#8211; Source annotations</li>
<li><strong>preprocessed_attended</strong> (<em>Variable</em>) &#8211; Transformed source
annotations used to
compute energies</li>
<li><strong>attended_mask</strong> (<em>Variable</em>) &#8211; Source mask</li>
<li><strong>stack</strong> (<em>Variable</em>) &#8211; Current state of the stack</li>
<li><strong>**states</strong> (<em>Variable</em>) &#8211; Decoder state</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Tuple. The first element is used as context vector for the
decoder state update. <code class="docutils literal"><span class="pre">stack</span></code> is a recurrent glimpse which
is used in the next <code class="docutils literal"><span class="pre">take_glimpse</span></code> iteration.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.attention.PushDownSequenceContentAttention.take_glimpses_inputs">
<code class="descname">take_glimpses_inputs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/attention.html#PushDownSequenceContentAttention.take_glimpses_inputs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.attention.PushDownSequenceContentAttention.take_glimpses_inputs" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines the <code class="docutils literal"><span class="pre">inputs</span></code> decoration for <code class="docutils literal"><span class="pre">take_glimpses</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.blocks.attention.PushDownThresholdedAttention">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.attention.</code><code class="descname">PushDownThresholdedAttention</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/attention.html#PushDownThresholdedAttention"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.attention.PushDownThresholdedAttention" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.blocks.attention.PushDownSequenceContentAttention" title="cam.sgnmt.blocks.attention.PushDownSequenceContentAttention"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.blocks.attention.PushDownSequenceContentAttention</span></code></a>, <a class="reference internal" href="#cam.sgnmt.blocks.attention.ThresholdedSequenceContentAttention" title="cam.sgnmt.blocks.attention.ThresholdedSequenceContentAttention"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.blocks.attention.ThresholdedSequenceContentAttention</span></code></a></p>
<p>This class allows to use thresholded attention in combination
with an external neural stack memory.</p>
</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.blocks.attention.SelfAttendableContentAttention">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.attention.</code><code class="descname">SelfAttendableContentAttention</code><span class="sig-paren">(</span><em>match_dim</em>, <em>num_steps</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/attention.html#SelfAttendableContentAttention"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.attention.SelfAttendableContentAttention" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">blocks.bricks.attention.SequenceContentAttention</span></code></p>
<p>This is a variation of <code class="docutils literal"><span class="pre">SequenceContentAttention</span></code> which can
also attend to own previous states. This might be useful for
creating higher lever representations in the encoder network.</p>
<p>Note that because of restrictions in Blocks, the number of previous
states to which we can attend to must be fixed. Therefore, the
constructor expects to specify the number of recurrent
steps.</p>
<dl class="method">
<dt id="cam.sgnmt.blocks.attention.SelfAttendableContentAttention.get_dim">
<code class="descname">get_dim</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/attention.html#SelfAttendableContentAttention.get_dim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.attention.SelfAttendableContentAttention.get_dim" title="Permalink to this definition">¶</a></dt>
<dd><p>Get dimensions of variables. Delegates to super class if
<code class="docutils literal"><span class="pre">name</span></code> is not used in this class.</p>
</dd></dl>

<dl class="attribute">
<dt id="cam.sgnmt.blocks.attention.SelfAttendableContentAttention.initial_glimpses">
<code class="descname">initial_glimpses</code><a class="headerlink" href="#cam.sgnmt.blocks.attention.SelfAttendableContentAttention.initial_glimpses" title="Permalink to this definition">¶</a></dt>
<dd><p>Sets all inital glimpses to zero.</p>
</dd></dl>

<dl class="attribute">
<dt id="cam.sgnmt.blocks.attention.SelfAttendableContentAttention.take_glimpses">
<code class="descname">take_glimpses</code><a class="headerlink" href="#cam.sgnmt.blocks.attention.SelfAttendableContentAttention.take_glimpses" title="Permalink to this definition">¶</a></dt>
<dd><p>Similar to <code class="docutils literal"><span class="pre">SequenceContentAttention.take_glimpses()</span></code>,
but keeps the previous states in <code class="docutils literal"><span class="pre">attended_own</span></code> in order to
be able to attend to them.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.attention.SelfAttendableContentAttention.take_glimpses_inputs">
<code class="descname">take_glimpses_inputs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/attention.html#SelfAttendableContentAttention.take_glimpses_inputs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.attention.SelfAttendableContentAttention.take_glimpses_inputs" title="Permalink to this definition">¶</a></dt>
<dd><p>Inputs for <code class="docutils literal"><span class="pre">take_climpses</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.blocks.attention.SequenceMultiContentAttention">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.attention.</code><code class="descname">SequenceMultiContentAttention</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/attention.html#SequenceMultiContentAttention"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.attention.SequenceMultiContentAttention" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">blocks.bricks.attention.GenericSequenceAttention</span></code>, <code class="xref py py-class docutils literal"><span class="pre">blocks.bricks.interfaces.Initializable</span></code></p>
<dl class="attribute">
<dt id="cam.sgnmt.blocks.attention.SequenceMultiContentAttention.compute_energies">
<code class="descname">compute_energies</code><a class="headerlink" href="#cam.sgnmt.blocks.attention.SequenceMultiContentAttention.compute_energies" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.attention.SequenceMultiContentAttention.get_dim">
<code class="descname">get_dim</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/attention.html#SequenceMultiContentAttention.get_dim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.attention.SequenceMultiContentAttention.get_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="cam.sgnmt.blocks.attention.SequenceMultiContentAttention.initial_glimpses">
<code class="descname">initial_glimpses</code><a class="headerlink" href="#cam.sgnmt.blocks.attention.SequenceMultiContentAttention.initial_glimpses" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="cam.sgnmt.blocks.attention.SequenceMultiContentAttention.preprocess">
<code class="descname">preprocess</code><a class="headerlink" href="#cam.sgnmt.blocks.attention.SequenceMultiContentAttention.preprocess" title="Permalink to this definition">¶</a></dt>
<dd><p>Preprocess the sequence for computing attention weights.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>attended</strong> (<code class="xref py py-class docutils literal"><span class="pre">TensorVariable</span></code>) &#8211; The attended sequence, time is the 1-st dimension.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="cam.sgnmt.blocks.attention.SequenceMultiContentAttention.take_glimpses">
<code class="descname">take_glimpses</code><a class="headerlink" href="#cam.sgnmt.blocks.attention.SequenceMultiContentAttention.take_glimpses" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute attention weights and produce glimpses.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>attended</strong> (<code class="xref py py-class docutils literal"><span class="pre">TensorVariable</span></code>) &#8211; The sequence, time is the 1-st dimension.</li>
<li><strong>preprocessed_attended</strong> (<code class="xref py py-class docutils literal"><span class="pre">TensorVariable</span></code>) &#8211; The preprocessed sequence. If <code class="docutils literal"><span class="pre">None</span></code>, is computed by calling
<a class="reference internal" href="#cam.sgnmt.blocks.attention.SequenceMultiContentAttention.preprocess" title="cam.sgnmt.blocks.attention.SequenceMultiContentAttention.preprocess"><code class="xref py py-meth docutils literal"><span class="pre">preprocess()</span></code></a>.</li>
<li><strong>attended_mask</strong> (<code class="xref py py-class docutils literal"><span class="pre">TensorVariable</span></code>) &#8211; A 0/1 mask specifying available data. 0 means that the
corresponding sequence element is fake.</li>
<li><strong>**states</strong> &#8211; The states of the network.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><ul class="simple">
<li><strong>weighted_averages</strong> (<code class="xref py py-class docutils literal"><span class="pre">Variable</span></code>) &#8211; Linear combinations of sequence elements with the attention
weights.</li>
<li><strong>weights</strong> (<code class="xref py py-class docutils literal"><span class="pre">Variable</span></code>) &#8211; The attention weights. The first dimension is batch, the second
is time.</li>
</ul>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.attention.SequenceMultiContentAttention.take_glimpses_inputs">
<code class="descname">take_glimpses_inputs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/attention.html#SequenceMultiContentAttention.take_glimpses_inputs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.attention.SequenceMultiContentAttention.take_glimpses_inputs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.blocks.attention.ThresholdedSequenceContentAttention">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.attention.</code><code class="descname">ThresholdedSequenceContentAttention</code><span class="sig-paren">(</span><em>nbest=1</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/attention.html#ThresholdedSequenceContentAttention"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.attention.ThresholdedSequenceContentAttention" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">blocks.bricks.attention.SequenceContentAttention</span></code></p>
<p>This class can be used to resharpen the normal content based
attention. Instead of using the normal softmax over the energies,
it keeps only the n-best energies and set all the others to zero.
This results in a sharper focus and avoids blurry alignment weights
on long sequences.</p>
<p>Note that this attention can be used during decoding in place of
the normal content-based attention without retraining.</p>
<dl class="attribute">
<dt id="cam.sgnmt.blocks.attention.ThresholdedSequenceContentAttention.compute_weights">
<code class="descname">compute_weights</code><a class="headerlink" href="#cam.sgnmt.blocks.attention.ThresholdedSequenceContentAttention.compute_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Overrides <code class="docutils literal"><span class="pre">SequenceContentAttention.compute_weights()</span></code>.
Instead of a normal softmax, it sets most of the energies to
zero, resulting in sharp attention. If <code class="docutils literal"><span class="pre">self.nbest</span></code> equals 1,
the thresholded attention always sets its full attention to one
single source annotation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>energies</strong> (<em>Variable</em>) &#8211; Energies computed by the
energy_computer</li>
<li><strong>attended_mask</strong> (<em>Variable</em>) &#8211; Source sentence mask</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Variable. Thresholded alignment weights</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.blocks.attention.TreeAttention">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.attention.</code><code class="descname">TreeAttention</code><span class="sig-paren">(</span><em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/attention.html#TreeAttention"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.attention.TreeAttention" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">blocks.bricks.attention.GenericSequenceAttention</span></code>, <code class="xref py py-class docutils literal"><span class="pre">blocks.bricks.interfaces.Initializable</span></code></p>
<p>This attention replaces the weighted average in the vanilla
attention mechanism with a recursive network which is similar to
the recurrent autoencoder. The source annotations are merged
recursively until a single representation is obtained. The merge
network takes two representations and the last decoder state as
input and outputs another representation which serves as input to
the next merge operation.</p>
<dl class="attribute">
<dt id="cam.sgnmt.blocks.attention.TreeAttention.compute_energies">
<code class="descname">compute_energies</code><a class="headerlink" href="#cam.sgnmt.blocks.attention.TreeAttention.compute_energies" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.attention.TreeAttention.get_dim">
<code class="descname">get_dim</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/attention.html#TreeAttention.get_dim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.attention.TreeAttention.get_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="cam.sgnmt.blocks.attention.TreeAttention.initial_glimpses">
<code class="descname">initial_glimpses</code><a class="headerlink" href="#cam.sgnmt.blocks.attention.TreeAttention.initial_glimpses" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="cam.sgnmt.blocks.attention.TreeAttention.take_glimpses">
<code class="descname">take_glimpses</code><a class="headerlink" href="#cam.sgnmt.blocks.attention.TreeAttention.take_glimpses" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.attention.TreeAttention.take_glimpses_inputs">
<code class="descname">take_glimpses_inputs</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/attention.html#TreeAttention.take_glimpses_inputs"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.attention.TreeAttention.take_glimpses_inputs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="cam-sgnmt-blocks-batch-decode-module">
<h2>cam.sgnmt.blocks.batch_decode module<a class="headerlink" href="#cam-sgnmt-blocks-batch-decode-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-cam.sgnmt.blocks.checkpoint">
<span id="cam-sgnmt-blocks-checkpoint-module"></span><h2>cam.sgnmt.blocks.checkpoint module<a class="headerlink" href="#module-cam.sgnmt.blocks.checkpoint" title="Permalink to this headline">¶</a></h2>
<p>This file is taken from the <code class="docutils literal"><span class="pre">machine_translation</span></code> example in
Blocks and handles storing and loading NMT models and iteration states
during training. Note that this module is not used during decoding.</p>
<dl class="class">
<dt id="cam.sgnmt.blocks.checkpoint.CheckpointNMT">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.checkpoint.</code><code class="descname">CheckpointNMT</code><span class="sig-paren">(</span><em>saveto</em>, <em>slim_iteration_state</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/checkpoint.html#CheckpointNMT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.checkpoint.CheckpointNMT" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">blocks.extensions.SimpleExtension</span></code>, <a class="reference internal" href="#cam.sgnmt.blocks.checkpoint.SaveLoadUtils" title="cam.sgnmt.blocks.checkpoint.SaveLoadUtils"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.blocks.checkpoint.SaveLoadUtils</span></code></a></p>
<p>Redefines checkpointing for NMT.</p>
<p>Saves only parameters (npz), iteration state (pickle) and log (pickle).</p>
<dl class="method">
<dt id="cam.sgnmt.blocks.checkpoint.CheckpointNMT.do">
<code class="descname">do</code><span class="sig-paren">(</span><em>callback_name</em>, <em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/checkpoint.html#CheckpointNMT.do"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.checkpoint.CheckpointNMT.do" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.checkpoint.CheckpointNMT.dump">
<code class="descname">dump</code><span class="sig-paren">(</span><em>main_loop</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/checkpoint.html#CheckpointNMT.dump"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.checkpoint.CheckpointNMT.dump" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.checkpoint.CheckpointNMT.dump_iteration_state">
<code class="descname">dump_iteration_state</code><span class="sig-paren">(</span><em>main_loop</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/checkpoint.html#CheckpointNMT.dump_iteration_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.checkpoint.CheckpointNMT.dump_iteration_state" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.checkpoint.CheckpointNMT.dump_log">
<code class="descname">dump_log</code><span class="sig-paren">(</span><em>main_loop</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/checkpoint.html#CheckpointNMT.dump_log"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.checkpoint.CheckpointNMT.dump_log" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.checkpoint.CheckpointNMT.dump_parameters">
<code class="descname">dump_parameters</code><span class="sig-paren">(</span><em>main_loop</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/checkpoint.html#CheckpointNMT.dump_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.checkpoint.CheckpointNMT.dump_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.blocks.checkpoint.LoadNMT">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.checkpoint.</code><code class="descname">LoadNMT</code><span class="sig-paren">(</span><em>saveto</em>, <em>slim_iteration_state</em>, <em>reset_epoch=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/checkpoint.html#LoadNMT"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.checkpoint.LoadNMT" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">blocks.extensions.TrainingExtension</span></code>, <a class="reference internal" href="#cam.sgnmt.blocks.checkpoint.SaveLoadUtils" title="cam.sgnmt.blocks.checkpoint.SaveLoadUtils"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.blocks.checkpoint.SaveLoadUtils</span></code></a></p>
<p>Loads parameters log and iterations state.</p>
<dl class="method">
<dt id="cam.sgnmt.blocks.checkpoint.LoadNMT.before_training">
<code class="descname">before_training</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/checkpoint.html#LoadNMT.before_training"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.checkpoint.LoadNMT.before_training" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.checkpoint.LoadNMT.load_iteration_state">
<code class="descname">load_iteration_state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/checkpoint.html#LoadNMT.load_iteration_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.checkpoint.LoadNMT.load_iteration_state" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.checkpoint.LoadNMT.load_log">
<code class="descname">load_log</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/checkpoint.html#LoadNMT.load_log"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.checkpoint.LoadNMT.load_log" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.checkpoint.LoadNMT.load_parameters">
<code class="descname">load_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/checkpoint.html#LoadNMT.load_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.checkpoint.LoadNMT.load_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.checkpoint.LoadNMT.load_to">
<code class="descname">load_to</code><span class="sig-paren">(</span><em>main_loop</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/checkpoint.html#LoadNMT.load_to"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.checkpoint.LoadNMT.load_to" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads the dump from the root folder into the main loop.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.blocks.checkpoint.SaveLoadUtils">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.checkpoint.</code><code class="descname">SaveLoadUtils</code><a class="reference internal" href="_modules/cam/sgnmt/blocks/checkpoint.html#SaveLoadUtils"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.checkpoint.SaveLoadUtils" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Utility class for checkpointing.</p>
<dl class="method">
<dt id="cam.sgnmt.blocks.checkpoint.SaveLoadUtils.load_parameter_values">
<code class="descname">load_parameter_values</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/checkpoint.html#SaveLoadUtils.load_parameter_values"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.checkpoint.SaveLoadUtils.load_parameter_values" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="cam.sgnmt.blocks.checkpoint.SaveLoadUtils.path_to_folder">
<code class="descname">path_to_folder</code><a class="headerlink" href="#cam.sgnmt.blocks.checkpoint.SaveLoadUtils.path_to_folder" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="cam.sgnmt.blocks.checkpoint.SaveLoadUtils.path_to_iteration_state">
<code class="descname">path_to_iteration_state</code><a class="headerlink" href="#cam.sgnmt.blocks.checkpoint.SaveLoadUtils.path_to_iteration_state" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="cam.sgnmt.blocks.checkpoint.SaveLoadUtils.path_to_log">
<code class="descname">path_to_log</code><a class="headerlink" href="#cam.sgnmt.blocks.checkpoint.SaveLoadUtils.path_to_log" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="cam.sgnmt.blocks.checkpoint.SaveLoadUtils.path_to_parameters">
<code class="descname">path_to_parameters</code><a class="headerlink" href="#cam.sgnmt.blocks.checkpoint.SaveLoadUtils.path_to_parameters" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.checkpoint.SaveLoadUtils.save_parameter_values">
<code class="descname">save_parameter_values</code><span class="sig-paren">(</span><em>param_values</em>, <em>path</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/checkpoint.html#SaveLoadUtils.save_parameter_values"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.checkpoint.SaveLoadUtils.save_parameter_values" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-cam.sgnmt.blocks.decoder">
<span id="cam-sgnmt-blocks-decoder-module"></span><h2>cam.sgnmt.blocks.decoder module<a class="headerlink" href="#module-cam.sgnmt.blocks.decoder" title="Permalink to this headline">¶</a></h2>
<p>This module contains classes related to the decoder network in
encoder-decoder architectures. Note that this has nothing to do with
the search strategies which are also named &#8220;decoder&#8221; in SGNMT. Instead
of search algorithms, this module defines bricks which can be used to
combine the final encoder-decoder network.</p>
<dl class="class">
<dt id="cam.sgnmt.blocks.decoder.Decoder">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.decoder.</code><code class="descname">Decoder</code><span class="sig-paren">(</span><em>vocab_size</em>, <em>embedding_dim</em>, <em>state_dim</em>, <em>att_dim</em>, <em>maxout_dim</em>, <em>representation_dim</em>, <em>attention_strategy='content'</em>, <em>attention_sources='s'</em>, <em>readout_sources='sfa'</em>, <em>memory='none'</em>, <em>memory_size=500</em>, <em>seq_len=50</em>, <em>init_strategy='last'</em>, <em>make_prunable=False</em>, <em>theano_seed=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/decoder.html#Decoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.decoder.Decoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">blocks.bricks.interfaces.Initializable</span></code></p>
<p>Decoder of RNNsearch model which uses a full softmax output
layer and embedding matrices for feedback.</p>
<dl class="attribute">
<dt id="cam.sgnmt.blocks.decoder.Decoder.cost">
<code class="descname">cost</code><a class="headerlink" href="#cam.sgnmt.blocks.decoder.Decoder.cost" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="cam.sgnmt.blocks.decoder.Decoder.generate">
<code class="descname">generate</code><a class="headerlink" href="#cam.sgnmt.blocks.decoder.Decoder.generate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.blocks.decoder.GRUInitialState">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.decoder.</code><code class="descname">GRUInitialState</code><span class="sig-paren">(</span><em>attended_dim</em>, <em>init_strategy='last'</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/decoder.html#GRUInitialState"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.decoder.GRUInitialState" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">blocks.bricks.recurrent.GatedRecurrent</span></code></p>
<p>Gated Recurrent with special initial state.</p>
<dl class="attribute">
<dt id="cam.sgnmt.blocks.decoder.GRUInitialState.initial_states">
<code class="descname">initial_states</code><a class="headerlink" href="#cam.sgnmt.blocks.decoder.GRUInitialState.initial_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the initial state depending on <code class="docutils literal"><span class="pre">init_strategy</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.blocks.decoder.InitializableFeedforwardSequence">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.decoder.</code><code class="descname">InitializableFeedforwardSequence</code><span class="sig-paren">(</span><em>application_methods</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/decoder.html#InitializableFeedforwardSequence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.decoder.InitializableFeedforwardSequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">blocks.bricks.sequences.FeedforwardSequence</span></code>, <code class="xref py py-class docutils literal"><span class="pre">blocks.bricks.interfaces.Initializable</span></code></p>
<p>Empty helper class</p>
</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.blocks.decoder.LookupFeedbackWMT15">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.decoder.</code><code class="descname">LookupFeedbackWMT15</code><span class="sig-paren">(</span><em>num_outputs=None</em>, <em>feedback_dim=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/decoder.html#LookupFeedbackWMT15"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.decoder.LookupFeedbackWMT15" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">blocks.bricks.sequence_generators.LookupFeedback</span></code></p>
<p>Zero-out initial readout feedback by checking its value.</p>
<dl class="attribute">
<dt id="cam.sgnmt.blocks.decoder.LookupFeedbackWMT15.feedback">
<code class="descname">feedback</code><a class="headerlink" href="#cam.sgnmt.blocks.decoder.LookupFeedbackWMT15.feedback" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.blocks.decoder.NoLookupDecoder">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.decoder.</code><code class="descname">NoLookupDecoder</code><span class="sig-paren">(</span><em>vocab_size</em>, <em>embedding_dim</em>, <em>state_dim</em>, <em>att_dim</em>, <em>maxout_dim</em>, <em>representation_dim</em>, <em>attention_strategy='content'</em>, <em>attention_sources='s'</em>, <em>readout_sources='sfa'</em>, <em>memory='none'</em>, <em>memory_size=500</em>, <em>seq_len=50</em>, <em>init_strategy='last'</em>, <em>theano_seed=None</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/decoder.html#NoLookupDecoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.decoder.NoLookupDecoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">blocks.bricks.interfaces.Initializable</span></code></p>
<p>This is the decoder implementation without embedding layer or
softmax. The target sentence is represented as a sequence of #
vectors as defined by the sparse feature map.</p>
<dl class="attribute">
<dt id="cam.sgnmt.blocks.decoder.NoLookupDecoder.cost">
<code class="descname">cost</code><a class="headerlink" href="#cam.sgnmt.blocks.decoder.NoLookupDecoder.cost" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="cam.sgnmt.blocks.decoder.NoLookupDecoder.generate">
<code class="descname">generate</code><a class="headerlink" href="#cam.sgnmt.blocks.decoder.NoLookupDecoder.generate" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.blocks.decoder.NoLookupEmitter">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.decoder.</code><code class="descname">NoLookupEmitter</code><span class="sig-paren">(</span><em>*args</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/decoder.html#NoLookupEmitter"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.decoder.NoLookupEmitter" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">blocks.bricks.sequence_generators.AbstractEmitter</span></code></p>
<p>Emitter brick in the readout network without embedding (i.e.
with target sparse feature maps). Directly emits the readouts</p>
<dl class="attribute">
<dt id="cam.sgnmt.blocks.decoder.NoLookupEmitter.cost">
<code class="descname">cost</code><a class="headerlink" href="#cam.sgnmt.blocks.decoder.NoLookupEmitter.cost" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="cam.sgnmt.blocks.decoder.NoLookupEmitter.emit">
<code class="descname">emit</code><a class="headerlink" href="#cam.sgnmt.blocks.decoder.NoLookupEmitter.emit" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.decoder.NoLookupEmitter.get_dim">
<code class="descname">get_dim</code><span class="sig-paren">(</span><em>name</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/decoder.html#NoLookupEmitter.get_dim"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.decoder.NoLookupEmitter.get_dim" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="cam.sgnmt.blocks.decoder.NoLookupEmitter.initial_outputs">
<code class="descname">initial_outputs</code><a class="headerlink" href="#cam.sgnmt.blocks.decoder.NoLookupEmitter.initial_outputs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="attribute">
<dt id="cam.sgnmt.blocks.decoder.NoLookupEmitter.probs">
<code class="descname">probs</code><a class="headerlink" href="#cam.sgnmt.blocks.decoder.NoLookupEmitter.probs" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-cam.sgnmt.blocks.encoder">
<span id="cam-sgnmt-blocks-encoder-module"></span><h2>cam.sgnmt.blocks.encoder module<a class="headerlink" href="#module-cam.sgnmt.blocks.encoder" title="Permalink to this headline">¶</a></h2>
<p>Contains the different implementations of the encoder network in a
NMT encoder-decoder model. This module is accessible via the <code class="docutils literal"><span class="pre">model</span></code>
module and should not be used directly.</p>
<dl class="class">
<dt id="cam.sgnmt.blocks.encoder.BidirectionalEncoder">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.encoder.</code><code class="descname">BidirectionalEncoder</code><span class="sig-paren">(</span><em>vocab_size</em>, <em>embedding_dim</em>, <em>n_layers</em>, <em>skip_connections</em>, <em>state_dim</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/encoder.html#BidirectionalEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.encoder.BidirectionalEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">blocks.bricks.interfaces.Initializable</span></code></p>
<p>A generalized version of the vanilla encoder of the RNNsearch
model which supports different numbers of layers. Zero layers
represent non-recurrent encoders.</p>
<dl class="attribute">
<dt id="cam.sgnmt.blocks.encoder.BidirectionalEncoder.apply">
<code class="descname">apply</code><a class="headerlink" href="#cam.sgnmt.blocks.encoder.BidirectionalEncoder.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Produces source annotations, either non-recurrently or with
a bidirectional RNN architecture.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.blocks.encoder.BidirectionalWMT15">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.encoder.</code><code class="descname">BidirectionalWMT15</code><span class="sig-paren">(</span><em>prototype</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/encoder.html#BidirectionalWMT15"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.encoder.BidirectionalWMT15" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">blocks.bricks.recurrent.Bidirectional</span></code></p>
<p>Wrap two Gated Recurrents each having separate parameters.</p>
<dl class="attribute">
<dt id="cam.sgnmt.blocks.encoder.BidirectionalWMT15.apply">
<code class="descname">apply</code><a class="headerlink" href="#cam.sgnmt.blocks.encoder.BidirectionalWMT15.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies forward and backward networks and concatenates
outputs.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.blocks.encoder.DeepBidirectionalEncoder">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.encoder.</code><code class="descname">DeepBidirectionalEncoder</code><span class="sig-paren">(</span><em>vocab_size</em>, <em>embedding_dim</em>, <em>n_layers</em>, <em>skip_connections</em>, <em>state_dim</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/encoder.html#DeepBidirectionalEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.encoder.DeepBidirectionalEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">blocks.bricks.interfaces.Initializable</span></code></p>
<p>This encoder is a multi-layered version of
<code class="docutils literal"><span class="pre">BidirectionalEncoder</span></code> where parameters between layers are not
shared.</p>
<dl class="attribute">
<dt id="cam.sgnmt.blocks.encoder.DeepBidirectionalEncoder.apply">
<code class="descname">apply</code><a class="headerlink" href="#cam.sgnmt.blocks.encoder.DeepBidirectionalEncoder.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Produces source annotations, either non-recurrently or with
a bidirectional RNN architecture.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.blocks.encoder.EncoderWithAnnotators">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.encoder.</code><code class="descname">EncoderWithAnnotators</code><span class="sig-paren">(</span><em>base_encoder</em>, <em>annotators</em>, <em>add_direct</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/encoder.html#EncoderWithAnnotators"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.encoder.EncoderWithAnnotators" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">blocks.bricks.interfaces.Initializable</span></code></p>
<p>This encoder extends the annotations of the standard encoder by
additional ones. These additional annotations are derived from the
flat encoder annotations by <code class="docutils literal"><span class="pre">Annotator</span></code> instances.</p>
<dl class="attribute">
<dt id="cam.sgnmt.blocks.encoder.EncoderWithAnnotators.apply">
<code class="descname">apply</code><a class="headerlink" href="#cam.sgnmt.blocks.encoder.EncoderWithAnnotators.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the final list of annotations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source_sentence</strong> (<em>Variable</em>) &#8211; Source sentence with words in
vector representation.</li>
<li><strong>source_sentence_mask</strong> (<em>Variable</em>) &#8211; Source mask</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Variable. source annotations</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.blocks.encoder.HierarchicalAnnotator">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.encoder.</code><code class="descname">HierarchicalAnnotator</code><span class="sig-paren">(</span><em>base_encoder</em>, <em>state_dim=1000</em>, <em>self_attendable=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/encoder.html#HierarchicalAnnotator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.encoder.HierarchicalAnnotator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">blocks.bricks.interfaces.Initializable</span></code></p>
<p>This annotator creates higher level annotations by using a
network which is similar to the attentional decoder network to
produce a sequence of new annotations.</p>
<dl class="attribute">
<dt id="cam.sgnmt.blocks.encoder.HierarchicalAnnotator.apply">
<code class="descname">apply</code><a class="headerlink" href="#cam.sgnmt.blocks.encoder.HierarchicalAnnotator.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.blocks.encoder.NoLookupEncoder">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.encoder.</code><code class="descname">NoLookupEncoder</code><span class="sig-paren">(</span><em>embedding_dim</em>, <em>state_dim</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/encoder.html#NoLookupEncoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.encoder.NoLookupEncoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">blocks.bricks.interfaces.Initializable</span></code></p>
<p>This is a variation of <code class="docutils literal"><span class="pre">BidirectionalEncoder</span></code> which works with
sparse feature maps. It does not use a lookup table but directly
feeds the predefined distributed representations into the encoder
network.</p>
<dl class="attribute">
<dt id="cam.sgnmt.blocks.encoder.NoLookupEncoder.apply">
<code class="descname">apply</code><a class="headerlink" href="#cam.sgnmt.blocks.encoder.NoLookupEncoder.apply" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates bidirectional RNN source annotations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>source_sentence</strong> (<em>Variable</em>) &#8211; Source sentence with words in
vector representation.</li>
<li><strong>source_sentence_mask</strong> (<em>Variable</em>) &#8211; Source mask</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Variable. source annotations</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-cam.sgnmt.blocks.model">
<span id="cam-sgnmt-blocks-model-module"></span><h2>cam.sgnmt.blocks.model module<a class="headerlink" href="#module-cam.sgnmt.blocks.model" title="Permalink to this headline">¶</a></h2>
<p>This file contains the <code class="docutils literal"><span class="pre">NMTModel</span></code> class which is the main
interface to the NMT implementations in Blocks. All main runner scripts
(<code class="docutils literal"><span class="pre">train.py</span></code>, <code class="docutils literal"><span class="pre">decode.py</span></code>, and <code class="docutils literal"><span class="pre">align.py</span></code>) access Blocks NMT
models through this class. According to the NMT config, it composes the
final NMT model using an encoder, attention, and decoder network which
are implemented in the modules <code class="docutils literal"><span class="pre">encoder.py</span></code>, <code class="docutils literal"><span class="pre">attention.py</span></code>, and
<code class="docutils literal"><span class="pre">decoder.py</span></code>.</p>
<dl class="class">
<dt id="cam.sgnmt.blocks.model.LoadNMTUtils">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.model.</code><code class="descname">LoadNMTUtils</code><span class="sig-paren">(</span><em>nmt_model_path</em>, <em>saveto</em>, <em>model</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/model.html#LoadNMTUtils"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.model.LoadNMTUtils" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.blocks.checkpoint.SaveLoadUtils" title="cam.sgnmt.blocks.checkpoint.SaveLoadUtils"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.blocks.checkpoint.SaveLoadUtils</span></code></a></p>
<p>Loads parameters log and iterations state. This class is adapted
from the <code class="docutils literal"><span class="pre">LoadNMT</span></code> class in the blocks example and contains
some copied code. Note that we do not use BLOCKS_DELIMITER.
Instead, we always use &#8216;-&#8216; to keep back compatibility with older
models.</p>
<dl class="method">
<dt id="cam.sgnmt.blocks.model.LoadNMTUtils.load_parameters">
<code class="descname">load_parameters</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/model.html#LoadNMTUtils.load_parameters"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.model.LoadNMTUtils.load_parameters" title="Permalink to this definition">¶</a></dt>
<dd><p>Currently not used, kept for consistency with blocks
reference implementation.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.model.LoadNMTUtils.load_weights">
<code class="descname">load_weights</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/model.html#LoadNMTUtils.load_weights"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.model.LoadNMTUtils.load_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Load the model parameters from the model file. Compare with
<code class="docutils literal"><span class="pre">blocks.machine_translation.LoadNMT</span></code>.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.blocks.model.NMTModel">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.model.</code><code class="descname">NMTModel</code><span class="sig-paren">(</span><em>config={}</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/model.html#NMTModel"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.model.NMTModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Encapsulates an NMT model. Calling <code class="docutils literal"><span class="pre">set_up</span></code> will initialize
all the attributes.</p>
<dl class="attribute">
<dt id="cam.sgnmt.blocks.model.NMTModel.samples">
<code class="descname">samples</code><a class="headerlink" href="#cam.sgnmt.blocks.model.NMTModel.samples" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Variable</em> &#8211; Samples variable used for search algorithms</p>
</dd></dl>

<dl class="attribute">
<dt id="cam.sgnmt.blocks.model.NMTModel.cost">
<code class="descname">cost</code><a class="headerlink" href="#cam.sgnmt.blocks.model.NMTModel.cost" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Variable</em> &#8211; Model cost</p>
</dd></dl>

<dl class="attribute">
<dt id="cam.sgnmt.blocks.model.NMTModel.search_model">
<code class="descname">search_model</code><a class="headerlink" href="#cam.sgnmt.blocks.model.NMTModel.search_model" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Variable</em> &#8211; Decoding model</p>
</dd></dl>

<dl class="attribute">
<dt id="cam.sgnmt.blocks.model.NMTModel.training_model">
<code class="descname">training_model</code><a class="headerlink" href="#cam.sgnmt.blocks.model.NMTModel.training_model" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Variable</em> &#8211; Training model</p>
</dd></dl>

<dl class="attribute">
<dt id="cam.sgnmt.blocks.model.NMTModel.sampling_input">
<code class="descname">sampling_input</code><a class="headerlink" href="#cam.sgnmt.blocks.model.NMTModel.sampling_input" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Variable</em> &#8211; Input variable for the source sentence</p>
</dd></dl>

<dl class="attribute">
<dt id="cam.sgnmt.blocks.model.NMTModel.cg">
<code class="descname">cg</code><a class="headerlink" href="#cam.sgnmt.blocks.model.NMTModel.cg" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Graph</em> &#8211; Computational graph</p>
</dd></dl>

<dl class="attribute">
<dt id="cam.sgnmt.blocks.model.NMTModel.encoder">
<code class="descname">encoder</code><a class="headerlink" href="#cam.sgnmt.blocks.model.NMTModel.encoder" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Encoder</em> &#8211; Encoder network</p>
</dd></dl>

<dl class="attribute">
<dt id="cam.sgnmt.blocks.model.NMTModel.align_models">
<code class="descname">align_models</code><a class="headerlink" href="#cam.sgnmt.blocks.model.NMTModel.align_models" title="Permalink to this definition">¶</a></dt>
<dd><p><em>dict</em> &#8211; Dictionary of alignment models indexed
by source sentence length</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.model.NMTModel.set_up">
<code class="descname">set_up</code><span class="sig-paren">(</span><em>config=None</em>, <em>make_prunable=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/model.html#NMTModel.set_up"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.model.NMTModel.set_up" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads and initializes all the theano variables for the
training model and the decoding model.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>config</strong> (<em>dict</em>) &#8211; NMT configuration</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-cam.sgnmt.blocks.nmt">
<span id="cam-sgnmt-blocks-nmt-module"></span><h2>cam.sgnmt.blocks.nmt module<a class="headerlink" href="#module-cam.sgnmt.blocks.nmt" title="Permalink to this headline">¶</a></h2>
<p>This module is the interface to the blocks NMT implementation.</p>
<dl class="data">
<dt id="cam.sgnmt.blocks.nmt.BEST_BLEU_PATTERN">
<code class="descclassname">cam.sgnmt.blocks.nmt.</code><code class="descname">BEST_BLEU_PATTERN</code><em class="property"> = &lt;_sre.SRE_Pattern object&gt;</em><a class="headerlink" href="#cam.sgnmt.blocks.nmt.BEST_BLEU_PATTERN" title="Permalink to this definition">¶</a></dt>
<dd><p>Pattern for checkpoints created in training for model selection</p>
</dd></dl>

<dl class="data">
<dt id="cam.sgnmt.blocks.nmt.PARAMS_FILE_NAME">
<code class="descclassname">cam.sgnmt.blocks.nmt.</code><code class="descname">PARAMS_FILE_NAME</code><em class="property"> = 'params.npz'</em><a class="headerlink" href="#cam.sgnmt.blocks.nmt.PARAMS_FILE_NAME" title="Permalink to this definition">¶</a></dt>
<dd><p>Name of the default model file (not checkpoints)</p>
</dd></dl>

<dl class="function">
<dt id="cam.sgnmt.blocks.nmt.blocks_add_nmt_config">
<code class="descclassname">cam.sgnmt.blocks.nmt.</code><code class="descname">blocks_add_nmt_config</code><span class="sig-paren">(</span><em>parser</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/nmt.html#blocks_add_nmt_config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.nmt.blocks_add_nmt_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds the nmt options to the command line configuration.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>parser</strong> (<em>object</em>) &#8211; Parser or ArgumentGroup object</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="cam.sgnmt.blocks.nmt.blocks_get_default_nmt_config">
<code class="descclassname">cam.sgnmt.blocks.nmt.</code><code class="descname">blocks_get_default_nmt_config</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/nmt.html#blocks_get_default_nmt_config"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.nmt.blocks_get_default_nmt_config" title="Permalink to this definition">¶</a></dt>
<dd><p>Get default NMT configuration.</p>
</dd></dl>

<dl class="function">
<dt id="cam.sgnmt.blocks.nmt.blocks_get_nmt_config_help">
<code class="descclassname">cam.sgnmt.blocks.nmt.</code><code class="descname">blocks_get_nmt_config_help</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/nmt.html#blocks_get_nmt_config_help"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.nmt.blocks_get_nmt_config_help" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a dictionary with help text for the NMT configuration</p>
</dd></dl>

<dl class="function">
<dt id="cam.sgnmt.blocks.nmt.blocks_get_nmt_predictor">
<code class="descclassname">cam.sgnmt.blocks.nmt.</code><code class="descname">blocks_get_nmt_predictor</code><span class="sig-paren">(</span><em>args</em>, <em>nmt_path</em>, <em>nmt_config</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/nmt.html#blocks_get_nmt_predictor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.nmt.blocks_get_nmt_predictor" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the Blocks NMT predictor. If a target sparse feature map is
used, we create an unbounded vocabulary NMT predictor. Otherwise,
the normal bounded NMT predictor is returned</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>args</strong> (<em>object</em>) &#8211; SGNMT arguments from <code class="docutils literal"><span class="pre">ArgumentParser</span></code></li>
<li><strong>nmt_config</strong> (<em>dict</em>) &#8211; NMT configuration</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Predictor. The NMT predictor</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="cam.sgnmt.blocks.nmt.blocks_get_nmt_vanilla_decoder">
<code class="descclassname">cam.sgnmt.blocks.nmt.</code><code class="descname">blocks_get_nmt_vanilla_decoder</code><span class="sig-paren">(</span><em>args</em>, <em>nmt_specs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/nmt.html#blocks_get_nmt_vanilla_decoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.nmt.blocks_get_nmt_vanilla_decoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the Blocks NMT vanilla decoder.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>args</strong> (<em>object</em>) &#8211; SGNMT arguments from <code class="docutils literal"><span class="pre">ArgumentParser</span></code></li>
<li><strong>nmt_specs</strong> (<em>list</em>) &#8211; List of (nmt_path,nmt_config) tuples, one
entry for each model in the ensemble</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Predictor. An instance of <code class="docutils literal"><span class="pre">BlocksNMTVanillaDecoder</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="cam.sgnmt.blocks.nmt.get_nmt_model_path">
<code class="descclassname">cam.sgnmt.blocks.nmt.</code><code class="descname">get_nmt_model_path</code><span class="sig-paren">(</span><em>nmt_model_selector</em>, <em>nmt_config</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/nmt.html#get_nmt_model_path"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.nmt.get_nmt_model_path" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the path to the NMT model according the given NMT config.
This switches between the most recent checkpoint, the best BLEU
checkpoint, or the latest parameters (params.npz). This method
delegates to <code class="docutils literal"><span class="pre">get_nmt_model_path_*</span></code>. This
method relies on the global <code class="docutils literal"><span class="pre">args</span></code> variable.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>nmt_model_selector</strong> (<em>string</em>) &#8211; the <code class="docutils literal"><span class="pre">--nmt_model_selector</span></code> arg
which defines the policy to decide
which NMT model to load (params,
bleu, or time)</li>
<li><strong>nmt_config</strong> (<em>dict</em>) &#8211; NMT configuration, see <code class="docutils literal"><span class="pre">get_nmt_config()</span></code></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">string. Path to the NMT model file</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="cam.sgnmt.blocks.nmt.get_nmt_model_path_best_bleu">
<code class="descclassname">cam.sgnmt.blocks.nmt.</code><code class="descname">get_nmt_model_path_best_bleu</code><span class="sig-paren">(</span><em>nmt_config</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/nmt.html#get_nmt_model_path_best_bleu"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.nmt.get_nmt_model_path_best_bleu" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the path to the checkpoint with the best BLEU score. If
no checkpoint can be found, back up to params.npz.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>nmt_config</strong> (<em>dict</em>) &#8211; NMT configuration. We will use the field
<code class="docutils literal"><span class="pre">saveto</span></code> to get the training directory</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">string. Path to the checkpoint file with best BLEU score</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="cam.sgnmt.blocks.nmt.get_nmt_model_path_most_recent">
<code class="descclassname">cam.sgnmt.blocks.nmt.</code><code class="descname">get_nmt_model_path_most_recent</code><span class="sig-paren">(</span><em>nmt_config</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/nmt.html#get_nmt_model_path_most_recent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.nmt.get_nmt_model_path_most_recent" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the path to the most recent checkpoint. If
no checkpoint can be found, back up to params.npz.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>nmt_config</strong> (<em>dict</em>) &#8211; NMT configuration. We will use the field
<code class="docutils literal"><span class="pre">saveto</span></code> to get the training directory</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">string. Path to the most recent checkpoint file</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="cam.sgnmt.blocks.nmt.get_nmt_model_path_params">
<code class="descclassname">cam.sgnmt.blocks.nmt.</code><code class="descname">get_nmt_model_path_params</code><span class="sig-paren">(</span><em>nmt_config</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/nmt.html#get_nmt_model_path_params"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.nmt.get_nmt_model_path_params" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the path to the params.npz. This file usually contains
the latest model parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>nmt_config</strong> (<em>dict</em>) &#8211; NMT configuration. We will use the field
<code class="docutils literal"><span class="pre">saveto</span></code> to get the training directory</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">string. Path to the params.npz</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-cam.sgnmt.blocks.pruning">
<span id="cam-sgnmt-blocks-pruning-module"></span><h2>cam.sgnmt.blocks.pruning module<a class="headerlink" href="#module-cam.sgnmt.blocks.pruning" title="Permalink to this headline">¶</a></h2>
<p>This module contains code for model pruning during training. This
implements the data-bound neuron removal algorithm descibed in</p>
<p>Unfolding and Shrinking Neural Machine Translation Ensembles
Felix Stahlberg and Bill Byrne
<a class="reference external" href="https://arxiv.org/abs/1704.03279">https://arxiv.org/abs/1704.03279</a></p>
<p>Note that to avoid rebuilding the computation graph after each
prunning operation, we do not remove neurons but set their connections
to zero. To realize speed ups, neurons with zero weights must be
removed in a postprocessing step.</p>
<dl class="class">
<dt id="cam.sgnmt.blocks.pruning.Connection">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.pruning.</code><code class="descname">Connection</code><span class="sig-paren">(</span><em>direction</em>, <em>mat_name</em>, <em>dim</em>, <em>start_idx=0.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/pruning.html#Connection"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.pruning.Connection" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>A connection between layer which is represented by a weight
matrix.</p>
</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.blocks.pruning.PrunableInitializableFeedforwardSequence">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.pruning.</code><code class="descname">PrunableInitializableFeedforwardSequence</code><span class="sig-paren">(</span><em>application_methods</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/pruning.html#PrunableInitializableFeedforwardSequence"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.pruning.PrunableInitializableFeedforwardSequence" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">blocks.bricks.sequences.FeedforwardSequence</span></code>, <code class="xref py py-class docutils literal"><span class="pre">blocks.bricks.interfaces.Initializable</span></code></p>
<p>Version of <code class="docutils literal"><span class="pre">InitializableFeedforwardSequence</span></code> which allows
keeping track of internal neuron activities.</p>
<dl class="attribute">
<dt id="cam.sgnmt.blocks.pruning.PrunableInitializableFeedforwardSequence.apply">
<code class="descname">apply</code><a class="headerlink" href="#cam.sgnmt.blocks.pruning.PrunableInitializableFeedforwardSequence.apply" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.blocks.pruning.PrunableLayer">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.pruning.</code><code class="descname">PrunableLayer</code><span class="sig-paren">(</span><em>name</em>, <em>theano_variable</em>, <em>trg_size</em>, <em>n_steps</em>, <em>maxout=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/pruning.html#PrunableLayer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.pruning.PrunableLayer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>This class represents a layer definition loaded from the file
system and keeps track of neurons which have been removed in the
layer.</p>
<dl class="method">
<dt id="cam.sgnmt.blocks.pruning.PrunableLayer.count_unpruned_neurons">
<code class="descname">count_unpruned_neurons</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/pruning.html#PrunableLayer.count_unpruned_neurons"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.pruning.PrunableLayer.count_unpruned_neurons" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the number of unpruned neurons in the layer.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.pruning.PrunableLayer.derive_step_size">
<code class="descname">derive_step_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/pruning.html#PrunableLayer.derive_step_size"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.pruning.PrunableLayer.derive_step_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculate the required step size to reach the target size
for this layer.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.pruning.PrunableLayer.get_size">
<code class="descname">get_size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/pruning.html#PrunableLayer.get_size"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.pruning.PrunableLayer.get_size" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the size of the layer.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.pruning.PrunableLayer.initialize_mask">
<code class="descname">initialize_mask</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/pruning.html#PrunableLayer.initialize_mask"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.pruning.PrunableLayer.initialize_mask" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the neuron mask to a upper triangular matrix, ie.
no neuron has been removed.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.pruning.PrunableLayer.prune">
<code class="descname">prune</code><span class="sig-paren">(</span><em>params_dict</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/pruning.html#PrunableLayer.prune"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.pruning.PrunableLayer.prune" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform a single pruning operation. The number of neurons to
delete depends on the step size and the difference between the
current and the target layer size.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>params_dict</strong> (<em>dict</em>) &#8211; Dictionary of numpy arrays</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.pruning.PrunableLayer.register_activities">
<code class="descname">register_activities</code><span class="sig-paren">(</span><em>activity</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/pruning.html#PrunableLayer.register_activities"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.pruning.PrunableLayer.register_activities" title="Permalink to this definition">¶</a></dt>
<dd><p>Store the layer activities in a training batch and update
the distance matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>activity</strong> (<em>array</em>) &#8211; Neuron activity in the most recent batch</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.pruning.PrunableLayer.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/pruning.html#PrunableLayer.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.pruning.PrunableLayer.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Resets the activity records. Can be called after a pruning
operation to maintain recency.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.pruning.PrunableLayer.sanity_check">
<code class="descname">sanity_check</code><span class="sig-paren">(</span><em>params_dict</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/pruning.html#PrunableLayer.sanity_check"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.pruning.PrunableLayer.sanity_check" title="Permalink to this definition">¶</a></dt>
<dd><p>Checks whether the weight matrices are consistent with the
list of neurons which have been removed so far. All incoming
and outgoing connections of prunned neurons should be zero.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>params_dict</strong> (<em>dict</em>) &#8211; Dictionary with numpy arrays</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.blocks.pruning.PrunableSequenceGenerator">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.pruning.</code><code class="descname">PrunableSequenceGenerator</code><span class="sig-paren">(</span><em>readout</em>, <em>transition</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/pruning.html#PrunableSequenceGenerator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.pruning.PrunableSequenceGenerator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">blocks.bricks.sequence_generators.SequenceGenerator</span></code></p>
<p>A sequence generator which keeps prunable layers as class
variables s.t. they can be accessed later.</p>
<dl class="attribute">
<dt id="cam.sgnmt.blocks.pruning.PrunableSequenceGenerator.cost_matrix">
<code class="descname">cost_matrix</code><a class="headerlink" href="#cam.sgnmt.blocks.pruning.PrunableSequenceGenerator.cost_matrix" title="Permalink to this definition">¶</a></dt>
<dd><p>Adapted from <code class="docutils literal"><span class="pre">BaseSequenceGenerator.cost_matrix</span></code></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.blocks.pruning.PruningGradientDescent">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.pruning.</code><code class="descname">PruningGradientDescent</code><span class="sig-paren">(</span><em>prune_layer_configs</em>, <em>prune_layout_path</em>, <em>prune_every</em>, <em>prune_reset_every</em>, <em>prune_n_steps</em>, <em>nmt_model</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/pruning.html#PruningGradientDescent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.pruning.PruningGradientDescent" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">blocks.algorithms.GradientDescent</span></code></p>
<p>This is a drop-in replacement for Blocks GradientDescent
optimizer. We intersperse the normal SGD updates with pruning
operations and record the neuron activities after each training
batch.</p>
<dl class="method">
<dt id="cam.sgnmt.blocks.pruning.PruningGradientDescent.initialize">
<code class="descname">initialize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/pruning.html#PruningGradientDescent.initialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.pruning.PruningGradientDescent.initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the training algorithm.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.pruning.PruningGradientDescent.initialize_layers">
<code class="descname">initialize_layers</code><span class="sig-paren">(</span><em>layer_configs</em>, <em>layout_path</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/pruning.html#PruningGradientDescent.initialize_layers"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.pruning.PruningGradientDescent.initialize_layers" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize all layers which should be pruned in the course
of this training.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>layer_configs</strong> (<em>dict</em>) &#8211; Layer configurations.</li>
<li><strong>layout_path</strong> (<em>string</em>) &#8211; Path to the network layout file.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.pruning.PruningGradientDescent.process_batch">
<code class="descname">process_batch</code><span class="sig-paren">(</span><em>batch</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/pruning.html#PruningGradientDescent.process_batch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.pruning.PruningGradientDescent.process_batch" title="Permalink to this definition">¶</a></dt>
<dd><p>Overrides <code class="docutils literal"><span class="pre">GradientDescent.process_batch</span></code> and adds
recording neuron activities and pruning neurons to the
pipeline.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>batch</strong> (<em>array</em>) &#8211; Current training batch</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="cam.sgnmt.blocks.pruning.add_in_mat">
<code class="descclassname">cam.sgnmt.blocks.pruning.</code><code class="descname">add_in_mat</code><span class="sig-paren">(</span><em>mat</em>, <em>dim</em>, <em>f_idx</em>, <em>t_idx</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/pruning.html#add_in_mat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.pruning.add_in_mat" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper method to add a row or column to another one in a matrix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mat</strong> (<em>array</em>) &#8211; two dimensional numpy array.</li>
<li><strong>dim</strong> (<em>int</em>) &#8211; 0 for rows, 1 for columns</li>
<li><strong>f_idx</strong> (<em>int</em>) &#8211; Index of the first row or column</li>
<li><strong>t_idx</strong> (<em>int</em>) &#8211; Index of the second row or column</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">array. Matrix in which the first row or column is added to the
second one.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="cam.sgnmt.blocks.pruning.compensate_for_pruning">
<code class="descclassname">cam.sgnmt.blocks.pruning.</code><code class="descname">compensate_for_pruning</code><span class="sig-paren">(</span><em>to_delete</em>, <em>layer</em>, <em>params_dict</em><span class="sig-paren">)</span><a class="headerlink" href="#cam.sgnmt.blocks.pruning.compensate_for_pruning" title="Permalink to this definition">¶</a></dt>
<dd><p>This the the strategy used to compensate for the removal of a
neuron. It can be set to <code class="docutils literal"><span class="pre">_compensate_for_pruning_interpol</span></code> or
<code class="docutils literal"><span class="pre">_compensate_for_pruning_sum</span></code>. The first one is based on linear
combinations of the remaining neurons and should be preferred for
NMT networks as shown in <a class="reference external" href="https://arxiv.org/abs/1704.03279">https://arxiv.org/abs/1704.03279</a>. The
parameter dictionary <code class="docutils literal"><span class="pre">params_dict</span></code> is updated accordingly.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>to_delete</strong> (<em>list</em>) &#8211; List of i,j neuron pairs which were selected
for deletion</li>
<li><strong>layer</strong> (<a class="reference internal" href="#cam.sgnmt.blocks.pruning.PrunableLayer" title="cam.sgnmt.blocks.pruning.PrunableLayer"><em>PrunableLayer</em></a>) &#8211; The layer which we are currently pruning</li>
<li><strong>params_dict</strong> (<em>dict</em>) &#8211; Dictionary of numpy arrays (weight matrices)</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="cam.sgnmt.blocks.pruning.get_activity_discounts">
<code class="descclassname">cam.sgnmt.blocks.pruning.</code><code class="descname">get_activity_discounts</code><span class="sig-paren">(</span><em>layer</em><span class="sig-paren">)</span><a class="headerlink" href="#cam.sgnmt.blocks.pruning.get_activity_discounts" title="Permalink to this definition">¶</a></dt>
<dd><p>We decide which neuron to prune based on (a) their similarity, and
(b) we prefer neurons with small activity. We provide two strategies
for (b): Using the minimum or the sum of the activities in neuron
pairs. The original method uses the minimum.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>layer</strong> (<a class="reference internal" href="#cam.sgnmt.blocks.pruning.PrunableLayer" title="cam.sgnmt.blocks.pruning.PrunableLayer"><em>PrunableLayer</em></a>) &#8211; The layer which is to be pruned</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">array. Discount matrix for the layer.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="cam.sgnmt.blocks.pruning.set_zero_in_mat">
<code class="descclassname">cam.sgnmt.blocks.pruning.</code><code class="descname">set_zero_in_mat</code><span class="sig-paren">(</span><em>mat</em>, <em>dim</em>, <em>idx</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/pruning.html#set_zero_in_mat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.pruning.set_zero_in_mat" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper method to set a row or column to zero.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>mat</strong> (<em>array</em>) &#8211; two dimensional numpy array.</li>
<li><strong>dim</strong> (<em>int</em>) &#8211; 0 for rows, 1 for columns</li>
<li><strong>idx</strong> (<em>int</em>) &#8211; Index of the row or column</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">array. Matrix in which the <code class="docutils literal"><span class="pre">idx</span></code>-the row or column is
set to zero.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-cam.sgnmt.blocks.sampling">
<span id="cam-sgnmt-blocks-sampling-module"></span><h2>cam.sgnmt.blocks.sampling module<a class="headerlink" href="#module-cam.sgnmt.blocks.sampling" title="Permalink to this headline">¶</a></h2>
<p>This module is derived from the <code class="docutils literal"><span class="pre">sampling</span></code> module in the Blocks
NMT example, but reduced to providing functionality for model selection
according the BLEU score on the dev set.</p>
<dl class="class">
<dt id="cam.sgnmt.blocks.sampling.BleuValidator">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.sampling.</code><code class="descname">BleuValidator</code><span class="sig-paren">(</span><em>source_sentence</em>, <em>samples</em>, <em>model</em>, <em>data_stream</em>, <em>config</em>, <em>n_best=1</em>, <em>track_n_models=1</em>, <em>normalize=True</em>, <em>store_full_main_loop=False</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/sampling.html#BleuValidator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.sampling.BleuValidator" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">blocks.extensions.SimpleExtension</span></code></p>
<p>Implements early stopping based on BLEU score. This class is
still very similar to the <code class="docutils literal"><span class="pre">BleuValidator</span></code> in the NMT Blocks
example.</p>
<p>TODO: Refactor, make this more similar to the rest of SGNMT, use
vanilla_decoder.py</p>
<dl class="method">
<dt id="cam.sgnmt.blocks.sampling.BleuValidator.do">
<code class="descname">do</code><span class="sig-paren">(</span><em>which_callback</em>, <em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/sampling.html#BleuValidator.do"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.sampling.BleuValidator.do" title="Permalink to this definition">¶</a></dt>
<dd><p>Decodes the dev set and stores checkpoints in case the BLEU
score has improved.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.sampling.BleuValidator.save_parameter_values">
<code class="descname">save_parameter_values</code><span class="sig-paren">(</span><em>param_values</em>, <em>path</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/sampling.html#BleuValidator.save_parameter_values"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.sampling.BleuValidator.save_parameter_values" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is copied from blocks.machine_translation.checkpoint</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.blocks.sampling.ModelInfo">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.sampling.</code><code class="descname">ModelInfo</code><span class="sig-paren">(</span><em>bleu_score</em>, <em>path=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/sampling.html#ModelInfo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.sampling.ModelInfo" title="Permalink to this definition">¶</a></dt>
<dd><p>Utility class for keeping track of evaluated models.</p>
</dd></dl>

</div>
<div class="section" id="module-cam.sgnmt.blocks.sparse_search">
<span id="cam-sgnmt-blocks-sparse-search-module"></span><h2>cam.sgnmt.blocks.sparse_search module<a class="headerlink" href="#module-cam.sgnmt.blocks.sparse_search" title="Permalink to this headline">¶</a></h2>
<p>This module is similar to the <code class="docutils literal"><span class="pre">blocks.search</span></code> module but supports
search with sparse features on the output side. This is significantly
different from plain word IDs because it requires a cascaded search:
First, we do beam search to get the n best output vectors. Then, we
scan the sparse feat map table for the 12 best words given the
output vectors. In vanilla NMT, the second step is not required because
the 12 best words directly correspond to the dimensions of the output
vector.</p>
<dl class="class">
<dt id="cam.sgnmt.blocks.sparse_search.SparseBeamSearch">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.sparse_search.</code><code class="descname">SparseBeamSearch</code><span class="sig-paren">(</span><em>samples</em>, <em>trg_sparse_feat_map</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/sparse_search.html#SparseBeamSearch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.sparse_search.SparseBeamSearch" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">blocks.search.BeamSearch</span></code></p>
<p>This class modifies the original <code class="docutils literal"><span class="pre">BeamSearch</span></code> implementation
in blocks to work with sparse features on the output side. Note
that this violates the Liskov substitution principle as we inherit
only to leverage off the methods from <code class="docutils literal"><span class="pre">BeamSearch</span></code>. However, we
leave it to future work to agonize about that..</p>
<dl class="method">
<dt id="cam.sgnmt.blocks.sparse_search.SparseBeamSearch.search">
<code class="descname">search</code><span class="sig-paren">(</span><em>input_values</em>, <em>eol_symbol</em>, <em>max_length</em>, <em>ignore_first_eol=False</em>, <em>as_arrays=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/sparse_search.html#SparseBeamSearch.search"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.sparse_search.SparseBeamSearch.search" title="Permalink to this definition">¶</a></dt>
<dd><p>Performs beam search. For a full description see
<code class="docutils literal"><span class="pre">blocks.search.BeamSearch.search</span></code>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-cam.sgnmt.blocks.stream">
<span id="cam-sgnmt-blocks-stream-module"></span><h2>cam.sgnmt.blocks.stream module<a class="headerlink" href="#module-cam.sgnmt.blocks.stream" title="Permalink to this headline">¶</a></h2>
<p>This module acts as an replacement of the original <code class="docutils literal"><span class="pre">stream</span></code> module
in the Blocks NMT implementation. Some methods are copied over from the
Blocks code.</p>
<p>Additionally, this module contains more advanced data sources such as
<code class="docutils literal"><span class="pre">ParallelTextFile</span></code> for reading a parallel corpus with random access,
and the <code class="docutils literal"><span class="pre">ParallelSourceSwitchDataset</span></code> for integrating reinforcement
learning methods into the training process.</p>
<dl class="class">
<dt id="cam.sgnmt.blocks.stream.BacktranslatedParallelSource">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.stream.</code><code class="descname">BacktranslatedParallelSource</code><span class="sig-paren">(</span><em>trg_sentences</em>, <em>nmt_config</em>, <em>store_trans=None</em>, <em>max_same_word=0.3</em>, <em>reload_frequency=0</em>, <em>old_backtrans_src=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/stream.html#BacktranslatedParallelSource"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.stream.BacktranslatedParallelSource" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.blocks.stream.ParallelSource" title="cam.sgnmt.blocks.stream.ParallelSource"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.blocks.stream.ParallelSource</span></code></a></p>
<p>This data source is based on monolingual target data. The source
sentences are translated from the target sentence like described by
Senrich et al., 2015.</p>
<dl class="method">
<dt id="cam.sgnmt.blocks.stream.BacktranslatedParallelSource.backtranslate">
<code class="descname">backtranslate</code><span class="sig-paren">(</span><em>trg_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/stream.html#BacktranslatedParallelSource.backtranslate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.stream.BacktranslatedParallelSource.backtranslate" title="Permalink to this definition">¶</a></dt>
<dd><p>Translates a sentence from the target language back into the
source language.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>trg_sentence</strong> (<em>list</em>) &#8211; Target sentence ending with &lt;/S&gt;</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">list. Source sentence ending with &lt;/S&gt;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.stream.BacktranslatedParallelSource.next">
<code class="descname">next</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/stream.html#BacktranslatedParallelSource.next"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.stream.BacktranslatedParallelSource.next" title="Permalink to this definition">¶</a></dt>
<dd><p>Emits the target sentences in random order with the
backtranslated source sentence.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">tuple. synthetic source - target sentence pair</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.blocks.stream.DummyParallelSource">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.stream.</code><code class="descname">DummyParallelSource</code><span class="sig-paren">(</span><em>src_token</em>, <em>trg_sentences</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/stream.html#DummyParallelSource"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.stream.DummyParallelSource" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.blocks.stream.ParallelSource" title="cam.sgnmt.blocks.stream.ParallelSource"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.blocks.stream.ParallelSource</span></code></a></p>
<p>Represents monolingual data and uses a dummy token on the
source side to fill in the missing gap.</p>
<dl class="method">
<dt id="cam.sgnmt.blocks.stream.DummyParallelSource.next">
<code class="descname">next</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/stream.html#DummyParallelSource.next"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.stream.DummyParallelSource.next" title="Permalink to this definition">¶</a></dt>
<dd><p>Emits the target sentences in random order with a dummy
token plus &lt;/S&gt; on the source sentence</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">tuple. Next dummy token - target sentence pair</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.blocks.stream.MergedParallelSource">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.stream.</code><code class="descname">MergedParallelSource</code><span class="sig-paren">(</span><em>src1</em>, <em>src2</em>, <em>src1prob</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/stream.html#MergedParallelSource"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.stream.MergedParallelSource" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.blocks.stream.ParallelSource" title="cam.sgnmt.blocks.stream.ParallelSource"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.blocks.stream.ParallelSource</span></code></a></p>
<p>Each time <code class="docutils literal"><span class="pre">next</span></code> is called, we randomly select one of two
parallel sources and pass through the <code class="docutils literal"><span class="pre">next</span></code> request to the
selected one.</p>
<dl class="method">
<dt id="cam.sgnmt.blocks.stream.MergedParallelSource.next">
<code class="descname">next</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/stream.html#MergedParallelSource.next"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.stream.MergedParallelSource.next" title="Permalink to this definition">¶</a></dt>
<dd><p>Emits the next sentence pair of one of the sources.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">tuple. Next sentence pair</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.blocks.stream.OldBacktranslatedParallelSource">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.stream.</code><code class="descname">OldBacktranslatedParallelSource</code><span class="sig-paren">(</span><em>log_file</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/stream.html#OldBacktranslatedParallelSource"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.stream.OldBacktranslatedParallelSource" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.blocks.stream.ParallelSource" title="cam.sgnmt.blocks.stream.ParallelSource"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.blocks.stream.ParallelSource</span></code></a></p>
<p>This <code class="docutils literal"><span class="pre">ParallelSource</span></code> implementation allows access to
sentences which have been translated before. It reads a log file
created by <code class="docutils literal"><span class="pre">BacktranslatedParallelSource</span></code> and yields sentence
pairs from that file. The backtranslating parallel source can add
new sentence pairs with <code class="docutils literal"><span class="pre">add</span></code> which have not been logged in the
file yet.</p>
<dl class="method">
<dt id="cam.sgnmt.blocks.stream.OldBacktranslatedParallelSource.add">
<code class="descname">add</code><span class="sig-paren">(</span><em>idx</em>, <em>src_sen</em>, <em>trg_sen</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/stream.html#OldBacktranslatedParallelSource.add"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.stream.OldBacktranslatedParallelSource.add" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a new backtranslated sentence to this source. If a
sentence pair with the same index already exists, override it.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>idx</strong> (<em>int</em>) &#8211; Index of the sentence pair</li>
<li><strong>src_sen</strong> (<em>list</em>) &#8211; Source sentence with EOS</li>
<li><strong>trg_sen</strong> (<em>list</em>) &#8211; Target sentence with EOS</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.stream.OldBacktranslatedParallelSource.next">
<code class="descname">next</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/stream.html#OldBacktranslatedParallelSource.next"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.stream.OldBacktranslatedParallelSource.next" title="Permalink to this definition">¶</a></dt>
<dd><p>Emits the sentence pairs in random order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">tuple. Next sentence pair</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.blocks.stream.PaddingWithEOS">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.stream.</code><code class="descname">PaddingWithEOS</code><span class="sig-paren">(</span><em>data_stream</em>, <em>eos_idx</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/stream.html#PaddingWithEOS"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.stream.PaddingWithEOS" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">fuel.transformers.Padding</span></code></p>
<p>Pads a stream with given end of sequence idx.</p>
<p>This class is copied from machine_translation.stream in blocks-examples.</p>
<dl class="method">
<dt id="cam.sgnmt.blocks.stream.PaddingWithEOS.transform_batch">
<code class="descname">transform_batch</code><span class="sig-paren">(</span><em>batch</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/stream.html#PaddingWithEOS.transform_batch"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.stream.PaddingWithEOS.transform_batch" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.blocks.stream.ParallelSource">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.stream.</code><code class="descname">ParallelSource</code><a class="reference internal" href="_modules/cam/sgnmt/blocks/stream.html#ParallelSource"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.stream.ParallelSource" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Interface for sources which can be fed into
<code class="docutils literal"><span class="pre">ParallelSourceSwitchDataset</span></code>. These sources always represent an
indexed data set of sentence pairs. This can be either real
parallel training data or synthesized data were only one side is
original text and the other side is artificial (e.g. a dummy token
or back-translated sentences).</p>
<dl class="method">
<dt id="cam.sgnmt.blocks.stream.ParallelSource.next">
<code class="descname">next</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/stream.html#ParallelSource.next"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.stream.ParallelSource.next" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the next sentence pair.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body"><dl class="docutils">
<dt>tuple. First element is the source sentence, the second is</dt>
<dd>the target sentence (list of integers) without &lt;S&gt;
but with &lt;/S&gt;</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.blocks.stream.ParallelSourceSwitchDataset">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.stream.</code><code class="descname">ParallelSourceSwitchDataset</code><span class="sig-paren">(</span><em>parallel_sources</em>, <em>src_vocab_size=30000</em>, <em>trg_vocab_size=30000</em>, <em>src_sparse_feat_map=None</em>, <em>trg_sparse_feat_map=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/stream.html#ParallelSourceSwitchDataset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.stream.ParallelSourceSwitchDataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">fuel.datasets.base.Dataset</span></code></p>
<p>This bridges the gap between Fuel and the <code class="docutils literal"><span class="pre">ParallelSource</span></code>
implementations in this module. This is a Fuel <code class="docutils literal"><span class="pre">Dataset</span></code> which
uses a set of <code class="docutils literal"><span class="pre">ParallelSource</span></code> instances to produce a stream of
sentence pairs. Only one of the parallel sources is active at a
time. The active source can be changed with the
<code class="docutils literal"><span class="pre">set_active_source</span></code> method. This is particular useful in
combination with reinforcement learning policies where switching
the source corresponds to the action the agent takes.</p>
<dl class="attribute">
<dt id="cam.sgnmt.blocks.stream.ParallelSourceSwitchDataset.example_iteration_scheme">
<code class="descname">example_iteration_scheme</code><em class="property"> = None</em><a class="headerlink" href="#cam.sgnmt.blocks.stream.ParallelSourceSwitchDataset.example_iteration_scheme" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.stream.ParallelSourceSwitchDataset.get_data">
<code class="descname">get_data</code><span class="sig-paren">(</span><em>state=None</em>, <em>request=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/stream.html#ParallelSourceSwitchDataset.get_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.stream.ParallelSourceSwitchDataset.get_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Get next data entry from <code class="docutils literal"><span class="pre">active_source</span></code>, ignores args.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.stream.ParallelSourceSwitchDataset.open">
<code class="descname">open</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/stream.html#ParallelSourceSwitchDataset.open"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.stream.ParallelSourceSwitchDataset.open" title="Permalink to this definition">¶</a></dt>
<dd><p>Dummy implementation</p>
</dd></dl>

<dl class="attribute">
<dt id="cam.sgnmt.blocks.stream.ParallelSourceSwitchDataset.provides_sources">
<code class="descname">provides_sources</code><em class="property"> = ('source', 'target')</em><a class="headerlink" href="#cam.sgnmt.blocks.stream.ParallelSourceSwitchDataset.provides_sources" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.stream.ParallelSourceSwitchDataset.set_active_idx">
<code class="descname">set_active_idx</code><span class="sig-paren">(</span><em>idx</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/stream.html#ParallelSourceSwitchDataset.set_active_idx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.stream.ParallelSourceSwitchDataset.set_active_idx" title="Permalink to this definition">¶</a></dt>
<dd><p>Activates a new parallel source.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>idx</strong> (<em>int</em>) &#8211; index of the new data source</td>
</tr>
<tr class="field-even field"><th class="field-name">Raises:</th><td class="field-body"><code class="xref py py-exc docutils literal"><span class="pre">IndexError</span></code> &#8211; if <code class="docutils literal"><span class="pre">idx</span></code> is too large</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.blocks.stream.ParallelTextFile">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.stream.</code><code class="descname">ParallelTextFile</code><span class="sig-paren">(</span><em>src_file</em>, <em>trgt_file</em>, <em>src_vocab_size</em>, <em>trgt_vocab_size</em>, <em>preprocess=None</em>, <em>src_sparse_feat_map=None</em>, <em>trg_sparse_feat_map=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/stream.html#ParallelTextFile"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.stream.ParallelTextFile" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">fuel.datasets.base.Dataset</span></code></p>
<p>This <code class="docutils literal"><span class="pre">Dataset</span></code> implementation is similar to <code class="docutils literal"><span class="pre">TextFile</span></code> in
Fuel but supports random access. This makes it possible to use it
in combination with <code class="docutils literal"><span class="pre">ShuffledExampleScheme</span></code> in fuel. Another
difference is that it directly represents a database of two
text files, i.e. the resulting string does not need to be merged
with another one.</p>
<dl class="attribute">
<dt id="cam.sgnmt.blocks.stream.ParallelTextFile.example_iteration_scheme">
<code class="descname">example_iteration_scheme</code><em class="property"> = None</em><a class="headerlink" href="#cam.sgnmt.blocks.stream.ParallelTextFile.example_iteration_scheme" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.stream.ParallelTextFile.get_data">
<code class="descname">get_data</code><span class="sig-paren">(</span><em>state=None</em>, <em>request=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/stream.html#ParallelTextFile.get_data"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.stream.ParallelTextFile.get_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns a data entry, which is a pair (tuple) of source and
target sentence. Similarly to <code class="docutils literal"><span class="pre">TextFile</span></code> the sentences are
lists of word ids.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>state</strong> (<em>None</em>) &#8211; not used</li>
<li><strong>requres</strong> (<em>int</em>) &#8211; Index of the entry to load</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">2-tuple of source and target sentence at given position</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.stream.ParallelTextFile.open">
<code class="descname">open</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/stream.html#ParallelTextFile.open"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.stream.ParallelTextFile.open" title="Permalink to this definition">¶</a></dt>
<dd><p>Dummy implementation as opening is done in constructor</p>
</dd></dl>

<dl class="attribute">
<dt id="cam.sgnmt.blocks.stream.ParallelTextFile.provides_sources">
<code class="descname">provides_sources</code><em class="property"> = ('source', 'target')</em><a class="headerlink" href="#cam.sgnmt.blocks.stream.ParallelTextFile.provides_sources" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.blocks.stream.Reshuffler">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.stream.</code><code class="descname">Reshuffler</code><span class="sig-paren">(</span><em>from_idx</em>, <em>to_idx=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/stream.html#Reshuffler"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.stream.Reshuffler" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>This class can be used for reshuffling. Given a range of
integers, it shuffles them and yields the shuffled numbers one by
one. After having shown all numbers once, shuffle again and iterate
through the new list. This assures complete coverage of the data.</p>
<dl class="method">
<dt id="cam.sgnmt.blocks.stream.Reshuffler.next">
<code class="descname">next</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/stream.html#Reshuffler.next"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.stream.Reshuffler.next" title="Permalink to this definition">¶</a></dt>
<dd><p>Get an integer within the range specified in the constructor.
Numbers will be generated in a random order, but this method
guarantees that all numbers will be visited by this method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">int. A number in the given range.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.blocks.stream.ShuffledParallelSource">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.stream.</code><code class="descname">ShuffledParallelSource</code><span class="sig-paren">(</span><em>src_sentences</em>, <em>trg_sentences</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/stream.html#ShuffledParallelSource"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.stream.ShuffledParallelSource" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.blocks.stream.ParallelSource" title="cam.sgnmt.blocks.stream.ParallelSource"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.blocks.stream.ParallelSource</span></code></a></p>
<p>Simplest <code class="docutils literal"><span class="pre">ParallelSource</span></code> implementation which allows access
to parallel data in a random order.</p>
<dl class="method">
<dt id="cam.sgnmt.blocks.stream.ShuffledParallelSource.next">
<code class="descname">next</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/stream.html#ShuffledParallelSource.next"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.stream.ShuffledParallelSource.next" title="Permalink to this definition">¶</a></dt>
<dd><p>Emits the sentence pairs in random order.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">tuple. Next sentence pair</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.blocks.stream.SourceSwitchController">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.stream.</code><code class="descname">SourceSwitchController</code><span class="sig-paren">(</span><em>nmt_config</em>, <em>switch_dataset</em>, <em>part_val_set_size</em>, <em>**kwargs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/stream.html#SourceSwitchController"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.stream.SourceSwitchController" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">blocks.extensions.SimpleExtension</span></code></p>
<p>This is a super class for controlling algorithms for
<code class="docutils literal"><span class="pre">ParallelSourceSwitchDataset</span></code>. This is hooked into Blocks main
loop as extension. An example of a controller is the EXP3S
algorithm. The attributes are similar to the ones used in the
original <code class="docutils literal"><span class="pre">BleuValidator</span></code> implementation in machine_translation.
sampling.</p>
<dl class="attribute">
<dt id="cam.sgnmt.blocks.stream.SourceSwitchController.src_sentence">
<code class="descname">src_sentence</code><a class="headerlink" href="#cam.sgnmt.blocks.stream.SourceSwitchController.src_sentence" title="Permalink to this definition">¶</a></dt>
<dd><p><em>theano.variable</em> &#8211; The Theano variable representing
the source sentence in the
computational graph</p>
</dd></dl>

<dl class="attribute">
<dt id="cam.sgnmt.blocks.stream.SourceSwitchController.beam_search">
<code class="descname">beam_search</code><a class="headerlink" href="#cam.sgnmt.blocks.stream.SourceSwitchController.beam_search" title="Permalink to this definition">¶</a></dt>
<dd><p><em>BeamSearch</em> &#8211; Blocks beam search instance</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.stream.SourceSwitchController.do">
<code class="descname">do</code><span class="sig-paren">(</span><em>which_callback</em>, <em>*args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/stream.html#SourceSwitchController.do"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.stream.SourceSwitchController.do" title="Permalink to this definition">¶</a></dt>
<dd><p>This method is called every n batches. If we have already
seen <code class="docutils literal"><span class="pre">burn_in</span></code> batches, decode part of the dev set and change
the data source switch if necessary.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.stream.SourceSwitchController.process_reward">
<code class="descname">process_reward</code><span class="sig-paren">(</span><em>old_bleu</em>, <em>new_bleu</em>, <em>sec</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/stream.html#SourceSwitchController.process_reward"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.stream.SourceSwitchController.process_reward" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a GoF template method. Subclasses implement their
controlling strategy in this method. Actions can be realized
by using <code class="docutils literal"><span class="pre">self.switch_dataset.set_active_idx</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>old_bleu</strong> (<em>float</em>) &#8211; Achieved bleu before the previous action</li>
<li><strong>new_bleu</strong> (<em>float</em>) &#8211; Achieved bleu after the previous action</li>
<li><strong>sec</strong> (<em>float</em>) &#8211; Time in seconds required for the last action</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="cam.sgnmt.blocks.stream.load_sentences_from_file">
<code class="descclassname">cam.sgnmt.blocks.stream.</code><code class="descname">load_sentences_from_file</code><span class="sig-paren">(</span><em>path</em>, <em>vocab_size</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/stream.html#load_sentences_from_file"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.stream.load_sentences_from_file" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads sentences from a plain text file. For each sentence we add
&lt;/S&gt; (but not &lt;S&gt;) as expected by the data stream pipeline. Tokens
larger than <code class="docutils literal"><span class="pre">vocab_size</span></code> are replaced by the UNK id.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>path</strong> (<em>string</em>) &#8211; Path to the text file</li>
<li><strong>vocab_size</strong> (<em>int</em>) &#8211; Vocabulary size (all tokens larger than
this are replaced by <code class="docutils literal"><span class="pre">utils.UNK_ID</span></code></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first"><dl class="docutils">
<dt>list. List of list of integers representing the indexed</dt>
<dd><p class="first last">sentences in the input file.</p>
</dd>
</dl>
</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><ul class="first last simple">
<li>IOError. If the file could not be read</li>
<li>ValueError. If the text file contains non-integer tokens</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="cam-sgnmt-blocks-train-module">
<h2>cam.sgnmt.blocks.train module<a class="headerlink" href="#cam-sgnmt-blocks-train-module" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-cam.sgnmt.blocks.vanilla_decoder">
<span id="cam-sgnmt-blocks-vanilla-decoder-module"></span><h2>cam.sgnmt.blocks.vanilla_decoder module<a class="headerlink" href="#module-cam.sgnmt.blocks.vanilla_decoder" title="Permalink to this headline">¶</a></h2>
<p>This module bypasses the normal predictor framework and decodes
directly with <code class="docutils literal"><span class="pre">blocks.search.BeamSearch</span></code>. This is the original beam
search implementation in the blocks library, and is much faster than
going through the NMT predictor as it parallelizes expanding the active
hypotheses on the GPU. However, its less flexible because you can only
do pure single NMT decoding.</p>
<dl class="class">
<dt id="cam.sgnmt.blocks.vanilla_decoder.BlocksNMTEnsembleVanillaDecoder">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.vanilla_decoder.</code><code class="descname">BlocksNMTEnsembleVanillaDecoder</code><span class="sig-paren">(</span><em>nmt_specs</em>, <em>decoder_args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/vanilla_decoder.html#BlocksNMTEnsembleVanillaDecoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.vanilla_decoder.BlocksNMTEnsembleVanillaDecoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="cam.sgnmt.decoding.html#cam.sgnmt.decoding.core.Decoder" title="cam.sgnmt.decoding.core.Decoder"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.core.Decoder</span></code></a></p>
<p>Vanilla NMT decoder for examples. This still bypasses the
predictor framework but can handle multiple NMT systems. Note that
this decoder refrains from the vocabulary matching mechanisms used
in the predictor framework in favor of decoding speed. Therefore,
this decoder should be used only with models of the same vocabulary
size.</p>
<dl class="method">
<dt id="cam.sgnmt.blocks.vanilla_decoder.BlocksNMTEnsembleVanillaDecoder.decode">
<code class="descname">decode</code><span class="sig-paren">(</span><em>src_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/vanilla_decoder.html#BlocksNMTEnsembleVanillaDecoder.decode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.vanilla_decoder.BlocksNMTEnsembleVanillaDecoder.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a generalization to NMT ensembles of
<code class="docutils literal"><span class="pre">BeamSearch.search</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>src_sentence</strong> (<em>list</em>) &#8211; List of source word ids without &lt;S&gt; or
&lt;/S&gt; which make up the source sentence</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">list. A list of <code class="docutils literal"><span class="pre">Hypothesis</span></code> instances ordered by their
score.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.vanilla_decoder.BlocksNMTEnsembleVanillaDecoder.has_predictors">
<code class="descname">has_predictors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/vanilla_decoder.html#BlocksNMTEnsembleVanillaDecoder.has_predictors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.vanilla_decoder.BlocksNMTEnsembleVanillaDecoder.has_predictors" title="Permalink to this definition">¶</a></dt>
<dd><p>Always returns true.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.vanilla_decoder.BlocksNMTEnsembleVanillaDecoder.set_up_decoder">
<code class="descname">set_up_decoder</code><span class="sig-paren">(</span><em>nmt_specs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/vanilla_decoder.html#BlocksNMTEnsembleVanillaDecoder.set_up_decoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.vanilla_decoder.BlocksNMTEnsembleVanillaDecoder.set_up_decoder" title="Permalink to this definition">¶</a></dt>
<dd><p>This method sets up a list of NMT models and BeamSearch
instances, one for each model in the ensemble. Note that we do
not use the <code class="docutils literal"><span class="pre">BeamSearch.search</span></code> method for ensemble decoding
directly.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>nmt_model_path</strong> (<em>string</em>) &#8211; Path to the NMT model file (.npz)</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.blocks.vanilla_decoder.BlocksNMTVanillaDecoder">
<em class="property">class </em><code class="descclassname">cam.sgnmt.blocks.vanilla_decoder.</code><code class="descname">BlocksNMTVanillaDecoder</code><span class="sig-paren">(</span><em>nmt_model_path</em>, <em>config</em>, <em>decoder_args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/vanilla_decoder.html#BlocksNMTVanillaDecoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.vanilla_decoder.BlocksNMTVanillaDecoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="cam.sgnmt.decoding.html#cam.sgnmt.decoding.core.Decoder" title="cam.sgnmt.decoding.core.Decoder"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.core.Decoder</span></code></a></p>
<p>Adaptor class for blocks.search.BeamSearch. We implement the
<code class="docutils literal"><span class="pre">Decoder</span></code> class but ignore functionality for predictors or
heuristics. Instead, we pass through decoding directly to the
blocks beam search module. This is fast, but breaks with the
predictor framework. It can only be used for pure single system
NMT decoding. Note that this decoder supports sparse feat maps
on both source and target side.</p>
<dl class="method">
<dt id="cam.sgnmt.blocks.vanilla_decoder.BlocksNMTVanillaDecoder.decode">
<code class="descname">decode</code><span class="sig-paren">(</span><em>src_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/vanilla_decoder.html#BlocksNMTVanillaDecoder.decode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.vanilla_decoder.BlocksNMTVanillaDecoder.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decodes a single source sentence with the original blocks
beam search decoder. Does not use predictors. Note that the
score breakdowns in returned hypotheses are only on the
sentence level, not on the word level. For finer grained NMT
scores you need to use the nmt predictor. <code class="docutils literal"><span class="pre">src_sentence</span></code> is a
list of source word ids representing the source sentence without
&lt;S&gt; or &lt;/S&gt; symbols. As blocks expects to see &lt;/S&gt;, this method
adds it automatically.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>src_sentence</strong> (<em>list</em>) &#8211; List of source word ids without &lt;S&gt; or
&lt;/S&gt; which make up the source sentence</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">list. A list of <code class="docutils literal"><span class="pre">Hypothesis</span></code> instances ordered by their
score.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.vanilla_decoder.BlocksNMTVanillaDecoder.has_predictors">
<code class="descname">has_predictors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/vanilla_decoder.html#BlocksNMTVanillaDecoder.has_predictors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.vanilla_decoder.BlocksNMTVanillaDecoder.has_predictors" title="Permalink to this definition">¶</a></dt>
<dd><p>Always returns true.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.blocks.vanilla_decoder.BlocksNMTVanillaDecoder.set_up_decoder">
<code class="descname">set_up_decoder</code><span class="sig-paren">(</span><em>nmt_model_path</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/blocks/vanilla_decoder.html#BlocksNMTVanillaDecoder.set_up_decoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.blocks.vanilla_decoder.BlocksNMTVanillaDecoder.set_up_decoder" title="Permalink to this definition">¶</a></dt>
<dd><p>This method uses the NMT configuration in <code class="docutils literal"><span class="pre">self.config</span></code> to
initialize the NMT model. This method basically corresponds to
<code class="docutils literal"><span class="pre">blocks.machine_translation.main</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>nmt_model_path</strong> (<em>string</em>) &#8211; Path to the NMT model file (.npz)</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-cam.sgnmt.blocks">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-cam.sgnmt.blocks" title="Permalink to this headline">¶</a></h2>
<p>This module contains all code which depends on the blocks framework.
The only exception of this rule is <code class="docutils literal"><span class="pre">cam.sgnmt.predictors.blocks_nmt</span></code>
The main entry points are <code class="docutils literal"><span class="pre">decode</span></code> and <code class="docutils literal"><span class="pre">train</span></code>, both are scripts
which can be started directly via command line.</p>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="cam.sgnmt.blocks.alignment.html" class="btn btn-neutral float-right" title="cam.sgnmt.blocks.alignment package" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="cam.sgnmt.html" class="btn btn-neutral" title="cam.sgnmt package" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2018, University of Cambridge.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.3.2',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>