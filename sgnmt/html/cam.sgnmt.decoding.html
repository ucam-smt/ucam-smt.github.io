

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>cam.sgnmt.decoding package &mdash; SGNMT 0.1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
    <link rel="top" title="SGNMT 0.1 documentation" href="index.html"/>
        <link rel="up" title="cam.sgnmt package" href="cam.sgnmt.html"/>
        <link rel="next" title="cam.sgnmt.predictors package" href="cam.sgnmt.predictors.html"/>
        <link rel="prev" title="cam.sgnmt.blocks.machine_translation package" href="cam.sgnmt.blocks.machine_translation.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> SGNMT
          

          
          </a>

          
            
            
              <div class="version">
                0.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="setup.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="command_line.html">Command-line reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="predictors.html">Predictors</a></li>
<li class="toctree-l1"><a class="reference internal" href="decoders.html">Decoders</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">Frequently Asked Questions</a></li>
<li class="toctree-l1"><a class="reference internal" href="publications.html">Publications</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="cam.sgnmt.html">All modules</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="cam.sgnmt.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="cam.sgnmt.blocks.html">cam.sgnmt.blocks package</a></li>
<li class="toctree-l3 current"><a class="current reference internal" href="#">cam.sgnmt.decoding package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-cam.sgnmt.decoding.core">cam.sgnmt.decoding.core module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-cam.sgnmt.decoding.decoder">cam.sgnmt.decoding.decoder module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-cam.sgnmt.decoding.heuristics">cam.sgnmt.decoding.heuristics module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-cam.sgnmt.decoding">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="cam.sgnmt.predictors.html">cam.sgnmt.predictors package</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="cam.sgnmt.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="cam.sgnmt.html#module-cam.sgnmt.output">cam.sgnmt.output module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cam.sgnmt.html#module-cam.sgnmt.utils">cam.sgnmt.utils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cam.sgnmt.html#module-cam.sgnmt">Module contents</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">SGNMT</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
          <li><a href="cam.sgnmt.html">cam.sgnmt package</a> &raquo;</li>
      
    <li>cam.sgnmt.decoding package</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/cam.sgnmt.decoding.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="cam-sgnmt-decoding-package">
<h1>cam.sgnmt.decoding package<a class="headerlink" href="#cam-sgnmt-decoding-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-cam.sgnmt.decoding.core">
<span id="cam-sgnmt-decoding-core-module"></span><h2>cam.sgnmt.decoding.core module<a class="headerlink" href="#module-cam.sgnmt.decoding.core" title="Permalink to this headline">¶</a></h2>
<p>Contains all the basic interfaces and abstract classes for decoding.
This is mainly <code class="docutils literal"><span class="pre">Predictor</span></code> and <code class="docutils literal"><span class="pre">Decoder</span></code>. Functionality should be
implemented mainly in the <code class="docutils literal"><span class="pre">predictors</span></code> package for predictors and in
the <code class="docutils literal"><span class="pre">decoding.decoder</span></code> module for decoders.</p>
<dl class="data">
<dt id="cam.sgnmt.decoding.core.CLOSED_VOCAB_SCORE_NORM_EXACT">
<code class="descclassname">cam.sgnmt.decoding.core.</code><code class="descname">CLOSED_VOCAB_SCORE_NORM_EXACT</code><em class="property"> = 2</em><a class="headerlink" href="#cam.sgnmt.decoding.core.CLOSED_VOCAB_SCORE_NORM_EXACT" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Exact</em> &#8211; Normalize by 1 plus the number of words outside the
vocabulary to make it a valid distribution again</p>
</dd></dl>

<dl class="data">
<dt id="cam.sgnmt.decoding.core.CLOSED_VOCAB_SCORE_NORM_NONE">
<code class="descclassname">cam.sgnmt.decoding.core.</code><code class="descname">CLOSED_VOCAB_SCORE_NORM_NONE</code><em class="property"> = 1</em><a class="headerlink" href="#cam.sgnmt.decoding.core.CLOSED_VOCAB_SCORE_NORM_NONE" title="Permalink to this definition">¶</a></dt>
<dd><p><em>None</em> &#8211; Do not apply any normalization.</p>
</dd></dl>

<dl class="data">
<dt id="cam.sgnmt.decoding.core.CLOSED_VOCAB_SCORE_NORM_REDUCED">
<code class="descclassname">cam.sgnmt.decoding.core.</code><code class="descname">CLOSED_VOCAB_SCORE_NORM_REDUCED</code><em class="property"> = 3</em><a class="headerlink" href="#cam.sgnmt.decoding.core.CLOSED_VOCAB_SCORE_NORM_REDUCED" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Reduced</em> &#8211; Always normalize the closed vocabulary scores to the
vocabulary which is defined by the open vocabulary predictors at each
time step.</p>
</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.decoding.core.Decoder">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.core.</code><code class="descname">Decoder</code><span class="sig-paren">(</span><em>closed_vocab_norm=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>A <code class="docutils literal"><span class="pre">Decoder</span></code> instance represents a particular search strategy
such as A*, beam search, greedy search etc. Decisions are made
based on the outputs of one or many predictors, which are
maintained by the <code class="docutils literal"><span class="pre">Decoder</span></code> instance.</p>
<dl class="method">
<dt id="cam.sgnmt.decoding.core.Decoder.add_heuristic">
<code class="descname">add_heuristic</code><span class="sig-paren">(</span><em>heuristic</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder.add_heuristic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder.add_heuristic" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a heuristic to the decoder. For future cost estimates,
the sum of the estimates from all heuristics added so far will
be used. The predictors used in this heuristic have to be set
before via <code class="docutils literal"><span class="pre">set_heuristic_predictors()</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>heuristic</strong> (<a class="reference internal" href="#cam.sgnmt.decoding.core.Heuristic" title="cam.sgnmt.decoding.core.Heuristic"><em>Heuristic</em></a>) &#8211; A heuristic to use for future cost
estimates</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Decoder.add_predictor">
<code class="descname">add_predictor</code><span class="sig-paren">(</span><em>name</em>, <em>predictor</em>, <em>weight=1.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder.add_predictor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder.add_predictor" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a predictor to the decoder. This means that this
predictor is going to be used to predict the next target word
(see <code class="docutils literal"><span class="pre">predict_next</span></code>)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>string</em>) &#8211; Predictor name like &#8216;nmt&#8217; or &#8216;fst&#8217;</li>
<li><strong>predictor</strong> (<a class="reference internal" href="#cam.sgnmt.decoding.core.Predictor" title="cam.sgnmt.decoding.core.Predictor"><em>Predictor</em></a>) &#8211; Predictor instance</li>
<li><strong>weight</strong> (<em>float</em>) &#8211; Predictor weight</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Decoder.apply_predictors">
<code class="descname">apply_predictors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder.apply_predictors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder.apply_predictors" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the distribution over the next word by combining the
predictor scores.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">Two dicts. <code class="docutils literal"><span class="pre">combined</span></code> maps
target word ids to the combined score, <code class="docutils literal"><span class="pre">score_breakdown</span></code>
contains the scores for each predictor separately
represented as tuples (unweighted_score, predictor_weight)</td>
</tr>
<tr class="field-even field"><th class="field-name">Return type:</th><td class="field-body">combined,score_breakdown</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="cam.sgnmt.decoding.core.Decoder.combi_arithmetic_unnormalized">
<em class="property">static </em><code class="descname">combi_arithmetic_unnormalized</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder.combi_arithmetic_unnormalized"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder.combi_arithmetic_unnormalized" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the weighted sum (or geometric mean of log
values). Do not use with empty lists.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> (<em>list</em>) &#8211; List of tuples [(out1, weight1), ...]</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">float. Weighted sum out1*weight1+out2*weight2...</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="staticmethod">
<dt id="cam.sgnmt.decoding.core.Decoder.combi_geometric_unnormalized">
<em class="property">static </em><code class="descname">combi_geometric_unnormalized</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder.combi_geometric_unnormalized"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder.combi_geometric_unnormalized" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the weighted geometric mean. Do not use empty
lists.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> (<em>list</em>) &#8211; List of tuples [(out1, weight1), ...]</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">out1^weight1*out2^weight2...</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">float. Weighted geo. mean</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Decoder.consume">
<code class="descname">consume</code><span class="sig-paren">(</span><em>word</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder.consume"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder.consume" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls <code class="docutils literal"><span class="pre">consume()</span></code> on all predictors.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Decoder.decode">
<code class="descname">decode</code><span class="sig-paren">(</span><em>src_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder.decode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decodes a single source sentence. This method has to be
implemented by subclasses. It contains the core of the
implemented search strategy <code class="docutils literal"><span class="pre">src_sentence</span></code> is a list of
source word ids representing the source sentence without
&lt;S&gt; or &lt;/S&gt; symbols. This method returns a list of hypotheses,
order descending by score such that the first entry is the best
decoding result. Implementations should delegate the scoring of
hypotheses to the predictors via <code class="docutils literal"><span class="pre">apply_predictors()</span></code>, and
organize predictor states with the methods <code class="docutils literal"><span class="pre">consume()</span></code>,
<code class="docutils literal"><span class="pre">get_predictor_states()</span></code> and <code class="docutils literal"><span class="pre">set_predictor_states()</span></code>. In
this way, the decoder is decoupled from the scoring modules.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>src_sentence</strong> (<em>list</em>) &#8211; List of source word ids without &lt;S&gt; or
&lt;/S&gt; which make up the source sentence</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">list. A list of <code class="docutils literal"><span class="pre">Hypothesis</span></code> instances ordered by their
score.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><code class="docutils literal"><span class="pre">NotImplementedError</span></code> &#8211; if the method is not implemented</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Decoder.estimate_future_cost">
<code class="descname">estimate_future_cost</code><span class="sig-paren">(</span><em>hypo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder.estimate_future_cost"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder.estimate_future_cost" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses all heuristics which have been added with
<code class="docutils literal"><span class="pre">add_heuristic</span></code> to estimate the future cost for a given
partial hypothesis. The estimates are used in heuristic based
searches like A*. This function returns the future log <em>cost</em>
(i.e. the lower the better), assuming that the last word in the
partial hypothesis <code class="docutils literal"><span class="pre">hypo</span></code> is consumed next.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>hypo</strong> (<a class="reference internal" href="#cam.sgnmt.decoding.decoder.PartialHypothesis" title="cam.sgnmt.decoding.decoder.PartialHypothesis"><em>PartialHypothesis</em></a>) &#8211; Hypothesis for which to estimate
the future cost given the current
predictor state</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Returns</dt>
<dd>float. Future cost</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Decoder.get_predictor_states">
<code class="descname">get_predictor_states</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder.get_predictor_states"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder.get_predictor_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls <code class="docutils literal"><span class="pre">get_state()</span></code> on all predictors.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Decoder.has_predictors">
<code class="descname">has_predictors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder.has_predictors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder.has_predictors" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if predictors have been added to the decoder.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Decoder.initialize_predictors">
<code class="descname">initialize_predictors</code><span class="sig-paren">(</span><em>src_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder.initialize_predictors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder.initialize_predictors" title="Permalink to this definition">¶</a></dt>
<dd><p>First, increases the sentence id counter and calls
<code class="docutils literal"><span class="pre">initialize()</span></code> on all predictors. Then, <code class="docutils literal"><span class="pre">initialize()</span></code> is
called for all heuristics.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>src_sentence</strong> (<em>list</em>) &#8211; List of source word ids without &lt;S&gt; or
&lt;/S&gt; which make up the source sentence</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Decoder.remove_predictors">
<code class="descname">remove_predictors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder.remove_predictors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder.remove_predictors" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes all predictors of this decoder.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Decoder.reset_predictors">
<code class="descname">reset_predictors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder.reset_predictors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder.reset_predictors" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls <code class="docutils literal"><span class="pre">reset()</span></code> on all predictors and resets the sentence
id counter <code class="docutils literal"><span class="pre">self.current_sen_id</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Decoder.set_heuristic_predictors">
<code class="descname">set_heuristic_predictors</code><span class="sig-paren">(</span><em>heuristic_predictors</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder.set_heuristic_predictors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder.set_heuristic_predictors" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the list of predictors used by heuristics. This needs
to be called before adding heuristics with <code class="docutils literal"><span class="pre">add_heuristic()</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>heuristic_predictors</strong> (<em>list</em>) &#8211; Predictors and their weights
to be used with heuristics.
Should be in the same form
as <code class="docutils literal"><span class="pre">Decoder.predictors</span></code>,
i.e. a list of
(predictor, weight) tuples</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Decoder.set_predictor_combi_method">
<code class="descname">set_predictor_combi_method</code><span class="sig-paren">(</span><em>method</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder.set_predictor_combi_method"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder.set_predictor_combi_method" title="Permalink to this definition">¶</a></dt>
<dd><p>Defines how to accumulate scores over the sequence. Should
be one of the <code class="docutils literal"><span class="pre">combi_</span></code> methods defined below</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>method</strong> (<em>function</em>) &#8211; A function which accepts a list of
tuples [(out1, weight1), ...] and
calculates a combined score, e.g.
one of the <code class="docutils literal"><span class="pre">combi_*</span></code> methods</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Decoder.set_predictor_states">
<code class="descname">set_predictor_states</code><span class="sig-paren">(</span><em>states</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder.set_predictor_states"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder.set_predictor_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls <code class="docutils literal"><span class="pre">set_state()</span></code> on all predictors.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Decoder.set_start_sen_id">
<code class="descname">set_start_sen_id</code><span class="sig-paren">(</span><em>start_sen_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder.set_start_sen_id"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder.set_start_sen_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the internal sentence id counter <cite>self.current_sen_id`</cite>
to <code class="docutils literal"><span class="pre">start_sen_id</span></code> and resets all predictors.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.decoding.core.Heuristic">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.core.</code><code class="descname">Heuristic</code><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Heuristic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Heuristic" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>A <code class="docutils literal"><span class="pre">Heuristic</span></code> instance can be used to estimate the future
costs for a given word in a given state. See the <code class="docutils literal"><span class="pre">heuristics</span></code>
module for implementations.</p>
<dl class="method">
<dt id="cam.sgnmt.decoding.core.Heuristic.estimate_future_cost">
<code class="descname">estimate_future_cost</code><span class="sig-paren">(</span><em>hypo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Heuristic.estimate_future_cost"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Heuristic.estimate_future_cost" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the future cost (i.e. negative score) given the
states of the predictors set by <code class="docutils literal"><span class="pre">set_predictors</span></code> for a
partial hypothesis <code class="docutils literal"><span class="pre">hypo</span></code>. Note that this function is not
supposed to change predictor states. If (e.g. for the greedy
heuristic) this is not possible, the predictor states must be
changed back after execution by the implementing method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>hypo</strong> (<em>PartialHypo</em>) &#8211; Hypothesis for which to estimate the
future cost</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">float. The future cost estimate for this heuristic</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Heuristic.initialize">
<code class="descname">initialize</code><span class="sig-paren">(</span><em>src_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Heuristic.initialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Heuristic.initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the heuristic with the given source sentence.
This is not passed through to the heuristic predictors
automatically but handles initialization outside the
predictors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>src_sentence</strong> (<em>list</em>) &#8211; List of source word ids without &lt;S&gt; or
&lt;/S&gt; which make up the source sentence</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Heuristic.set_predictors">
<code class="descname">set_predictors</code><span class="sig-paren">(</span><em>predictors</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Heuristic.set_predictors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Heuristic.set_predictors" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the predictors used by this heuristic.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>predictors</strong> (<em>list</em>) &#8211; Predictors and their weights to be
used with this heuristic. Should be in
the same form as <code class="docutils literal"><span class="pre">Decoder.predictors</span></code>,
i.e. a list of (predictor, weight)
tuples</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="data">
<dt id="cam.sgnmt.decoding.core.NEG_INF">
<code class="descclassname">cam.sgnmt.decoding.core.</code><code class="descname">NEG_INF</code><em class="property"> = -inf</em><a class="headerlink" href="#cam.sgnmt.decoding.core.NEG_INF" title="Permalink to this definition">¶</a></dt>
<dd><p>The <code class="docutils literal"><span class="pre">CLOSED_VOCAB_SCORE_NORM_*</span></code> constants define the normalization
behavior for closed vocabulary predictor scores. Closed vocabulary
predictors (e.g. NMT) have a predefined (and normally very limited)
vocabulary. In contrast, open vocabulary predictors (see
<code class="docutils literal"><span class="pre">UnboundedPredictor</span></code>) are defined over a much larger vocabulary
(e.g. FST) s.t. it is easier to consider them as having an open
vocabulary. When combining open and closed vocabulary predictors, we use
the UNK probability of closed vocabulary predictors for words outside
their vocabulary. The following flags decide (as argument to
<code class="docutils literal"><span class="pre">Decoder</span></code>) what to do with the closed vocabulary predictor scores
when combining them with open vocabulary predictors in that way. This
can be changed with the &#8211;closed_vocab_norm argument</p>
</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.decoding.core.Predictor">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.core.</code><code class="descname">Predictor</code><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Predictor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Predictor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>A predictor produces the predictive probability distribution of
the next word given the state of the predictor. The state may
change during <code class="docutils literal"><span class="pre">predict_next()</span></code> and <code class="docutils literal"><span class="pre">consume()</span></code>. The functions
<code class="docutils literal"><span class="pre">get_state()</span></code> and <code class="docutils literal"><span class="pre">set_state()</span></code> can be used for non-greedy
decoding. Note: The state describes the predictor with the current
history. It does not encapsulate the current source sentence, i.e.
you cannot recover a predictor state if <code class="docutils literal"><span class="pre">initialize()</span></code> was called
in between. <code class="docutils literal"><span class="pre">predict_next()</span></code> and <code class="docutils literal"><span class="pre">consume()</span></code> must be called
alternately. This holds even when using <code class="docutils literal"><span class="pre">get_state()</span></code> and
<code class="docutils literal"><span class="pre">set_state()</span></code>: Loading/saving states is transparent to the
predictor instance.</p>
<dl class="method">
<dt id="cam.sgnmt.decoding.core.Predictor.consume">
<code class="descname">consume</code><span class="sig-paren">(</span><em>word</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Predictor.consume"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Predictor.consume" title="Permalink to this definition">¶</a></dt>
<dd><p>Expand the current history by <code class="docutils literal"><span class="pre">word</span></code> and update the
internal predictor state accordingly. Two calls of <code class="docutils literal"><span class="pre">consume()</span></code>
must be separated by a <code class="docutils literal"><span class="pre">predict_next()</span></code> call.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>word</strong> (<em>int</em>) &#8211; Word to add to the current history</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Predictor.estimate_future_cost">
<code class="descname">estimate_future_cost</code><span class="sig-paren">(</span><em>hypo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Predictor.estimate_future_cost"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Predictor.estimate_future_cost" title="Permalink to this definition">¶</a></dt>
<dd><p>Predictors can implement their own look-ahead cost functions.
They are used in A* if the &#8211;heuristics parameter is set to
predictor. This function should return the future log <em>cost</em>
(i.e. the lower the better) given the current predictor state,
assuming that the last word in the partial hypothesis &#8216;hypo&#8217; is
consumed next. This function must not change the internal
predictor state.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>hypo</strong> (<a class="reference internal" href="#cam.sgnmt.decoding.decoder.PartialHypothesis" title="cam.sgnmt.decoding.decoder.PartialHypothesis"><em>PartialHypothesis</em></a>) &#8211; Hypothesis for which to estimate
the future cost given the current
predictor state</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Returns</dt>
<dd>float. Future cost</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Predictor.finalize_posterior">
<code class="descname">finalize_posterior</code><span class="sig-paren">(</span><em>scores</em>, <em>use_weights</em>, <em>normalize_scores</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Predictor.finalize_posterior"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Predictor.finalize_posterior" title="Permalink to this definition">¶</a></dt>
<dd><p>This method can be used to enforce the parameters use_weights
normalize_scores in predictors with dict posteriors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>scores</strong> (<em>dict</em>) &#8211; unnormalized log valued scores</li>
<li><strong>use_weights</strong> (<em>bool</em>) &#8211; Set to false to replace all values in
<code class="docutils literal"><span class="pre">scores</span></code> with 0 (= log 1)</li>
<li><strong>normalize_scores</strong> &#8211; Set to true to make the exp of elements
in <code class="docutils literal"><span class="pre">scores</span></code> sum up to 1</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Predictor.get_state">
<code class="descname">get_state</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Predictor.get_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Predictor.get_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the current predictor state. The state can be any object
or tuple of objects which makes it possible to return to the
predictor state with the current history.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">object. Predictor state</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Predictor.get_unk_probability">
<code class="descname">get_unk_probability</code><span class="sig-paren">(</span><em>posterior</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Predictor.get_unk_probability"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Predictor.get_unk_probability" title="Permalink to this definition">¶</a></dt>
<dd><p>This function defines the probability of all words which are
not in <code class="docutils literal"><span class="pre">posterior</span></code>. This is usually used to combine open and
closed vocabulary predictors. The argument <code class="docutils literal"><span class="pre">posterior</span></code> should
have been produced with <code class="docutils literal"><span class="pre">predict_next()</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>posterior</strong> (<em>list,array,dict</em>) &#8211; Return value of the last call
of <code class="docutils literal"><span class="pre">predict_next</span></code></td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Score to use for words outside <code class="docutils literal"><span class="pre">posterior</span></code></td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">float</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Predictor.initialize">
<code class="descname">initialize</code><span class="sig-paren">(</span><em>src_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Predictor.initialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Predictor.initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the predictor with the given source sentence.
This resets the internal predictor state and loads everything
which is constant throughout the processing of a single source
sentence. For example, the NMT decoder runs the encoder network
and stores the source annotations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>src_sentence</strong> (<em>list</em>) &#8211; List of word IDs which form the source
sentence without &lt;S&gt; or &lt;/S&gt;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Predictor.initialize_heuristic">
<code class="descname">initialize_heuristic</code><span class="sig-paren">(</span><em>src_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Predictor.initialize_heuristic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Predictor.initialize_heuristic" title="Permalink to this definition">¶</a></dt>
<dd><p>This is called after <code class="docutils literal"><span class="pre">initialize()</span></code> if the predictor is
registered as heuristic predictor (i.e.
<code class="docutils literal"><span class="pre">estimate_future_cost()</span></code> will be called in the future).
Predictors can implement this function for initialization of
their own heuristic mechanisms.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>src_sentence</strong> (<em>list</em>) &#8211; List of word IDs which form the source
sentence without &lt;S&gt; or &lt;/S&gt;</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Predictor.predict_next">
<code class="descname">predict_next</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Predictor.predict_next"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Predictor.predict_next" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the predictive distribution over the target
vocabulary for the next word given the predictor state. Note
that the prediction itself can change the state of the
predictor. For example, the neural predictor updates the
decoder network state and its attention to predict the next
word. Two calls of <code class="docutils literal"><span class="pre">predict_next()</span></code> must be separated by a
<code class="docutils literal"><span class="pre">consume()</span></code> call.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">dictionary,array,list. Word log probabilities for the next
target token. All ids which are not set are assumed to have
probability <code class="docutils literal"><span class="pre">get_unk_probability()</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Predictor.reset">
<code class="descname">reset</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Predictor.reset"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Predictor.reset" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset the predictor state to the initial configuration. This
is required when a new set of sentences is to be decoded, e.g.
to reset the sentence counter in the fst predictor to load the
correct lattice. This function is NOT called each time before
decoding a single sentence. See <code class="docutils literal"><span class="pre">initialize()</span></code> for this.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Predictor.set_current_sen_id">
<code class="descname">set_current_sen_id</code><span class="sig-paren">(</span><em>cur_sen_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Predictor.set_current_sen_id"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Predictor.set_current_sen_id" title="Permalink to this definition">¶</a></dt>
<dd><p>This function is called between <code class="docutils literal"><span class="pre">initialize()</span></code> calls to
increment the sentence id counter. It can also be used to skip
sentences for the &#8211;range argument.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>cur_sen_id</strong> (<em>int</em>) &#8211; Sentence id for the next call of
<code class="docutils literal"><span class="pre">initialize()</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Predictor.set_state">
<code class="descname">set_state</code><span class="sig-paren">(</span><em>state</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Predictor.set_state"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Predictor.set_state" title="Permalink to this definition">¶</a></dt>
<dd><p>Loads a predictor state from an object created with
<code class="docutils literal"><span class="pre">get_state()</span></code>. Note that this does not copy the argument but
just references the given state. If <code class="docutils literal"><span class="pre">state</span></code> is going to be
used in the future to return to that point again, you should
copy the state with <code class="docutils literal"><span class="pre">copy.deepcopy()</span></code> before.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>state</strong> (<em>object</em>) &#8211; Predictor state as returned by
<code class="docutils literal"><span class="pre">get_state()</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.decoding.core.UnboundedVocabularyPredictor">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.core.</code><code class="descname">UnboundedVocabularyPredictor</code><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#UnboundedVocabularyPredictor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.UnboundedVocabularyPredictor" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.core.Predictor" title="cam.sgnmt.decoding.core.Predictor"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.core.Predictor</span></code></a></p>
<p>Predictors under this class implement models with very large
target vocabularies, for which it is too inefficient to list the
entire posterior. Instead, they are evaluated only for a given list
of target words. This list is usually created by taking all non-zero
probability words from the bounded vocabulary predictors. An
example of a unbounded vocabulary predictor is the ngram predictor:
Instead of listing the entire ngram vocabulary, we run srilm only
on the words which are possible according other predictor (e.g. fst
or nmt). This is realized by introducing the <code class="docutils literal"><span class="pre">trgt_words</span></code>
argument to <code class="docutils literal"><span class="pre">predict_next</span></code>.</p>
<dl class="method">
<dt id="cam.sgnmt.decoding.core.UnboundedVocabularyPredictor.predict_next">
<code class="descname">predict_next</code><span class="sig-paren">(</span><em>trgt_words</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#UnboundedVocabularyPredictor.predict_next"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.UnboundedVocabularyPredictor.predict_next" title="Permalink to this definition">¶</a></dt>
<dd><p>Like in <code class="docutils literal"><span class="pre">Predictor</span></code>, returns the predictive distribution
over target words given the predictor state. Note
that the prediction itself can change the state of the
predictor. For example, the neural predictor updates the
decoder network state and its attention to predict the next
word. Two calls of <code class="docutils literal"><span class="pre">predict_next()</span></code> must be separated by a
<code class="docutils literal"><span class="pre">consume()</span></code> call.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>trgt_words</strong> (<em>list</em>) &#8211; List of target word ids.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">dictionary,array,list. Word log probabilities for the next
target token. All ids which are not set are assumed to have
probability <code class="docutils literal"><span class="pre">get_unk_probability().</span> <span class="pre">The</span> <span class="pre">returned</span> <span class="pre">set</span> <span class="pre">should</span>
<span class="pre">not</span> <span class="pre">contain</span> <span class="pre">any</span> <span class="pre">ids</span> <span class="pre">which</span> <span class="pre">are</span> <span class="pre">not</span> <span class="pre">in</span> <span class="pre">``trgt_words</span></code>, but it
does not have to score all of them</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="cam.sgnmt.decoding.core.breakdown2score_bayesian">
<code class="descclassname">cam.sgnmt.decoding.core.</code><code class="descname">breakdown2score_bayesian</code><span class="sig-paren">(</span><em>working_score</em>, <em>score_breakdown</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#breakdown2score_bayesian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.breakdown2score_bayesian" title="Permalink to this definition">¶</a></dt>
<dd><p>This realizes score combination following the Bayesian LM
interpolation scheme from (Allauzen and Riley, 2011)</p>
<blockquote>
<div>Bayesian Language Model Interpolation for Mobile Speech Input</div></blockquote>
<p>By setting K=T we define the predictor weights according the score
the predictors give to the current partial hypothesis. The initial
predictor weights are used as priors. This function is designed to
be assigned to the globals <code class="docutils literal"><span class="pre">breakdown2score_partial</span></code> or
<code class="docutils literal"><span class="pre">breakdown2score_full</span></code>.
TODO could make more efficient use of <code class="docutils literal"><span class="pre">working_score</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>working_score</strong> (<em>float</em>) &#8211; Working combined score, which is the
weighted sum of the scores in
<code class="docutils literal"><span class="pre">score_breakdown</span></code>. Not used.</li>
<li><strong>score_breakdown</strong> (<em>list</em>) &#8211; Breakdown of the combined score into
predictor scores</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">float. Bayesian interpolated predictor scores</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="cam.sgnmt.decoding.core.breakdown2score_full">
<code class="descclassname">cam.sgnmt.decoding.core.</code><code class="descname">breakdown2score_full</code><span class="sig-paren">(</span><em>working_score</em>, <em>score_breakdown</em><span class="sig-paren">)</span><a class="headerlink" href="#cam.sgnmt.decoding.core.breakdown2score_full" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the combination scheme &#8216;sum&#8217; by always returning
<code class="docutils literal"><span class="pre">working_score</span></code>. This function is designed to be assigned to
the globals <code class="docutils literal"><span class="pre">breakdown2score_partial</span></code> or <code class="docutils literal"><span class="pre">breakdown2score_full</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>working_score</strong> (<em>float</em>) &#8211; Working combined score, which is the
weighted sum of the scores in
<code class="docutils literal"><span class="pre">score_breakdown</span></code></li>
<li><strong>score_breakdown</strong> (<em>list</em>) &#8211; Breakdown of the combined score into
predictor scores</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">float. Returns <code class="docutils literal"><span class="pre">working_score</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="cam.sgnmt.decoding.core.breakdown2score_length_norm">
<code class="descclassname">cam.sgnmt.decoding.core.</code><code class="descname">breakdown2score_length_norm</code><span class="sig-paren">(</span><em>working_score</em>, <em>score_breakdown</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#breakdown2score_length_norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.breakdown2score_length_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the combination scheme &#8216;length_norm&#8217; by normalizing
the sum of the predictor scores by the length of the current
sequence (i.e. the length of <code class="docutils literal"><span class="pre">score_breakdown</span></code>. This function is
designed to be assigned to the globals <code class="docutils literal"><span class="pre">breakdown2score_partial</span></code>
or <code class="docutils literal"><span class="pre">breakdown2score_full</span></code>.
TODO could make more efficient use of <code class="docutils literal"><span class="pre">working_score</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>working_score</strong> (<em>float</em>) &#8211; Working combined score, which is the
weighted sum of the scores in
<code class="docutils literal"><span class="pre">score_breakdown</span></code>. Not used.</li>
<li><strong>score_breakdown</strong> (<em>list</em>) &#8211; Breakdown of the combined score into
predictor scores</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">float. Returns a length normalized <code class="docutils literal"><span class="pre">working_score</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="cam.sgnmt.decoding.core.breakdown2score_partial">
<code class="descclassname">cam.sgnmt.decoding.core.</code><code class="descname">breakdown2score_partial</code><span class="sig-paren">(</span><em>working_score</em>, <em>score_breakdown</em><span class="sig-paren">)</span><a class="headerlink" href="#cam.sgnmt.decoding.core.breakdown2score_partial" title="Permalink to this definition">¶</a></dt>
<dd><p>The function breakdown2score_full is called at each creation of a
full hypothesis, i.e. only once per hypothesis</p>
</dd></dl>

<dl class="function">
<dt id="cam.sgnmt.decoding.core.breakdown2score_sum">
<code class="descclassname">cam.sgnmt.decoding.core.</code><code class="descname">breakdown2score_sum</code><span class="sig-paren">(</span><em>working_score</em>, <em>score_breakdown</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#breakdown2score_sum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.breakdown2score_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the combination scheme &#8216;sum&#8217; by always returning
<code class="docutils literal"><span class="pre">working_score</span></code>. This function is designed to be assigned to
the globals <code class="docutils literal"><span class="pre">breakdown2score_partial</span></code> or <code class="docutils literal"><span class="pre">breakdown2score_full</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>working_score</strong> (<em>float</em>) &#8211; Working combined score, which is the
weighted sum of the scores in
<code class="docutils literal"><span class="pre">score_breakdown</span></code></li>
<li><strong>score_breakdown</strong> (<em>list</em>) &#8211; Breakdown of the combined score into
predictor scores</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">float. Returns <code class="docutils literal"><span class="pre">working_score</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-cam.sgnmt.decoding.decoder">
<span id="cam-sgnmt-decoding-decoder-module"></span><h2>cam.sgnmt.decoding.decoder module<a class="headerlink" href="#module-cam.sgnmt.decoding.decoder" title="Permalink to this headline">¶</a></h2>
<p>This module contains high level decoder algorithms such as greedy,
A*, beam search, or depth first search schemes. Note that all decoders
are implemented in a monotonic left-to-right way which works well in
the predictors paradigm. If we use features which do not have natural
left-to-right semantics, we</p>
<ul class="simple">
<li>Restrict it to a accept/not-accept decision or</li>
<li>Change it s.t. it does have left-to-right semantics</li>
</ul>
<p>For example, to use synchronous grammars, we could</p>
<ul class="simple">
<li>Keep track of all parse trees which match the partial prefix
sequence</li>
<li>Transform the grammar into Greibach normal form</li>
</ul>
<p>The reason for this design decision is the emphasis on NMT: The neural
decoder decodes the sequence from left to right, all other features
(i.e. predictors) are conceptually rather guiding the neural decoding.</p>
<dl class="class">
<dt id="cam.sgnmt.decoding.decoder.AstarDecoder">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.decoder.</code><code class="descname">AstarDecoder</code><span class="sig-paren">(</span><em>closed_vocab_norm</em>, <em>capacity=0</em>, <em>nbest=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/decoder.html#AstarDecoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.decoder.AstarDecoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.core.Decoder" title="cam.sgnmt.decoding.core.Decoder"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.core.Decoder</span></code></a></p>
<p>This decoder implements A*. For heuristics, see the the
<code class="docutils literal"><span class="pre">decoding.core</span></code> module for interfaces and the general handling of
heuristics, and the <code class="docutils literal"><span class="pre">decoding.heuristics</span></code> package for heuristic
implementations. This A* implementation does not have a &#8216;closed
set&#8217;, i.e. we do not keep track of already visited states. Make
sure that your search space is acyclic (normally it is unless you
decode on cyclic lattices with the fst predictor.</p>
<dl class="method">
<dt id="cam.sgnmt.decoding.decoder.AstarDecoder.decode">
<code class="descname">decode</code><span class="sig-paren">(</span><em>src_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/decoder.html#AstarDecoder.decode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.decoder.AstarDecoder.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decodes a single source sentence using A* search.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.decoding.decoder.BeamDecoder">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.decoder.</code><code class="descname">BeamDecoder</code><span class="sig-paren">(</span><em>closed_vocab_norm</em>, <em>beam_size</em>, <em>early_stopping=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/decoder.html#BeamDecoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.decoder.BeamDecoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.core.Decoder" title="cam.sgnmt.decoding.core.Decoder"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.core.Decoder</span></code></a></p>
<p>This decoder implements beam search without heuristics.</p>
<dl class="method">
<dt id="cam.sgnmt.decoding.decoder.BeamDecoder.decode">
<code class="descname">decode</code><span class="sig-paren">(</span><em>src_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/decoder.html#BeamDecoder.decode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.decoder.BeamDecoder.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decodes a single source sentence using beam search.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.decoding.decoder.DFSDecoder">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.decoder.</code><code class="descname">DFSDecoder</code><span class="sig-paren">(</span><em>closed_vocab_norm</em>, <em>early_stopping=True</em>, <em>max_expansions=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/decoder.html#DFSDecoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.decoder.DFSDecoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.core.Decoder" title="cam.sgnmt.decoding.core.Decoder"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.core.Decoder</span></code></a></p>
<p>This decoder implements depth first search without using
heuristics. This is the most efficient search algorithm for
complete enumeration of the search space as it minimizes the
number of <code class="docutils literal"><span class="pre">get_state()</span></code> and <code class="docutils literal"><span class="pre">set_state()</span></code> calls. Note that
this DFS implementation has no cycle detection, i.e. if the search
space has cycles this decoder may run into an infinite loop.</p>
<dl class="method">
<dt id="cam.sgnmt.decoding.decoder.DFSDecoder.decode">
<code class="descname">decode</code><span class="sig-paren">(</span><em>src_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/decoder.html#DFSDecoder.decode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.decoder.DFSDecoder.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decodes a single source sentence using depth first search.
If <code class="docutils literal"><span class="pre">max_expansions</span></code> equals 0, this corresponds to exhaustive
search for the globally best scoring hypothesis. Note that with
<code class="docutils literal"><span class="pre">early_stopping</span></code> enabled, the returned set of hypothesis are
not necessarily the global n-best hypotheses. To create an
exact n-best list, disable both <code class="docutils literal"><span class="pre">max_expansions</span></code> and
<code class="docutils literal"><span class="pre">early_stopping</span></code> in the constructor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>src_sentence</strong> (<em>list</em>) &#8211; List of source word ids without &lt;S&gt; or
&lt;/S&gt; which make up the source sentence</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">list. A list of <code class="docutils literal"><span class="pre">Hypothesis</span></code> instances ordered by their
score. If <code class="docutils literal"><span class="pre">max_expansions</span></code> equals 0, the first element
holds the global best scoring hypothesis</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.decoding.decoder.GreedyDecoder">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.decoder.</code><code class="descname">GreedyDecoder</code><span class="sig-paren">(</span><em>closed_vocab_norm</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/decoder.html#GreedyDecoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.decoder.GreedyDecoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.core.Decoder" title="cam.sgnmt.decoding.core.Decoder"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.core.Decoder</span></code></a></p>
<p>The greedy decoder does not revise decisions and therefore does
not have to maintain predictor states. Therefore, this
implementation is particularly simple and can be used as template
for more complex decoders. The greedy decoder can be imitated with
the <code class="docutils literal"><span class="pre">BeamDecoder</span></code> with beam size 1.</p>
<dl class="method">
<dt id="cam.sgnmt.decoding.decoder.GreedyDecoder.decode">
<code class="descname">decode</code><span class="sig-paren">(</span><em>src_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/decoder.html#GreedyDecoder.decode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.decoder.GreedyDecoder.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode a single source sentence in a greedy way: Always take
the highest scoring word as next word and proceed to the next
position. This makes it possible to decode without using the
predictors <code class="docutils literal"><span class="pre">get_state()</span></code> and <code class="docutils literal"><span class="pre">set_state()</span></code> methods as we
do not have to keep track of predictor states.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>src_sentence</strong> (<em>list</em>) &#8211; List of source word ids without &lt;S&gt; or
&lt;/S&gt; which make up the source sentence</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">list. A list of a single best <code class="docutils literal"><span class="pre">Hypothesis</span></code> instance.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.decoding.decoder.Hypothesis">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.decoder.</code><code class="descname">Hypothesis</code><span class="sig-paren">(</span><em>trgt_sentence</em>, <em>total_score</em>, <em>score_breakdown=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/decoder.html#Hypothesis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.decoder.Hypothesis" title="Permalink to this definition">¶</a></dt>
<dd><p>Complete translation hypotheses are represented by an instance
of this class. We store the produced sentence, the combined score,
and a score breakdown to the separate predictor scores.</p>
</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.decoding.decoder.PartialHypothesis">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.decoder.</code><code class="descname">PartialHypothesis</code><span class="sig-paren">(</span><em>initial_states=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/decoder.html#PartialHypothesis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.decoder.PartialHypothesis" title="Permalink to this definition">¶</a></dt>
<dd><p>Represents a partial hypothesis in various decoders.</p>
<dl class="method">
<dt id="cam.sgnmt.decoding.decoder.PartialHypothesis.add_score_breakdown">
<code class="descname">add_score_breakdown</code><span class="sig-paren">(</span><em>added_scores</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/decoder.html#PartialHypothesis.add_score_breakdown"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.decoder.PartialHypothesis.add_score_breakdown" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for adding the word level score breakdowns
for the newly added word to the hypothesis score breakdown.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.decoder.PartialHypothesis.cheap_expand">
<code class="descname">cheap_expand</code><span class="sig-paren">(</span><em>word</em>, <em>score</em>, <em>score_breakdown</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/decoder.html#PartialHypothesis.cheap_expand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.decoder.PartialHypothesis.cheap_expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new partial hypothesis adding a new word to the
translation prefix with given probability. Does NOT update the
predictor states but adds a flag which signals that the last
word in this hypothesis has not been consumed yet by the
predictors. This can save memory because we can reuse the
current state for many hypothesis. It also saves computation
as we do not consume words which are then discarded anyway by
the search procedure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>word</strong> (<em>int</em>) &#8211; New word to add to the translation prefix</li>
<li><strong>score</strong> (<em>float</em>) &#8211; Word log probability which is to be added
to the total hypothesis score</li>
<li><strong>score_breakdown</strong> (<em>list</em>) &#8211; Predictor score breakdown for
the new word</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.decoder.PartialHypothesis.expand">
<code class="descname">expand</code><span class="sig-paren">(</span><em>word</em>, <em>new_states</em>, <em>score</em>, <em>score_breakdown</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/decoder.html#PartialHypothesis.expand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.decoder.PartialHypothesis.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new partial hypothesis adding a new word to the
translation prefix with given probability and updates the
stored predictor states.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>word</strong> (<em>int</em>) &#8211; New word to add to the translation prefix</li>
<li><strong>new_states</strong> (<em>object</em>) &#8211; Predictor states after consuming
<code class="docutils literal"><span class="pre">word</span></code></li>
<li><strong>score</strong> (<em>float</em>) &#8211; Word log probability which is to be added
to the total hypothesis score</li>
<li><strong>score_breakdown</strong> (<em>list</em>) &#8211; Predictor score breakdown for
the new word</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.decoder.PartialHypothesis.generate_full_hypothesis">
<code class="descname">generate_full_hypothesis</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/decoder.html#PartialHypothesis.generate_full_hypothesis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.decoder.PartialHypothesis.generate_full_hypothesis" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a <code class="docutils literal"><span class="pre">Hypothesis</span></code> instance from this hypothesis.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.decoder.PartialHypothesis.get_last_word">
<code class="descname">get_last_word</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/decoder.html#PartialHypothesis.get_last_word"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.decoder.PartialHypothesis.get_last_word" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the last word in the translation prefix.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.decoding.decoder.RestartingChild">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.decoder.</code><code class="descname">RestartingChild</code><span class="sig-paren">(</span><em>word</em>, <em>score</em>, <em>score_breakdown</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/decoder.html#RestartingChild"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.decoder.RestartingChild" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Helper class for <code class="docutils literal"><span class="pre">RestartingDecoder`</span></code> representing a child
object in the search tree.</p>
</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.decoding.decoder.RestartingDecoder">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.decoder.</code><code class="descname">RestartingDecoder</code><span class="sig-paren">(</span><em>closed_vocab_norm</em>, <em>max_expansions=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/decoder.html#RestartingDecoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.decoder.RestartingDecoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.core.Decoder" title="cam.sgnmt.decoding.core.Decoder"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.core.Decoder</span></code></a></p>
<p>This decoder first creates a path to the final node greedily.
Then, it looks for the node on this path with the smallest
difference between best and second best child, and restarts greedy
decoding from this point. In order to do so, it maintains a
priority queue of all visited nodes, which is ordered by the
difference between the worst expanded child and the best unexpanded
one. If this queue is empty, we have visited the best path. This
algorithm is similar to DFS but does not backtrace to the last call
of the recursive function but to the one which is most promising.</p>
<p>Note that this algorithm is exact. It tries to exploit the problem
characteristics of NMT search: Reloading predictor states can be
expensive, node expansion is even more expensive but for free from
visited nodes, and there is no good admissible heuristic.</p>
<p>Note2: Does not work properly if predictor scores can be positive
because of admissible pruning</p>
<dl class="method">
<dt id="cam.sgnmt.decoding.decoder.RestartingDecoder.create_initial_node">
<code class="descname">create_initial_node</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/decoder.html#RestartingDecoder.create_initial_node"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.decoder.RestartingDecoder.create_initial_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the root node for the search tree.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.decoder.RestartingDecoder.decode">
<code class="descname">decode</code><span class="sig-paren">(</span><em>src_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/decoder.html#RestartingDecoder.decode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.decoder.RestartingDecoder.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decodes a single source sentence using Restarting search.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.decoder.RestartingDecoder.greedy_decode">
<code class="descname">greedy_decode</code><span class="sig-paren">(</span><em>hypo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/decoder.html#RestartingDecoder.greedy_decode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.decoder.RestartingDecoder.greedy_decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for greedy decoding from a certain point in
the search tree.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.decoding.decoder.RestartingNode">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.decoder.</code><code class="descname">RestartingNode</code><span class="sig-paren">(</span><em>hypo</em>, <em>children</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/decoder.html#RestartingNode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.decoder.RestartingNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Helper class for <code class="docutils literal"><span class="pre">RestartingDecoder`</span></code> representing a node
in the search tree.</p>
</dd></dl>

</div>
<div class="section" id="module-cam.sgnmt.decoding.heuristics">
<span id="cam-sgnmt-decoding-heuristics-module"></span><h2>cam.sgnmt.decoding.heuristics module<a class="headerlink" href="#module-cam.sgnmt.decoding.heuristics" title="Permalink to this headline">¶</a></h2>
<p>Heuristics are used during A* decoding and are called to compose the
estimated look ahead costs. The <code class="docutils literal"><span class="pre">Heuristic</span></code> super class is defined
in the <code class="docutils literal"><span class="pre">core</span></code> module.</p>
<dl class="class">
<dt id="cam.sgnmt.decoding.heuristics.GreedyHeuristic">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.heuristics.</code><code class="descname">GreedyHeuristic</code><span class="sig-paren">(</span><em>closed_vocab_norm</em>, <em>cache_estimates=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/heuristics.html#GreedyHeuristic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.heuristics.GreedyHeuristic" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.core.Heuristic" title="cam.sgnmt.decoding.core.Heuristic"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.core.Heuristic</span></code></a></p>
<p>This heuristic performs greedy decoding to get future cost
estimates. This is expensive but can lead to very close estimates.</p>
<dl class="method">
<dt id="cam.sgnmt.decoding.heuristics.GreedyHeuristic.estimate_future_cost">
<code class="descname">estimate_future_cost</code><span class="sig-paren">(</span><em>hypo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/heuristics.html#GreedyHeuristic.estimate_future_cost"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.heuristics.GreedyHeuristic.estimate_future_cost" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the future cost by full greedy decoding. If
<code class="docutils literal"><span class="pre">self.cache_estimates</span></code> is enabled, check cache first</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.heuristics.GreedyHeuristic.estimate_future_cost_with_cache">
<code class="descname">estimate_future_cost_with_cache</code><span class="sig-paren">(</span><em>hypo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/heuristics.html#GreedyHeuristic.estimate_future_cost_with_cache"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.heuristics.GreedyHeuristic.estimate_future_cost_with_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Enabled cache...</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.heuristics.GreedyHeuristic.estimate_future_cost_without_cache">
<code class="descname">estimate_future_cost_without_cache</code><span class="sig-paren">(</span><em>hypo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/heuristics.html#GreedyHeuristic.estimate_future_cost_without_cache"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.heuristics.GreedyHeuristic.estimate_future_cost_without_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Disabled cache...</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.heuristics.GreedyHeuristic.initialize">
<code class="descname">initialize</code><span class="sig-paren">(</span><em>src_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/heuristics.html#GreedyHeuristic.initialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.heuristics.GreedyHeuristic.initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the cache.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.heuristics.GreedyHeuristic.set_predictors">
<code class="descname">set_predictors</code><span class="sig-paren">(</span><em>predictors</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/heuristics.html#GreedyHeuristic.set_predictors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.heuristics.GreedyHeuristic.set_predictors" title="Permalink to this definition">¶</a></dt>
<dd><p>Override <code class="docutils literal"><span class="pre">Decoder.set_predictors</span></code> to redirect the
predictors to <code class="docutils literal"><span class="pre">self.decoder</span></code></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.decoding.heuristics.PredictorHeuristic">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.heuristics.</code><code class="descname">PredictorHeuristic</code><a class="reference internal" href="_modules/cam/sgnmt/decoding/heuristics.html#PredictorHeuristic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.heuristics.PredictorHeuristic" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.core.Heuristic" title="cam.sgnmt.decoding.core.Heuristic"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.core.Heuristic</span></code></a></p>
<p>The predictor heuristic relies on the
<code class="docutils literal"><span class="pre">estimate_future_costs()</span></code> implementation of the predictors. Use
this heuristic to access predictor specific future cost functions,
e.g. shortest path for the fst predictor.</p>
<dl class="method">
<dt id="cam.sgnmt.decoding.heuristics.PredictorHeuristic.estimate_future_cost">
<code class="descname">estimate_future_cost</code><span class="sig-paren">(</span><em>hypo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/heuristics.html#PredictorHeuristic.estimate_future_cost"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.heuristics.PredictorHeuristic.estimate_future_cost" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the weighted sum of predictor estimates.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.heuristics.PredictorHeuristic.initialize">
<code class="descname">initialize</code><span class="sig-paren">(</span><em>src_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/heuristics.html#PredictorHeuristic.initialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.heuristics.PredictorHeuristic.initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls <code class="docutils literal"><span class="pre">initialize_heuristic()</span></code> on all predictors.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.decoding.heuristics.ScorePerWordHeuristic">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.heuristics.</code><code class="descname">ScorePerWordHeuristic</code><a class="reference internal" href="_modules/cam/sgnmt/decoding/heuristics.html#ScorePerWordHeuristic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.heuristics.ScorePerWordHeuristic" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.core.Heuristic" title="cam.sgnmt.decoding.core.Heuristic"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.core.Heuristic</span></code></a></p>
<p>Using this heuristic results in length normalized scores instead
of the pure sum of predictor scores for a partial hypothesis.
Therefore, it is not a heuristic like in the classical A* sense.
Instead, using the A* decoder with this heuristic simulates beam
search which always keeps the hypotheses with the best per word
scores.</p>
<dl class="method">
<dt id="cam.sgnmt.decoding.heuristics.ScorePerWordHeuristic.estimate_future_cost">
<code class="descname">estimate_future_cost</code><span class="sig-paren">(</span><em>hypo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/heuristics.html#ScorePerWordHeuristic.estimate_future_cost"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.heuristics.ScorePerWordHeuristic.estimate_future_cost" title="Permalink to this definition">¶</a></dt>
<dd><p>A* will put <code class="docutils literal"><span class="pre">cost-score</span></code> on the heap. In order to simulate
length normalized beam search, we want to use <code class="docutils literal"><span class="pre">-score/length</span></code>
as partial hypothesis score. Therefore, this method returns
<code class="docutils literal"><span class="pre">-score/length</span> <span class="pre">+</span> <span class="pre">score</span></code></p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.heuristics.ScorePerWordHeuristic.initialize">
<code class="descname">initialize</code><span class="sig-paren">(</span><em>src_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/heuristics.html#ScorePerWordHeuristic.initialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.heuristics.ScorePerWordHeuristic.initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Empty method.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-cam.sgnmt.decoding">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-cam.sgnmt.decoding" title="Permalink to this headline">¶</a></h2>
<p>This package contains the central interfaces for the decoder (in the
<code class="docutils literal"><span class="pre">core</span></code> module ), and the implementations of search strategies
(<code class="docutils literal"><span class="pre">Decoder</span></code>) in the <code class="docutils literal"><span class="pre">decoder</span></code> module.</p>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="cam.sgnmt.predictors.html" class="btn btn-neutral float-right" title="cam.sgnmt.predictors package" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="cam.sgnmt.blocks.machine_translation.html" class="btn btn-neutral" title="cam.sgnmt.blocks.machine_translation package" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2016, University of Cambridge.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>