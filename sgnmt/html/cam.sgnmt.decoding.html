

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>cam.sgnmt.decoding package &mdash; SGNMT 1.1 documentation</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  

  
    <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  

  
    <link rel="top" title="SGNMT 1.1 documentation" href="index.html"/>
        <link rel="up" title="cam.sgnmt package" href="cam.sgnmt.html"/>
        <link rel="next" title="cam.sgnmt.misc package" href="cam.sgnmt.misc.html"/>
        <link rel="prev" title="cam.sgnmt package" href="cam.sgnmt.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search">
          

          
            <a href="index.html" class="icon icon-home"> SGNMT
          

          
          </a>

          
            
            
              <div class="version">
                1.1
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
                <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="setup.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial.html">Tutorial: Basics (T2T)</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial_pytorch.html">Tutorial: fairseq (PyTorch)</a></li>
<li class="toctree-l1"><a class="reference internal" href="adding_components.html">Tutorial: Adding new components</a></li>
<li class="toctree-l1"><a class="reference internal" href="bea19_gec.html">Tutorial:  Grammatical error correction</a></li>
<li class="toctree-l1"><a class="reference internal" href="tutorial_blocks.html">Tutorial: Blocks/Thano (outdated)</a></li>
<li class="toctree-l1"><a class="reference internal" href="command_line.html">Command-line reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="predictors.html">Predictors</a></li>
<li class="toctree-l1"><a class="reference internal" href="decoders.html">Decoders</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="faq.html">Common issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="publications.html">Publications</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="cam.sgnmt.html">All modules</a><ul class="current">
<li class="toctree-l2 current"><a class="reference internal" href="cam.sgnmt.html#subpackages">Subpackages</a><ul class="current">
<li class="toctree-l3 current"><a class="current reference internal" href="#">cam.sgnmt.decoding package</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#submodules">Submodules</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-cam.sgnmt.decoding.astar">cam.sgnmt.decoding.astar module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-cam.sgnmt.decoding.beam">cam.sgnmt.decoding.beam module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-cam.sgnmt.decoding.bigramgreedy">cam.sgnmt.decoding.bigramgreedy module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-cam.sgnmt.decoding.bucket">cam.sgnmt.decoding.bucket module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-cam.sgnmt.decoding.combibeam">cam.sgnmt.decoding.combibeam module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-cam.sgnmt.decoding.combination">cam.sgnmt.decoding.combination module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-cam.sgnmt.decoding.core">cam.sgnmt.decoding.core module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-cam.sgnmt.decoding.dfs">cam.sgnmt.decoding.dfs module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-cam.sgnmt.decoding.flip">cam.sgnmt.decoding.flip module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-cam.sgnmt.decoding.fstbeam">cam.sgnmt.decoding.fstbeam module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-cam.sgnmt.decoding.greedy">cam.sgnmt.decoding.greedy module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-cam.sgnmt.decoding.heuristics">cam.sgnmt.decoding.heuristics module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-cam.sgnmt.decoding.interpolation">cam.sgnmt.decoding.interpolation module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-cam.sgnmt.decoding.lenbeam">cam.sgnmt.decoding.lenbeam module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-cam.sgnmt.decoding.mbrbeam">cam.sgnmt.decoding.mbrbeam module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-cam.sgnmt.decoding.multisegbeam">cam.sgnmt.decoding.multisegbeam module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-cam.sgnmt.decoding.predlimitbeam">cam.sgnmt.decoding.predlimitbeam module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-cam.sgnmt.decoding.restarting">cam.sgnmt.decoding.restarting module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-cam.sgnmt.decoding.sepbeam">cam.sgnmt.decoding.sepbeam module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-cam.sgnmt.decoding.syncbeam">cam.sgnmt.decoding.syncbeam module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-cam.sgnmt.decoding.syntaxbeam">cam.sgnmt.decoding.syntaxbeam module</a></li>
<li class="toctree-l4"><a class="reference internal" href="#module-cam.sgnmt.decoding">Module contents</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="cam.sgnmt.misc.html">cam.sgnmt.misc package</a></li>
<li class="toctree-l3"><a class="reference internal" href="cam.sgnmt.predictors.html">cam.sgnmt.predictors package</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="cam.sgnmt.html#submodules">Submodules</a></li>
<li class="toctree-l2"><a class="reference internal" href="cam.sgnmt.html#cam-sgnmt-decode-module">cam.sgnmt.decode module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cam.sgnmt.html#module-cam.sgnmt.decode_utils">cam.sgnmt.decode_utils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cam.sgnmt.html#cam-sgnmt-extract-scores-along-reference-module">cam.sgnmt.extract_scores_along_reference module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cam.sgnmt.html#module-cam.sgnmt.io">cam.sgnmt.io module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cam.sgnmt.html#module-cam.sgnmt.output">cam.sgnmt.output module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cam.sgnmt.html#module-cam.sgnmt.tf_utils">cam.sgnmt.tf_utils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cam.sgnmt.html#module-cam.sgnmt.ui">cam.sgnmt.ui module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cam.sgnmt.html#module-cam.sgnmt.utils">cam.sgnmt.utils module</a></li>
<li class="toctree-l2"><a class="reference internal" href="cam.sgnmt.html#module-cam.sgnmt">Module contents</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="index.html">SGNMT</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          

 



<div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="index.html">Docs</a> &raquo;</li>
      
          <li><a href="cam.sgnmt.html">cam.sgnmt package</a> &raquo;</li>
      
    <li>cam.sgnmt.decoding package</li>
      <li class="wy-breadcrumbs-aside">
        
          
            <a href="_sources/cam.sgnmt.decoding.txt" rel="nofollow"> View page source</a>
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="cam-sgnmt-decoding-package">
<h1>cam.sgnmt.decoding package<a class="headerlink" href="#cam-sgnmt-decoding-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-cam.sgnmt.decoding.astar">
<span id="cam-sgnmt-decoding-astar-module"></span><h2>cam.sgnmt.decoding.astar module<a class="headerlink" href="#module-cam.sgnmt.decoding.astar" title="Permalink to this headline">¶</a></h2>
<p>Implementation of the A* search strategy</p>
<dl class="class">
<dt id="cam.sgnmt.decoding.astar.AstarDecoder">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.astar.</code><code class="descname">AstarDecoder</code><span class="sig-paren">(</span><em>decoder_args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/astar.html#AstarDecoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.astar.AstarDecoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.core.Decoder" title="cam.sgnmt.decoding.core.Decoder"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.core.Decoder</span></code></a></p>
<p>This decoder implements A*. For heuristics, see the the
<code class="docutils literal"><span class="pre">decoding.core</span></code> module for interfaces and the general handling of
heuristics, and the <code class="docutils literal"><span class="pre">decoding.heuristics</span></code> package for heuristic
implementations. This A* implementation does not have a &#8216;closed
set&#8217;, i.e. we do not keep track of already visited states. Make
sure that your search space is acyclic (normally it is unless you
decode on cyclic lattices with the fst predictor.</p>
<p>Creates a new A* decoder instance. The following values are
fetched from <cite>decoder_args</cite>:</p>
<blockquote>
<div><p>beam (int): Maximum number of active hypotheses.
pure_heuristic_scores (bool): For standard A* set this to</p>
<blockquote>
<div>false. If set to true, partial
hypo scores are ignored when
scoring hypotheses.</div></blockquote>
<dl class="docutils">
<dt>early_stopping (bool): If this is true, partial hypotheses</dt>
<dd>with score worse than the current
best complete scores are not
expanded. This applies when nbest is
larger than one and inadmissible
heuristics are used</dd>
<dt>nbest (int): If this is set to a positive value, we do not</dt>
<dd>stop decoding at the first complete path, but
continue search until we collected this many
complete hypothesis. With an admissible
heuristic, this will yield an exact n-best
list.</dd>
</dl>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>decoder_args</strong> (<em>object</em>) &#8211; Decoder configuration passed through
from the configuration API.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cam.sgnmt.decoding.astar.AstarDecoder.decode">
<code class="descname">decode</code><span class="sig-paren">(</span><em>src_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/astar.html#AstarDecoder.decode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.astar.AstarDecoder.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decodes a single source sentence using A* search.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-cam.sgnmt.decoding.beam">
<span id="cam-sgnmt-decoding-beam-module"></span><h2>cam.sgnmt.decoding.beam module<a class="headerlink" href="#module-cam.sgnmt.decoding.beam" title="Permalink to this headline">¶</a></h2>
<p>Implementation of the beam search strategy</p>
<dl class="class">
<dt id="cam.sgnmt.decoding.beam.BeamDecoder">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.beam.</code><code class="descname">BeamDecoder</code><span class="sig-paren">(</span><em>decoder_args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/beam.html#BeamDecoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.beam.BeamDecoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.core.Decoder" title="cam.sgnmt.decoding.core.Decoder"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.core.Decoder</span></code></a></p>
<p>This decoder implements standard beam search and several
variants of it such as diversity promoting beam search and beam
search with heuristic future cost estimates. This implementation
supports risk-free pruning and hypotheses recombination.</p>
<p>Creates a new beam decoder instance. The following values
are fetched from <cite>decoder_args</cite>:</p>
<blockquote>
<div><p>hypo_recombination (bool): Activates hypo recombination
beam (int): Absolute beam size. A beam of 12 means</p>
<blockquote>
<div>that we keep track of 12 active hypotheses</div></blockquote>
<dl class="docutils">
<dt>sub_beam (int): Number of children per hypothesis. Set to</dt>
<dd>beam size if zero.</dd>
<dt>pure_heuristic_scores (bool): Hypotheses to keep in the beam</dt>
<dd>are normally selected
according the sum of partial
hypo score and future cost
estimates. If set to true,
partial hypo scores are
ignored.</dd>
<dt>diversity_factor (float): If this is set to a positive</dt>
<dd>value we add diversity promoting
penalization terms to the partial
hypothesis scores following Li
and Jurafsky, 2016</dd>
<dt>early_stopping (bool): If true, we stop when the best</dt>
<dd>scoring hypothesis ends with &lt;/S&gt;.
If false, we stop when all hypotheses
end with &lt;/S&gt;. Enable if you are
only interested in the single best
decoding result. If you want to
create full 12-best lists, disable</dd>
</dl>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>decoder_args</strong> (<em>object</em>) &#8211; Decoder configuration passed through
from the configuration API.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cam.sgnmt.decoding.beam.BeamDecoder.decode">
<code class="descname">decode</code><span class="sig-paren">(</span><em>src_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/beam.html#BeamDecoder.decode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.beam.BeamDecoder.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decodes a single source sentence using beam search.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-cam.sgnmt.decoding.bigramgreedy">
<span id="cam-sgnmt-decoding-bigramgreedy-module"></span><h2>cam.sgnmt.decoding.bigramgreedy module<a class="headerlink" href="#module-cam.sgnmt.decoding.bigramgreedy" title="Permalink to this headline">¶</a></h2>
<p>Implementation of the bigram greedy search strategy</p>
<dl class="class">
<dt id="cam.sgnmt.decoding.bigramgreedy.BigramGreedyDecoder">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.bigramgreedy.</code><code class="descname">BigramGreedyDecoder</code><span class="sig-paren">(</span><em>decoder_args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/bigramgreedy.html#BigramGreedyDecoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.bigramgreedy.BigramGreedyDecoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.core.Decoder" title="cam.sgnmt.decoding.core.Decoder"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.core.Decoder</span></code></a></p>
<p>The bigram greedy decoder collects bigram statistics at each
node expansions. After each decoding pass, it constructs a new
hypothesis to rescore by greedily selecting bigrams and gluing
them together. Afterwards, the new hypothesis is rescored and new
bigram statistics are collected.</p>
<p>Note that this decoder does not support the <code class="docutils literal"><span class="pre">max_length</span></code>
parameter as it is designed for fixed length decoding problems.</p>
<p>Also note that this decoder works only for bag-of-words problems.
Do not use the bow predictor in combination with this decoder as
it will hide the EOS scores which are important to estimate bigram
scores.</p>
<p>Creates a new bigram greedy decoder. Do not use this decoder
in combination with the bow predictor as it inherently already
satisfies the bag-of-word constrains. The following values
are fetched from <cite>decoder_args</cite>:</p>
<blockquote>
<div><dl class="docutils">
<dt>trg_test (string): Path to a plain text file which</dt>
<dd>defines the bag of words</dd>
<dt>max_node_expansions (int): Maximum number of node expansions</dt>
<dd>for inadmissible pruning.</dd>
</dl>
<p>early_stopping (boolean): Activates admissible pruning</p>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>decoder_args</strong> (<em>object</em>) &#8211; Decoder configuration passed through
from the configuration API.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cam.sgnmt.decoding.bigramgreedy.BigramGreedyDecoder.decode">
<code class="descname">decode</code><span class="sig-paren">(</span><em>src_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/bigramgreedy.html#BigramGreedyDecoder.decode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.bigramgreedy.BigramGreedyDecoder.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decodes a single source sentence with the flip decoder</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-cam.sgnmt.decoding.bucket">
<span id="cam-sgnmt-decoding-bucket-module"></span><h2>cam.sgnmt.decoding.bucket module<a class="headerlink" href="#module-cam.sgnmt.decoding.bucket" title="Permalink to this headline">¶</a></h2>
<p>Implementation of the bucket search strategy</p>
<dl class="class">
<dt id="cam.sgnmt.decoding.bucket.BucketDecoder">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.bucket.</code><code class="descname">BucketDecoder</code><span class="sig-paren">(</span><em>decoder_args</em>, <em>hypo_recombination</em>, <em>max_expansions=0</em>, <em>low_memory_mode=True</em>, <em>beam=1</em>, <em>pure_heuristic_scores=False</em>, <em>diversity_factor=-1.0</em>, <em>early_stopping=True</em>, <em>stochastic=False</em>, <em>bucket_selector='maxscore'</em>, <em>bucket_score_strategy='difference'</em>, <em>collect_stats_strategy='best'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/bucket.html#BucketDecoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.bucket.BucketDecoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.core.Decoder" title="cam.sgnmt.decoding.core.Decoder"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.core.Decoder</span></code></a></p>
<p>The bucket decoder maintains separate buckets for each sentence
length. The buckets contain partial hypotheses. In each iteration,
the decoder selects a bucket, and expands the best hypothesis in
this bucket by one token. The core of the bucket decoder is the
bucket selection strategy. The following strategies are available:</p>
<ul>
<li><dl class="first docutils">
<dt>&#8216;iter&#8217;: Puts all buckets in a big loop and iterates through it.</dt>
<dd><p class="first last">With this strategy, the number of hypothesis expansions
is equally distributed over the buckets</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>&#8216;random&#8217;: (with stochastic=true and bucket_selecto!=difference)</dt>
<dd><p class="first last">Randomly select a non-empty bucket</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>&#8216;difference&#8217;: Similar to the heuristic used by the restarting</dt>
<dd><p class="first last">decoder. Select the bucket in which the difference
between best and second best hypothesis is minimal</p>
</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>&#8216;maxdiff&#8217;: Like &#8216;iter&#8217;, but filters buckets in which the</dt>
<dd><p class="first last">difference between first and second hypo is larger
than epsilon. If no such buckets exist, increase
epsilon</p>
</dd>
</dl>
</li>
</ul>
<p>Create a new bucket decoder</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>decoder_args</strong> (<em>object</em>) &#8211; Decoder configuration passed through
from the configuration API.</li>
<li><strong>hypo_recombination</strong> (<em>boolean</em>) &#8211; Activates hypothesis
recombination. Hypos are
tested only within a bucket</li>
<li><strong>max_expansions</strong> (<em>int</em>) &#8211; Maximum number of node expansions for
inadmissible pruning.</li>
<li><strong>low_memory_mode</strong> (<em>bool</em>) &#8211; Switch on low memory mode at cost
of some computational overhead.
Limits the number of hypotheses in
each bucket to the number of
remaining node expansions</li>
<li><strong>beam</strong> (<em>int</em>) &#8211; Number of hypotheses which get expanded at once
after selecting a bucket.</li>
<li><strong>pure_heuristic_scores</strong> (<em>bool</em>) &#8211; If false, hypos are scored
with partial score plus
future cost estimates. If
true, only the future cost
estimates are used</li>
<li><strong>diversity_factor</strong> (<em>float</em>) &#8211; If this is set to a positive
value, we reorder hypos in a
bucket by adding a term which
counts how many hypos with the
same parent have been expanded
already</li>
<li><strong>early_stopping</strong> (<em>boolean</em>) &#8211; Admissible pruning (works only if
scores are non-positive)</li>
<li><strong>stochastic</strong> (<em>boolean</em>) &#8211; Stochastic bucket selection. If the
bucket selector is not &#8216;difference&#8217;,
this results in random bucket
selection. If <code class="docutils literal"><span class="pre">bucket_selector</span></code> is
set to &#8216;difference&#8217;, buckets are
randomly selected with probability
according the bucket score</li>
<li><strong>bucket_selector</strong> (<em>string</em>) &#8211; Bucket selection strategy. &#8216;iter&#8217;,
&#8216;maxscore&#8217;. &#8216;score&#8217;. See the
class docstring for more info</li>
<li><strong>bucket_score_strategy</strong> (<em>string</em>) &#8211; Determines the way the
buckets are scored.
&#8216;difference&#8217; between current
best word score and best
hypo in bucket, &#8216;absolute&#8217;
hypo score, &#8216;heap&#8217; score of
top scoring hypo in bucket ,
&#8216;constant&#8217; score of 0.0.</li>
<li><strong>collect_stats_strategy</strong> (<em>string</em>) &#8211; best, full, or all. Defines
how unigram estimates are
collected for heuristic</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cam.sgnmt.decoding.bucket.BucketDecoder.decode">
<code class="descname">decode</code><span class="sig-paren">(</span><em>src_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/bucket.html#BucketDecoder.decode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.bucket.BucketDecoder.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decodes a single source sentence.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-cam.sgnmt.decoding.combibeam">
<span id="cam-sgnmt-decoding-combibeam-module"></span><h2>cam.sgnmt.decoding.combibeam module<a class="headerlink" href="#module-cam.sgnmt.decoding.combibeam" title="Permalink to this headline">¶</a></h2>
<p>Implementation of beam search which applies combination_sheme at
each time step.</p>
<dl class="class">
<dt id="cam.sgnmt.decoding.combibeam.CombiBeamDecoder">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.combibeam.</code><code class="descname">CombiBeamDecoder</code><span class="sig-paren">(</span><em>decoder_args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/combibeam.html#CombiBeamDecoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.combibeam.CombiBeamDecoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.beam.BeamDecoder" title="cam.sgnmt.decoding.beam.BeamDecoder"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.beam.BeamDecoder</span></code></a></p>
<p>This beam search implementation is a modification to the hypo
expansion strategy. Rather than selecting hypotheses based on
the sum of the previous hypo scores and the current one, we
apply combination_scheme in each time step. This makes it possible
to use schemes like Bayesian combination on the word rather than
the full sentence level.</p>
<p>Creates a new beam decoder instance. In addition to the
constructor of <cite>BeamDecoder</cite>, the following values are fetched
from <cite>decoder_args</cite>:</p>
<blockquote>
<div>combination_scheme (string): breakdown2score strategy</div></blockquote>
<dl class="staticmethod">
<dt id="cam.sgnmt.decoding.combibeam.CombiBeamDecoder.get_domain_task_weights">
<em class="property">static </em><code class="descname">get_domain_task_weights</code><span class="sig-paren">(</span><em>w</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/combibeam.html#CombiBeamDecoder.get_domain_task_weights"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.combibeam.CombiBeamDecoder.get_domain_task_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Get array of domain-task weights from string w
Returns None if w is None or contains non-square number</p>
<blockquote>
<div>of weights (currently invalid)
or 2D numpy float array of weights otherwise</div></blockquote>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.decoding.combibeam.CombiStatePartialHypo">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.combibeam.</code><code class="descname">CombiStatePartialHypo</code><span class="sig-paren">(</span><em>initial_states=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/combibeam.html#CombiStatePartialHypo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.combibeam.CombiStatePartialHypo" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.core.PartialHypothesis" title="cam.sgnmt.decoding.core.PartialHypothesis"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.core.PartialHypothesis</span></code></a></p>
<p>Identical to PartialHypothesis, but tracks the
last-score-but-one for score combination</p>
</dd></dl>

</div>
<div class="section" id="module-cam.sgnmt.decoding.combination">
<span id="cam-sgnmt-decoding-combination-module"></span><h2>cam.sgnmt.decoding.combination module<a class="headerlink" href="#module-cam.sgnmt.decoding.combination" title="Permalink to this headline">¶</a></h2>
<p>This module contains strategies to convert a score breakdown to
the total score. This is commonly specified via the
&#8211;combination_scheme parameter.</p>
<dl class="docutils">
<dt>TODO: The breakdown2score interface is not very elegant, and has some</dt>
<dd>overlap with the interpolation_strategy implementations.</dd>
</dl>
<dl class="function">
<dt id="cam.sgnmt.decoding.combination.breakdown2score_bayesian">
<code class="descclassname">cam.sgnmt.decoding.combination.</code><code class="descname">breakdown2score_bayesian</code><span class="sig-paren">(</span><em>working_score</em>, <em>score_breakdown</em>, <em>full=False</em>, <em>prev_score=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/combination.html#breakdown2score_bayesian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.combination.breakdown2score_bayesian" title="Permalink to this definition">¶</a></dt>
<dd><p>This realizes score combination following the Bayesian LM
interpolation scheme from (Allauzen and Riley, 2011)</p>
<blockquote>
<div>Bayesian Language Model Interpolation for Mobile Speech Input</div></blockquote>
<p>By setting K=T we define the predictor weights according the score
the predictors give to the current partial hypothesis. The initial
predictor weights are used as priors.
TODO could make more efficient use of <code class="docutils literal"><span class="pre">working_score</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>working_score</strong> (<em>float</em>) &#8211; Working combined score, which is the
weighted sum of the scores in
<code class="docutils literal"><span class="pre">score_breakdown</span></code>. Not used.</li>
<li><strong>score_breakdown</strong> (<em>list</em>) &#8211; Breakdown of the combined score into
predictor scores</li>
<li><strong>full</strong> (<em>bool</em>) &#8211; <p>If True, reevaluate all time steps. If False,
assume that this function has been called in the</p>
<blockquote>
<div>previous time step.</div></blockquote>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">float. Bayesian interpolated predictor scores</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="cam.sgnmt.decoding.combination.breakdown2score_bayesian_loglin">
<code class="descclassname">cam.sgnmt.decoding.combination.</code><code class="descname">breakdown2score_bayesian_loglin</code><span class="sig-paren">(</span><em>working_score</em>, <em>score_breakdown</em>, <em>full=False</em>, <em>prev_score=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/combination.html#breakdown2score_bayesian_loglin"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.combination.breakdown2score_bayesian_loglin" title="Permalink to this definition">¶</a></dt>
<dd><p>Like bayesian combination scheme, but uses loglinear model
combination rather than linear interpolation weights</p>
<p>TODO: Implement incremental version of it, write weights into breakdowns.</p>
</dd></dl>

<dl class="function">
<dt id="cam.sgnmt.decoding.combination.breakdown2score_bayesian_state_dependent">
<code class="descclassname">cam.sgnmt.decoding.combination.</code><code class="descname">breakdown2score_bayesian_state_dependent</code><span class="sig-paren">(</span><em>working_score</em>, <em>score_breakdown</em>, <em>full=False</em>, <em>prev_score=None</em>, <em>lambdas=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/combination.html#breakdown2score_bayesian_state_dependent"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.combination.breakdown2score_bayesian_state_dependent" title="Permalink to this definition">¶</a></dt>
<dd><p>This realizes score combination following the Bayesian LM
interpolation scheme from (Allauzen and Riley, 2011)</p>
<blockquote>
<div>Bayesian Language Model Interpolation for Mobile Speech Input</div></blockquote>
<p>By setting K=T we define the predictor weights according the score
the predictors give to the current partial hypothesis. The initial
predictor weights are used as priors .</p>
<p>Unlike breakdown2score_bayesian, define state-independent weights
which affect how much state-dependent mixture weights (alphas) are
affected by scores from the other model.</p>
<p>Makes more efficient use of working_score and calculated priors
when used incrementally.
:param working_score: Working combined score, which is the</p>
<blockquote>
<div>weighted sum of the scores in
<code class="docutils literal"><span class="pre">score_breakdown</span></code>. Not used.</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>score_breakdown</strong> (<em>list</em>) &#8211; Breakdown of the combined score into
predictor scores</li>
<li><strong>full</strong> (<em>bool</em>) &#8211; <p>If True, reevaluate all time steps. If False,
assume that this function has been called in the</p>
<blockquote>
<div>previous time step.</div></blockquote>
</li>
<li><strong>prev_score</strong> &#8211; score of hypothesis without final step</li>
<li><strong>lambdas</strong> &#8211; np array of domain-task weights</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">float. Bayesian interpolated predictor scores</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="cam.sgnmt.decoding.combination.breakdown2score_length_norm">
<code class="descclassname">cam.sgnmt.decoding.combination.</code><code class="descname">breakdown2score_length_norm</code><span class="sig-paren">(</span><em>working_score</em>, <em>score_breakdown</em>, <em>full=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/combination.html#breakdown2score_length_norm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.combination.breakdown2score_length_norm" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the combination scheme &#8216;length_norm&#8217; by normalizing
the sum of the predictor scores by the length of the current
sequence (i.e. the length of <code class="docutils literal"><span class="pre">score_breakdown</span></code>).
TODO could make more efficient use of <code class="docutils literal"><span class="pre">working_score</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>working_score</strong> (<em>float</em>) &#8211; Working combined score, which is the
weighted sum of the scores in
<code class="docutils literal"><span class="pre">score_breakdown</span></code>. Not used.</li>
<li><strong>score_breakdown</strong> (<em>list</em>) &#8211; Breakdown of the combined score into
predictor scores</li>
<li><strong>full</strong> (<em>bool</em>) &#8211; <p>If True, reevaluate all time steps. If False,
assume that this function has been called in the</p>
<blockquote>
<div>previous time step (not used).</div></blockquote>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">float. Returns a length normalized <code class="docutils literal"><span class="pre">working_score</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="cam.sgnmt.decoding.combination.breakdown2score_sum">
<code class="descclassname">cam.sgnmt.decoding.combination.</code><code class="descname">breakdown2score_sum</code><span class="sig-paren">(</span><em>working_score</em>, <em>score_breakdown</em>, <em>full=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/combination.html#breakdown2score_sum"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.combination.breakdown2score_sum" title="Permalink to this definition">¶</a></dt>
<dd><p>Implements the combination scheme &#8216;sum&#8217; by always returning
<code class="docutils literal"><span class="pre">working_score</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>working_score</strong> (<em>float</em>) &#8211; Working combined score, which is the
weighted sum of the scores in
<code class="docutils literal"><span class="pre">score_breakdown</span></code></li>
<li><strong>score_breakdown</strong> (<em>list</em>) &#8211; Breakdown of the combined score into
predictor scores (not used).</li>
<li><strong>full</strong> (<em>bool</em>) &#8211; <p>If True, reevaluate all time steps. If False,
assume that this function has been called in the</p>
<blockquote>
<div>previous time step (not used).</div></blockquote>
</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">float. Returns <code class="docutils literal"><span class="pre">working_score</span></code></p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-cam.sgnmt.decoding.core">
<span id="cam-sgnmt-decoding-core-module"></span><h2>cam.sgnmt.decoding.core module<a class="headerlink" href="#module-cam.sgnmt.decoding.core" title="Permalink to this headline">¶</a></h2>
<p>Contains all the basic interfaces and abstract classes for decoders.
The <code class="docutils literal"><span class="pre">Decoder</span></code> class provides common functionality for all decoders.
The <code class="docutils literal"><span class="pre">Hypothesis</span></code> class represents complete hypotheses, which are
returned by decoders. <code class="docutils literal"><span class="pre">PartialHypothesis</span></code> is a helper class which can
be used by predictors to represent translation prefixes.</p>
<dl class="data">
<dt id="cam.sgnmt.decoding.core.CLOSED_VOCAB_SCORE_NORM_EXACT">
<code class="descclassname">cam.sgnmt.decoding.core.</code><code class="descname">CLOSED_VOCAB_SCORE_NORM_EXACT</code><em class="property"> = 2</em><a class="headerlink" href="#cam.sgnmt.decoding.core.CLOSED_VOCAB_SCORE_NORM_EXACT" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Exact</em> &#8211; Normalize by 1 plus the number of words outside the
vocabulary to make it a valid distribution again</p>
</dd></dl>

<dl class="data">
<dt id="cam.sgnmt.decoding.core.CLOSED_VOCAB_SCORE_NORM_NONE">
<code class="descclassname">cam.sgnmt.decoding.core.</code><code class="descname">CLOSED_VOCAB_SCORE_NORM_NONE</code><em class="property"> = 1</em><a class="headerlink" href="#cam.sgnmt.decoding.core.CLOSED_VOCAB_SCORE_NORM_NONE" title="Permalink to this definition">¶</a></dt>
<dd><p><em>None</em> &#8211; Do not apply any normalization.</p>
</dd></dl>

<dl class="data">
<dt id="cam.sgnmt.decoding.core.CLOSED_VOCAB_SCORE_NORM_NON_ZERO">
<code class="descclassname">cam.sgnmt.decoding.core.</code><code class="descname">CLOSED_VOCAB_SCORE_NORM_NON_ZERO</code><em class="property"> = 5</em><a class="headerlink" href="#cam.sgnmt.decoding.core.CLOSED_VOCAB_SCORE_NORM_NON_ZERO" title="Permalink to this definition">¶</a></dt>
<dd><p>Apply no normalization, but ensure posterior contains only tokens with scores
strictly &lt; 0.0.</p>
</dd></dl>

<dl class="data">
<dt id="cam.sgnmt.decoding.core.CLOSED_VOCAB_SCORE_NORM_REDUCED">
<code class="descclassname">cam.sgnmt.decoding.core.</code><code class="descname">CLOSED_VOCAB_SCORE_NORM_REDUCED</code><em class="property"> = 3</em><a class="headerlink" href="#cam.sgnmt.decoding.core.CLOSED_VOCAB_SCORE_NORM_REDUCED" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Reduced</em> &#8211; Always normalize the closed vocabulary scores to the
vocabulary which is defined by the open vocabulary predictors at each
time step.</p>
</dd></dl>

<dl class="data">
<dt id="cam.sgnmt.decoding.core.CLOSED_VOCAB_SCORE_NORM_RESCALE_UNK">
<code class="descclassname">cam.sgnmt.decoding.core.</code><code class="descname">CLOSED_VOCAB_SCORE_NORM_RESCALE_UNK</code><em class="property"> = 4</em><a class="headerlink" href="#cam.sgnmt.decoding.core.CLOSED_VOCAB_SCORE_NORM_RESCALE_UNK" title="Permalink to this definition">¶</a></dt>
<dd><p><em>Rescale UNK</em> &#8211; Divide the UNK scores by the number of words outside the
vocabulary. Results in a valid distribution if predictor scores are
stochastic.</p>
</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.decoding.core.Decoder">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.core.</code><code class="descname">Decoder</code><span class="sig-paren">(</span><em>decoder_args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="cam.sgnmt.html#cam.sgnmt.utils.Observable" title="cam.sgnmt.utils.Observable"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.utils.Observable</span></code></a></p>
<p>A <code class="docutils literal"><span class="pre">Decoder</span></code> instance represents a particular search strategy
such as A*, beam search, greedy search etc. Decisions are made
based on the outputs of one or many predictors, which are
maintained by the <code class="docutils literal"><span class="pre">Decoder</span></code> instance.</p>
<p>Decoders are observable. They fire notifications after
apply_predictors has been called. All heuristics
are observing the decoder by default.</p>
<p>Initializes the decoder instance with no predictors or
heuristics.</p>
<dl class="method">
<dt id="cam.sgnmt.decoding.core.Decoder.add_full_hypo">
<code class="descname">add_full_hypo</code><span class="sig-paren">(</span><em>hypo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder.add_full_hypo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder.add_full_hypo" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a new full hypothesis to <code class="docutils literal"><span class="pre">full_hypos</span></code>. This can be
used by implementing subclasses to add a new hypothesis to the
result set. This method also notifies observers.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>hypo</strong> (<a class="reference internal" href="#cam.sgnmt.decoding.core.Hypothesis" title="cam.sgnmt.decoding.core.Hypothesis"><em>Hypothesis</em></a>) &#8211; New complete hypothesis</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Decoder.add_heuristic">
<code class="descname">add_heuristic</code><span class="sig-paren">(</span><em>heuristic</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder.add_heuristic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder.add_heuristic" title="Permalink to this definition">¶</a></dt>
<dd><p>Add a heuristic to the decoder. For future cost estimates,
the sum of the estimates from all heuristics added so far will
be used. The predictors used in this heuristic have to be set
before via <code class="docutils literal"><span class="pre">set_heuristic_predictors()</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>heuristic</strong> (<a class="reference internal" href="#cam.sgnmt.decoding.core.Heuristic" title="cam.sgnmt.decoding.core.Heuristic"><em>Heuristic</em></a>) &#8211; A heuristic to use for future cost
estimates</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Decoder.add_predictor">
<code class="descname">add_predictor</code><span class="sig-paren">(</span><em>name</em>, <em>predictor</em>, <em>weight=1.0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder.add_predictor"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder.add_predictor" title="Permalink to this definition">¶</a></dt>
<dd><p>Adds a predictor to the decoder. This means that this
predictor is going to be used to predict the next target word
(see <code class="docutils literal"><span class="pre">predict_next</span></code>)</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>name</strong> (<em>string</em>) &#8211; Predictor name like &#8216;nmt&#8217; or &#8216;fst&#8217;</li>
<li><strong>predictor</strong> (<a class="reference internal" href="cam.sgnmt.predictors.html#cam.sgnmt.predictors.core.Predictor" title="cam.sgnmt.predictors.core.Predictor"><em>Predictor</em></a>) &#8211; Predictor instance</li>
<li><strong>weight</strong> (<em>float</em>) &#8211; Predictor weight</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Decoder.apply_interpolation_strategy">
<code class="descname">apply_interpolation_strategy</code><span class="sig-paren">(</span><em>pred_weights</em>, <em>non_zero_words</em>, <em>posteriors</em>, <em>unk_probs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder.apply_interpolation_strategy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder.apply_interpolation_strategy" title="Permalink to this definition">¶</a></dt>
<dd><p>Applies the interpolation strategies to find the predictor
weights for this apply_predictors() call.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>pred_weights</strong> (<em>list</em>) &#8211; a priori predictor weights</li>
<li><strong>non_zero_words</strong> (<em>set</em>) &#8211; All words with positive probability</li>
<li><strong>posteriors</strong> &#8211; Predictor posterior distributions calculated
with <code class="docutils literal"><span class="pre">predict_next()</span></code></li>
<li><strong>unk_probs</strong> &#8211; UNK probabilities of the predictors, calculated
with <code class="docutils literal"><span class="pre">get_unk_probability</span></code></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A list of predictor weights.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Decoder.apply_predictors">
<code class="descname">apply_predictors</code><span class="sig-paren">(</span><em>top_n=0</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder.apply_predictors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder.apply_predictors" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the distribution over the next word by combining the
predictor scores.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>top_n</strong> (<em>int</em>) &#8211; If positive, return only the best n words.</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">Two dicts. <code class="docutils literal"><span class="pre">combined</span></code> maps
target word ids to the combined score, <code class="docutils literal"><span class="pre">score_breakdown</span></code>
contains the scores for each predictor separately
represented as tuples (unweighted_score, predictor_weight)</td>
</tr>
<tr class="field-odd field"><th class="field-name">Return type:</th><td class="field-body">combined,score_breakdown</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Decoder.are_equal_predictor_states">
<code class="descname">are_equal_predictor_states</code><span class="sig-paren">(</span><em>states1</em>, <em>states2</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder.are_equal_predictor_states"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder.are_equal_predictor_states" title="Permalink to this definition">¶</a></dt>
<dd><p>This method applies <code class="docutils literal"><span class="pre">is_equal</span></code> on all predictors. It
returns true if all predictor states are equal.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>states1</strong> (<em>list</em>) &#8211; First predictor states as returned by
<code class="docutils literal"><span class="pre">get_predictor_states</span></code></li>
<li><strong>states2</strong> (<em>list</em>) &#8211; Second predictor states as returned by
<code class="docutils literal"><span class="pre">get_predictor_states</span></code></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">boolean. True if all predictor states are equal, False
otherwise</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Decoder.change_predictor_weights">
<code class="descname">change_predictor_weights</code><span class="sig-paren">(</span><em>new_weights</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder.change_predictor_weights"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder.change_predictor_weights" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="staticmethod">
<dt id="cam.sgnmt.decoding.core.Decoder.combi_arithmetic_unnormalized">
<em class="property">static </em><code class="descname">combi_arithmetic_unnormalized</code><span class="sig-paren">(</span><em>x</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder.combi_arithmetic_unnormalized"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder.combi_arithmetic_unnormalized" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the weighted sum (or geometric mean of log
values). Do not use with empty lists.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>x</strong> (<em>list</em>) &#8211; List of tuples [(out1, weight1), ...]</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">float. Weighted sum out1*weight1+out2*weight2...</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Decoder.consume">
<code class="descname">consume</code><span class="sig-paren">(</span><em>word</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder.consume"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder.consume" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls <code class="docutils literal"><span class="pre">consume()</span></code> on all predictors.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Decoder.decode">
<code class="descname">decode</code><span class="sig-paren">(</span><em>src_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder.decode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decodes a single source sentence. This method has to be
implemented by subclasses. It contains the core of the
implemented search strategy <code class="docutils literal"><span class="pre">src_sentence</span></code> is a list of
source word ids representing the source sentence without
&lt;S&gt; or &lt;/S&gt; symbols. This method returns a list of hypotheses,
order descending by score such that the first entry is the best
decoding result. Implementations should delegate the scoring of
hypotheses to the predictors via <code class="docutils literal"><span class="pre">apply_predictors()</span></code>, and
organize predictor states with the methods <code class="docutils literal"><span class="pre">consume()</span></code>,
<code class="docutils literal"><span class="pre">get_predictor_states()</span></code> and <code class="docutils literal"><span class="pre">set_predictor_states()</span></code>. In
this way, the decoder is decoupled from the scoring modules.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>src_sentence</strong> (<em>list</em>) &#8211; List of source word ids without &lt;S&gt; or
&lt;/S&gt; which make up the source sentence</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">list. A list of <code class="docutils literal"><span class="pre">Hypothesis</span></code> instances ordered by their
score.</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><code class="docutils literal"><span class="pre">NotImplementedError</span></code> &#8211; if the method is not implemented</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Decoder.estimate_future_cost">
<code class="descname">estimate_future_cost</code><span class="sig-paren">(</span><em>hypo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder.estimate_future_cost"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder.estimate_future_cost" title="Permalink to this definition">¶</a></dt>
<dd><p>Uses all heuristics which have been added with
<code class="docutils literal"><span class="pre">add_heuristic</span></code> to estimate the future cost for a given
partial hypothesis. The estimates are used in heuristic based
searches like A*. This function returns the future log <em>cost</em>
(i.e. the lower the better), assuming that the last word in the
partial hypothesis <code class="docutils literal"><span class="pre">hypo</span></code> is consumed next.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>hypo</strong> (<a class="reference internal" href="#cam.sgnmt.decoding.core.PartialHypothesis" title="cam.sgnmt.decoding.core.PartialHypothesis"><em>PartialHypothesis</em></a>) &#8211; Hypothesis for which to estimate
the future cost given the current
predictor state</td>
</tr>
</tbody>
</table>
<dl class="docutils">
<dt>Returns</dt>
<dd>float. Future cost</dd>
</dl>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Decoder.get_full_hypos_sorted">
<code class="descname">get_full_hypos_sorted</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder.get_full_hypos_sorted"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder.get_full_hypos_sorted" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">full_hypos</span></code> sorted by the total score. Can be
used by implementing subclasses as return value of
<code class="docutils literal"><span class="pre">decode</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">list. <code class="docutils literal"><span class="pre">full_hypos</span></code> sorted by <code class="docutils literal"><span class="pre">total_score</span></code>.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Decoder.get_lower_score_bound">
<code class="descname">get_lower_score_bound</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder.get_lower_score_bound"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder.get_lower_score_bound" title="Permalink to this definition">¶</a></dt>
<dd><p>Intended to be called by implementing subclasses. Returns a
lower bound on the best score of the current sentence. This is
either read from the lower bounds file (if provided) or set to
negative infinity.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">float. Lower bound on the best score for current sentence</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Decoder.get_max_expansions">
<code class="descname">get_max_expansions</code><span class="sig-paren">(</span><em>max_expansions_param</em>, <em>src_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder.get_max_expansions"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder.get_max_expansions" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a helper for decoders which support the
<code class="docutils literal"><span class="pre">max_node_expansions</span></code> parameter. It returns the maximum
number of node expansions for the given sentence.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>max_expansions_param</strong> (<em>int</em>) &#8211; max_node_expansions parameter
passed through from the config</li>
<li><strong>src_sentence</strong> (<em>list</em>) &#8211; Current source sentence</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">int. Maximum number of node expansions for this decoding
task.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Decoder.get_predictor_states">
<code class="descname">get_predictor_states</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder.get_predictor_states"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder.get_predictor_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls <code class="docutils literal"><span class="pre">get_state()</span></code> on all predictors.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Decoder.has_predictors">
<code class="descname">has_predictors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder.has_predictors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder.has_predictors" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if predictors have been added to the decoder.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Decoder.initialize_predictors">
<code class="descname">initialize_predictors</code><span class="sig-paren">(</span><em>src_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder.initialize_predictors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder.initialize_predictors" title="Permalink to this definition">¶</a></dt>
<dd><p>First, increases the sentence id counter and calls
<code class="docutils literal"><span class="pre">initialize()</span></code> on all predictors. Then, <code class="docutils literal"><span class="pre">initialize()</span></code> is
called for all heuristics.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>src_sentence</strong> (<em>list</em>) &#8211; List of source word ids without &lt;S&gt; or
&lt;/S&gt; which make up the source sentence</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Decoder.remove_predictors">
<code class="descname">remove_predictors</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder.remove_predictors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder.remove_predictors" title="Permalink to this definition">¶</a></dt>
<dd><p>Removes all predictors of this decoder.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Decoder.set_current_sen_id">
<code class="descname">set_current_sen_id</code><span class="sig-paren">(</span><em>sen_id</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder.set_current_sen_id"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder.set_current_sen_id" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Decoder.set_heuristic_predictors">
<code class="descname">set_heuristic_predictors</code><span class="sig-paren">(</span><em>heuristic_predictors</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder.set_heuristic_predictors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder.set_heuristic_predictors" title="Permalink to this definition">¶</a></dt>
<dd><p>Define the list of predictors used by heuristics. This needs
to be called before adding heuristics with <code class="docutils literal"><span class="pre">add_heuristic()</span></code></p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>heuristic_predictors</strong> (<em>list</em>) &#8211; Predictors and their weights
to be used with heuristics.
Should be in the same form
as <code class="docutils literal"><span class="pre">Decoder.predictors</span></code>,
i.e. a list of
(predictor, weight) tuples</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Decoder.set_predictor_states">
<code class="descname">set_predictor_states</code><span class="sig-paren">(</span><em>states</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Decoder.set_predictor_states"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Decoder.set_predictor_states" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls <code class="docutils literal"><span class="pre">set_state()</span></code> on all predictors.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.decoding.core.Heuristic">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.core.</code><code class="descname">Heuristic</code><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Heuristic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Heuristic" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="cam.sgnmt.html#cam.sgnmt.utils.Observer" title="cam.sgnmt.utils.Observer"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.utils.Observer</span></code></a></p>
<p>A <code class="docutils literal"><span class="pre">Heuristic</span></code> instance can be used to estimate the future
costs for a given word in a given state. See the <code class="docutils literal"><span class="pre">heuristics</span></code>
module for implementations.</p>
<p>Creates a heuristic without predictors.</p>
<dl class="method">
<dt id="cam.sgnmt.decoding.core.Heuristic.estimate_future_cost">
<code class="descname">estimate_future_cost</code><span class="sig-paren">(</span><em>hypo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Heuristic.estimate_future_cost"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Heuristic.estimate_future_cost" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the future cost (i.e. negative score) given the
states of the predictors set by <code class="docutils literal"><span class="pre">set_predictors</span></code> for a
partial hypothesis <code class="docutils literal"><span class="pre">hypo</span></code>. Note that this function is not
supposed to change predictor states. If (e.g. for the greedy
heuristic) this is not possible, the predictor states must be
changed back after execution by the implementing method.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>hypo</strong> (<em>PartialHypo</em>) &#8211; Hypothesis for which to estimate the
future cost</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">float. The future cost estimate for this heuristic</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Heuristic.initialize">
<code class="descname">initialize</code><span class="sig-paren">(</span><em>src_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Heuristic.initialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Heuristic.initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the heuristic with the given source sentence.
This is not passed through to the heuristic predictors
automatically but handles initialization outside the
predictors.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>src_sentence</strong> (<em>list</em>) &#8211; List of source word ids without &lt;S&gt; or
&lt;/S&gt; which make up the source sentence</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Heuristic.notify">
<code class="descname">notify</code><span class="sig-paren">(</span><em>message</em>, <em>message_type=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Heuristic.notify"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Heuristic.notify" title="Permalink to this definition">¶</a></dt>
<dd><p>This is the notification method from the <code class="docutils literal"><span class="pre">Observer</span></code>
super class. We implement it with an empty method here, but
implementing sub classes can override this method to get
notifications from the decoder instance about generated
posterior distributions.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>message</strong> (<em>object</em>) &#8211; The posterior sent by the decoder</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.Heuristic.set_predictors">
<code class="descname">set_predictors</code><span class="sig-paren">(</span><em>predictors</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Heuristic.set_predictors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Heuristic.set_predictors" title="Permalink to this definition">¶</a></dt>
<dd><p>Set the predictors used by this heuristic.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>predictors</strong> (<em>list</em>) &#8211; Predictors and their weights to be
used with this heuristic. Should be in
the same form as <code class="docutils literal"><span class="pre">Decoder.predictors</span></code>,
i.e. a list of (predictor, weight)
tuples</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.decoding.core.Hypothesis">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.core.</code><code class="descname">Hypothesis</code><span class="sig-paren">(</span><em>trgt_sentence</em>, <em>total_score</em>, <em>score_breakdown=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#Hypothesis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.Hypothesis" title="Permalink to this definition">¶</a></dt>
<dd><p>Complete translation hypotheses are represented by an instance
of this class. We store the produced sentence, the combined score,
and a score breakdown to the separate predictor scores.</p>
<p>Creates a new full hypothesis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>trgt_sentence</strong> (<em>list</em>) &#8211; List of target word ids without &lt;S&gt;
or &lt;/S&gt; which make up the target
sentence</li>
<li><strong>total_score</strong> (<em>float</em>) &#8211; combined total score of this hypo</li>
<li><strong>score_breakdown</strong> (<em>list</em>) &#8211; Predictor score breakdown for each
target token in <code class="docutils literal"><span class="pre">trgt_sentence</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.decoding.core.PartialHypothesis">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.core.</code><code class="descname">PartialHypothesis</code><span class="sig-paren">(</span><em>initial_states=None</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#PartialHypothesis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.PartialHypothesis" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Represents a partial hypothesis in various decoders.</p>
<p>Creates a new partial hypothesis with zero score and empty
translation prefix.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>initial_states</strong> &#8211; Initial predictor states</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cam.sgnmt.decoding.core.PartialHypothesis.cheap_expand">
<code class="descname">cheap_expand</code><span class="sig-paren">(</span><em>word</em>, <em>score</em>, <em>score_breakdown</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#PartialHypothesis.cheap_expand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.PartialHypothesis.cheap_expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new partial hypothesis adding a new word to the
translation prefix with given probability. Does NOT update the
predictor states but adds a flag which signals that the last
word in this hypothesis has not been consumed yet by the
predictors. This can save memory because we can reuse the
current state for many hypothesis. It also saves computation
as we do not consume words which are then discarded anyway by
the search procedure.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>word</strong> (<em>int</em>) &#8211; New word to add to the translation prefix</li>
<li><strong>score</strong> (<em>float</em>) &#8211; Word log probability which is to be added
to the total hypothesis score</li>
<li><strong>score_breakdown</strong> (<em>list</em>) &#8211; Predictor score breakdown for
the new word</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.PartialHypothesis.expand">
<code class="descname">expand</code><span class="sig-paren">(</span><em>word</em>, <em>new_states</em>, <em>score</em>, <em>score_breakdown</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#PartialHypothesis.expand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.PartialHypothesis.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new partial hypothesis adding a new word to the
translation prefix with given probability and updates the
stored predictor states.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>word</strong> (<em>int</em>) &#8211; New word to add to the translation prefix</li>
<li><strong>new_states</strong> (<em>object</em>) &#8211; Predictor states after consuming
<code class="docutils literal"><span class="pre">word</span></code></li>
<li><strong>score</strong> (<em>float</em>) &#8211; Word log probability which is to be added
to the total hypothesis score</li>
<li><strong>score_breakdown</strong> (<em>list</em>) &#8211; Predictor score breakdown for
the new word</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.PartialHypothesis.generate_full_hypothesis">
<code class="descname">generate_full_hypothesis</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#PartialHypothesis.generate_full_hypothesis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.PartialHypothesis.generate_full_hypothesis" title="Permalink to this definition">¶</a></dt>
<dd><p>Create a <code class="docutils literal"><span class="pre">Hypothesis</span></code> instance from this hypothesis.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.core.PartialHypothesis.get_last_word">
<code class="descname">get_last_word</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/core.html#PartialHypothesis.get_last_word"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.core.PartialHypothesis.get_last_word" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the last word in the translation prefix.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-cam.sgnmt.decoding.dfs">
<span id="cam-sgnmt-decoding-dfs-module"></span><h2>cam.sgnmt.decoding.dfs module<a class="headerlink" href="#module-cam.sgnmt.decoding.dfs" title="Permalink to this headline">¶</a></h2>
<p>Implementation of the dfs search strategy</p>
<dl class="class">
<dt id="cam.sgnmt.decoding.dfs.DFSDecoder">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.dfs.</code><code class="descname">DFSDecoder</code><span class="sig-paren">(</span><em>decoder_args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/dfs.html#DFSDecoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.dfs.DFSDecoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.core.Decoder" title="cam.sgnmt.decoding.core.Decoder"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.core.Decoder</span></code></a></p>
<p>This decoder implements depth first search without using
heuristics. This is the most efficient search algorithm for
complete enumeration of the search space as it minimizes the
number of <code class="docutils literal"><span class="pre">get_state()</span></code> and <code class="docutils literal"><span class="pre">set_state()</span></code> calls. Note that
this DFS implementation has no cycle detection, i.e. if the search
space has cycles this decoder may run into an infinite loop.</p>
<p>Creates new DFS decoder instance. The following values are
fetched from <cite>decoder_args</cite>:</p>
<blockquote>
<div><dl class="docutils">
<dt>decoder_args (object): Decoder configuration passed through</dt>
<dd>from the configuration API.</dd>
<dt>early_stopping (bool): Enable safe (admissible) branch</dt>
<dd>pruning if the accumulated score
is already worse than the currently
best complete score. Do not use if
scores can be positive</dd>
<dt>max_expansions (int): Maximum number of node expansions for</dt>
<dd>inadmissible pruning.</dd>
</dl>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>decoder_args</strong> (<em>object</em>) &#8211; Decoder configuration passed through
from the configuration API.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cam.sgnmt.decoding.dfs.DFSDecoder.decode">
<code class="descname">decode</code><span class="sig-paren">(</span><em>src_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/dfs.html#DFSDecoder.decode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.dfs.DFSDecoder.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decodes a single source sentence using depth first search.
If <code class="docutils literal"><span class="pre">max_expansions</span></code> equals 0, this corresponds to exhaustive
search for the globally best scoring hypothesis. Note that with
<code class="docutils literal"><span class="pre">early_stopping</span></code> enabled, the returned set of hypothesis are
not necessarily the global n-best hypotheses. To create an
exact n-best list, disable both <code class="docutils literal"><span class="pre">max_expansions</span></code> and
<code class="docutils literal"><span class="pre">early_stopping</span></code> in the constructor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>src_sentence</strong> (<em>list</em>) &#8211; List of source word ids without &lt;S&gt; or
&lt;/S&gt; which make up the source sentence</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">list. A list of <code class="docutils literal"><span class="pre">Hypothesis</span></code> instances ordered by their
score. If <code class="docutils literal"><span class="pre">max_expansions</span></code> equals 0, the first element
holds the global best scoring hypothesis</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.decoding.dfs.SimpleDFSDecoder">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.dfs.</code><code class="descname">SimpleDFSDecoder</code><span class="sig-paren">(</span><em>decoder_args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/dfs.html#SimpleDFSDecoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.dfs.SimpleDFSDecoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.core.Decoder" title="cam.sgnmt.decoding.core.Decoder"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.core.Decoder</span></code></a></p>
<p>This is a stripped down version of the DFS decoder which is
designed to explore the entire search space. SimpleDFS is
intended to be used with a <cite>score_lower_bounds_file</cite> from a
previous beam search run which already contains good lower
bounds. SimpleDFS verifies whether the lower bound is actually
the global best score.</p>
<p>SimpleDFS can only be used with a single predictor.</p>
<p>SimpleDFS does not support max_expansions or max_len_factor.
early_stopping cannot be disabled.</p>
<p>Creates new SimpleDFS decoder instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>decoder_args</strong> (<em>object</em>) &#8211; Decoder configuration passed through
from the configuration API.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cam.sgnmt.decoding.dfs.SimpleDFSDecoder.decode">
<code class="descname">decode</code><span class="sig-paren">(</span><em>src_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/dfs.html#SimpleDFSDecoder.decode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.dfs.SimpleDFSDecoder.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decodes a single source sentence exhaustively using depth
first search.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>src_sentence</strong> (<em>list</em>) &#8211; List of source word ids without &lt;S&gt; or
&lt;/S&gt; which make up the source sentence</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">list. A list of <code class="docutils literal"><span class="pre">Hypothesis</span></code> instances ordered by their
score.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.decoding.dfs.SimpleLengthDFSDecoder">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.dfs.</code><code class="descname">SimpleLengthDFSDecoder</code><span class="sig-paren">(</span><em>decoder_args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/dfs.html#SimpleLengthDFSDecoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.dfs.SimpleLengthDFSDecoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.core.Decoder" title="cam.sgnmt.decoding.core.Decoder"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.core.Decoder</span></code></a></p>
<p>This is a length dependent version of SimpleDFS. This
decoder finds the global best scores for certain hypo lengths.
The <cite>simplelendfs_lower_bounds_file</cite> contains lines of the form</p>
<blockquote>
<div>&lt;length1&gt;:&lt;lower-bound&gt; ... &lt;lengthN&gt;:&lt;lower-boundN&gt;</div></blockquote>
<p>that specify length dependent score lower bounds. The decoder
will search for the optimal model scores for the specified
lengths.</p>
<p>SimpleDFS can only be used with a single predictor.</p>
<p>SimpleDFS does not support max_expansions or max_len_factor.
early_stopping cannot be disabled.</p>
<p>Creates new SimpleDFS decoder instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>decoder_args</strong> (<em>object</em>) &#8211; Decoder configuration passed through
from the configuration API.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cam.sgnmt.decoding.dfs.SimpleLengthDFSDecoder.decode">
<code class="descname">decode</code><span class="sig-paren">(</span><em>src_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/dfs.html#SimpleLengthDFSDecoder.decode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.dfs.SimpleLengthDFSDecoder.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decodes a single source sentence exhaustively using depth
first search under length constraints.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>src_sentence</strong> (<em>list</em>) &#8211; List of source word ids without &lt;S&gt; or
&lt;/S&gt; which make up the source sentence</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">list. A list of <code class="docutils literal"><span class="pre">Hypothesis</span></code> instances ordered by their
score.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-cam.sgnmt.decoding.flip">
<span id="cam-sgnmt-decoding-flip-module"></span><h2>cam.sgnmt.decoding.flip module<a class="headerlink" href="#module-cam.sgnmt.decoding.flip" title="Permalink to this headline">¶</a></h2>
<p>Implementation of the flip search strategy</p>
<dl class="class">
<dt id="cam.sgnmt.decoding.flip.FlipCandidate">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.flip.</code><code class="descname">FlipCandidate</code><span class="sig-paren">(</span><em>trgt_sentence</em>, <em>scores</em>, <em>bigram_scores</em>, <em>max_score</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/flip.html#FlipCandidate"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.flip.FlipCandidate" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Helper class for <code class="docutils literal"><span class="pre">FlipDecoder</span></code>. Represents a full but yet
unscored hypothesis which differs from an explored hypo by one
flip or move operation.</p>
<p>Creates a new candidate hypothesis.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>trgt_sentence</strong> (<em>list</em>) &#8211; Full target sentence</li>
<li><strong>scores</strong> (<em>list</em>) &#8211; Word level scores. Same length as
<code class="docutils literal"><span class="pre">trgt_sentence</span></code></li>
<li><strong>bigram_scores</strong> (<em>dict</em>) &#8211; Bigram scores collected along the
parent hypothesis</li>
<li><strong>max_score</strong> (<em>float</em>) &#8211; Maximum possible score this candidate
can achieve</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.decoding.flip.FlipDecoder">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.flip.</code><code class="descname">FlipDecoder</code><span class="sig-paren">(</span><em>decoder_args</em>, <em>always_greedy=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/flip.html#FlipDecoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.flip.FlipDecoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.core.Decoder" title="cam.sgnmt.decoding.core.Decoder"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.core.Decoder</span></code></a></p>
<p>The flip decoder explores the search space by permutating
already explored hypotheses with a single permutation operation. We
support two operations: &#8216;flip&#8217; flips the position of two target
tokens. &#8216;move&#8217; moves one target token to another location in the
sentence.</p>
<p>Note that this decoder does not support the <code class="docutils literal"><span class="pre">max_length</span></code>
parameter as it is designed for fixed length decoding problems.</p>
<p>Also note that this decoder works only for bag-of-words problems.
Do not use the bow predictor in combination with this decoder as
it will hide the EOS scores which are important to estimate bigram
scores.</p>
<p>Creates a new flip decoder. Do not use this decoder in
combination with the bow predictor as it inherently already
satisfies the bag-of-word constrains. The following values
are fetched from <cite>decoder_args</cite>:</p>
<blockquote>
<div><dl class="docutils">
<dt>trg_test(string): Path to a plain text file which</dt>
<dd>defines the bag of words</dd>
<dt>max_node_expansions (int): Maximum number of node expansions</dt>
<dd>for inadmissible pruning.</dd>
</dl>
<p>early_stopping (boolean): Activates admissible pruning</p>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>decoder_args</strong> (<em>object</em>) &#8211; Decoder configuration passed through
from the configuration API.</li>
<li><strong>always_greedy</strong> (<em>boolean</em>) &#8211; Per default, the flip decoder does
forced decoding along the complete
candidate sentence. Set to True to
do greedy decoding from the
backtraced node instead</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cam.sgnmt.decoding.flip.FlipDecoder.decode">
<code class="descname">decode</code><span class="sig-paren">(</span><em>src_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/flip.html#FlipDecoder.decode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.flip.FlipDecoder.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decodes a single source sentence with the flip decoder</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-cam.sgnmt.decoding.fstbeam">
<span id="cam-sgnmt-decoding-fstbeam-module"></span><h2>cam.sgnmt.decoding.fstbeam module<a class="headerlink" href="#module-cam.sgnmt.decoding.fstbeam" title="Permalink to this headline">¶</a></h2>
<p>Implementation of a beam search which uses an FST for synchronization.</p>
<dl class="class">
<dt id="cam.sgnmt.decoding.fstbeam.FSTBeamDecoder">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.fstbeam.</code><code class="descname">FSTBeamDecoder</code><span class="sig-paren">(</span><em>decoder_args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/fstbeam.html#FSTBeamDecoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.fstbeam.FSTBeamDecoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.beam.BeamDecoder" title="cam.sgnmt.decoding.beam.BeamDecoder"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.beam.BeamDecoder</span></code></a></p>
<p>This beam search variant synchronizes hypotheses if they share
the same node in an FST. This is similar to the syncbeam strategy,
but rather than using a dedicated synchronization symbol, we keep
track of the state ID of each hypothesis in an FST. Hypotheses are
expanded until all of them arrive at the same state id, and are
then compared with each other to select the set of active
hypotheses in the next time step.</p>
<p>Creates a new beam decoder instance with FST-based
synchronization. In addition to the constructor of
<cite>BeamDecoder</cite>, the following values are fetched from
<cite>decoder_args</cite>:</p>
<blockquote>
<div>max_word_len (int): Maximum length of a single word
fst_path (string): Path to the FST.</div></blockquote>
</dd></dl>

</div>
<div class="section" id="module-cam.sgnmt.decoding.greedy">
<span id="cam-sgnmt-decoding-greedy-module"></span><h2>cam.sgnmt.decoding.greedy module<a class="headerlink" href="#module-cam.sgnmt.decoding.greedy" title="Permalink to this headline">¶</a></h2>
<p>Implementation of the greedy search strategy</p>
<dl class="class">
<dt id="cam.sgnmt.decoding.greedy.GreedyDecoder">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.greedy.</code><code class="descname">GreedyDecoder</code><span class="sig-paren">(</span><em>decoder_args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/greedy.html#GreedyDecoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.greedy.GreedyDecoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.core.Decoder" title="cam.sgnmt.decoding.core.Decoder"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.core.Decoder</span></code></a></p>
<p>The greedy decoder does not revise decisions and therefore does
not have to maintain predictor states. Therefore, this
implementation is particularly simple and can be used as template
for more complex decoders. The greedy decoder can be imitated with
the <code class="docutils literal"><span class="pre">BeamDecoder</span></code> with beam size 1.</p>
<p>Initialize the greedy decoder.</p>
<dl class="method">
<dt id="cam.sgnmt.decoding.greedy.GreedyDecoder.decode">
<code class="descname">decode</code><span class="sig-paren">(</span><em>src_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/greedy.html#GreedyDecoder.decode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.greedy.GreedyDecoder.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decode a single source sentence in a greedy way: Always take
the highest scoring word as next word and proceed to the next
position. This makes it possible to decode without using the
predictors <code class="docutils literal"><span class="pre">get_state()</span></code> and <code class="docutils literal"><span class="pre">set_state()</span></code> methods as we
do not have to keep track of predictor states.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>src_sentence</strong> (<em>list</em>) &#8211; List of source word ids without &lt;S&gt; or
&lt;/S&gt; which make up the source sentence</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">list. A list of a single best <code class="docutils literal"><span class="pre">Hypothesis</span></code> instance.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-cam.sgnmt.decoding.heuristics">
<span id="cam-sgnmt-decoding-heuristics-module"></span><h2>cam.sgnmt.decoding.heuristics module<a class="headerlink" href="#module-cam.sgnmt.decoding.heuristics" title="Permalink to this headline">¶</a></h2>
<p>Heuristics are used during A* decoding and are called to compose the
estimated look ahead costs. The <code class="docutils literal"><span class="pre">Heuristic</span></code> super class is defined
in the <code class="docutils literal"><span class="pre">core</span></code> module.</p>
<dl class="class">
<dt id="cam.sgnmt.decoding.heuristics.GreedyHeuristic">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.heuristics.</code><code class="descname">GreedyHeuristic</code><span class="sig-paren">(</span><em>decoder_args</em>, <em>cache_estimates=True</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/heuristics.html#GreedyHeuristic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.heuristics.GreedyHeuristic" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.core.Heuristic" title="cam.sgnmt.decoding.core.Heuristic"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.core.Heuristic</span></code></a></p>
<p>This heuristic performs greedy decoding to get future cost
estimates. This is expensive but can lead to very close estimates.</p>
<p>Creates a new <code class="docutils literal"><span class="pre">GreedyHeuristic</span></code> instance. The greedy
heuristic performs full greedy decoding from the current
state to get accurate cost estimates. However, this can be very
expensive.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>decoder_args</strong> (<em>object</em>) &#8211; Decoder configuration passed through
from the configuration API.</li>
<li><strong>cache_estimates</strong> (<em>bool</em>) &#8211; Set to true to enable a cache for
predictor states which have been
visited during the greedy decoding.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cam.sgnmt.decoding.heuristics.GreedyHeuristic.estimate_future_cost">
<code class="descname">estimate_future_cost</code><span class="sig-paren">(</span><em>hypo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/heuristics.html#GreedyHeuristic.estimate_future_cost"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.heuristics.GreedyHeuristic.estimate_future_cost" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate the future cost by full greedy decoding. If
<code class="docutils literal"><span class="pre">self.cache_estimates</span></code> is enabled, check cache first</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.heuristics.GreedyHeuristic.estimate_future_cost_with_cache">
<code class="descname">estimate_future_cost_with_cache</code><span class="sig-paren">(</span><em>hypo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/heuristics.html#GreedyHeuristic.estimate_future_cost_with_cache"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.heuristics.GreedyHeuristic.estimate_future_cost_with_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Enabled cache...</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.heuristics.GreedyHeuristic.estimate_future_cost_without_cache">
<code class="descname">estimate_future_cost_without_cache</code><span class="sig-paren">(</span><em>hypo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/heuristics.html#GreedyHeuristic.estimate_future_cost_without_cache"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.heuristics.GreedyHeuristic.estimate_future_cost_without_cache" title="Permalink to this definition">¶</a></dt>
<dd><p>Disabled cache...</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.heuristics.GreedyHeuristic.initialize">
<code class="descname">initialize</code><span class="sig-paren">(</span><em>src_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/heuristics.html#GreedyHeuristic.initialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.heuristics.GreedyHeuristic.initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the cache.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.heuristics.GreedyHeuristic.set_predictors">
<code class="descname">set_predictors</code><span class="sig-paren">(</span><em>predictors</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/heuristics.html#GreedyHeuristic.set_predictors"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.heuristics.GreedyHeuristic.set_predictors" title="Permalink to this definition">¶</a></dt>
<dd><p>Override <code class="docutils literal"><span class="pre">Decoder.set_predictors</span></code> to redirect the
predictors to <code class="docutils literal"><span class="pre">self.decoder</span></code></p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.decoding.heuristics.LastTokenHeuristic">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.heuristics.</code><code class="descname">LastTokenHeuristic</code><a class="reference internal" href="_modules/cam/sgnmt/decoding/heuristics.html#LastTokenHeuristic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.heuristics.LastTokenHeuristic" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.core.Heuristic" title="cam.sgnmt.decoding.core.Heuristic"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.core.Heuristic</span></code></a></p>
<p>This heuristic reflects the score of the last token in the
translation prefix only, ie. not the accumulated score. Using this
with pure_heuristic_estimates leads to expanding the partial
hypothesis with the end token with the best individual score. This
can be useful in search spaces in which bad translation prefixes
imply low individual scores later.</p>
<p>Creates a heuristic without predictors.</p>
<dl class="method">
<dt id="cam.sgnmt.decoding.heuristics.LastTokenHeuristic.estimate_future_cost">
<code class="descname">estimate_future_cost</code><span class="sig-paren">(</span><em>hypo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/heuristics.html#LastTokenHeuristic.estimate_future_cost"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.heuristics.LastTokenHeuristic.estimate_future_cost" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the negative score of the last token in hypo.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.heuristics.LastTokenHeuristic.initialize">
<code class="descname">initialize</code><span class="sig-paren">(</span><em>src_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/heuristics.html#LastTokenHeuristic.initialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.heuristics.LastTokenHeuristic.initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Empty method.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.decoding.heuristics.PredictorHeuristic">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.heuristics.</code><code class="descname">PredictorHeuristic</code><a class="reference internal" href="_modules/cam/sgnmt/decoding/heuristics.html#PredictorHeuristic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.heuristics.PredictorHeuristic" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.core.Heuristic" title="cam.sgnmt.decoding.core.Heuristic"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.core.Heuristic</span></code></a></p>
<p>The predictor heuristic relies on the
<code class="docutils literal"><span class="pre">estimate_future_costs()</span></code> implementation of the predictors. Use
this heuristic to access predictor specific future cost functions,
e.g. shortest path for the fst predictor.</p>
<p>Creates a heuristic without predictors.</p>
<dl class="method">
<dt id="cam.sgnmt.decoding.heuristics.PredictorHeuristic.estimate_future_cost">
<code class="descname">estimate_future_cost</code><span class="sig-paren">(</span><em>hypo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/heuristics.html#PredictorHeuristic.estimate_future_cost"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.heuristics.PredictorHeuristic.estimate_future_cost" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the weighted sum of predictor estimates.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.heuristics.PredictorHeuristic.initialize">
<code class="descname">initialize</code><span class="sig-paren">(</span><em>src_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/heuristics.html#PredictorHeuristic.initialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.heuristics.PredictorHeuristic.initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls <code class="docutils literal"><span class="pre">initialize_heuristic()</span></code> on all predictors.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.heuristics.PredictorHeuristic.notify">
<code class="descname">notify</code><span class="sig-paren">(</span><em>message</em>, <em>message_type=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/heuristics.html#PredictorHeuristic.notify"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.heuristics.PredictorHeuristic.notify" title="Permalink to this definition">¶</a></dt>
<dd><p>This heuristic passes through notifications to the
predictors.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.decoding.heuristics.ScorePerWordHeuristic">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.heuristics.</code><code class="descname">ScorePerWordHeuristic</code><a class="reference internal" href="_modules/cam/sgnmt/decoding/heuristics.html#ScorePerWordHeuristic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.heuristics.ScorePerWordHeuristic" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.core.Heuristic" title="cam.sgnmt.decoding.core.Heuristic"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.core.Heuristic</span></code></a></p>
<p>Using this heuristic results in length normalized scores instead
of the pure sum of predictor scores for a partial hypothesis.
Therefore, it is not a heuristic like in the classical A* sense.
Instead, using the A* decoder with this heuristic simulates beam
search which always keeps the hypotheses with the best per word
scores.</p>
<p>Creates a heuristic without predictors.</p>
<dl class="method">
<dt id="cam.sgnmt.decoding.heuristics.ScorePerWordHeuristic.estimate_future_cost">
<code class="descname">estimate_future_cost</code><span class="sig-paren">(</span><em>hypo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/heuristics.html#ScorePerWordHeuristic.estimate_future_cost"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.heuristics.ScorePerWordHeuristic.estimate_future_cost" title="Permalink to this definition">¶</a></dt>
<dd><p>A* will put <code class="docutils literal"><span class="pre">cost-score</span></code> on the heap. In order to simulate
length normalized beam search, we want to use <code class="docutils literal"><span class="pre">-score/length</span></code>
as partial hypothesis score. Therefore, this method returns
<code class="docutils literal"><span class="pre">-score/length</span> <span class="pre">+</span> <span class="pre">score</span></code></p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.heuristics.ScorePerWordHeuristic.initialize">
<code class="descname">initialize</code><span class="sig-paren">(</span><em>src_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/heuristics.html#ScorePerWordHeuristic.initialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.heuristics.ScorePerWordHeuristic.initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Empty method.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.decoding.heuristics.StatsHeuristic">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.heuristics.</code><code class="descname">StatsHeuristic</code><span class="sig-paren">(</span><em>heuristic_scores_file=''</em>, <em>collect_stats_strategy='best'</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/heuristics.html#StatsHeuristic"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.heuristics.StatsHeuristic" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.core.Heuristic" title="cam.sgnmt.decoding.core.Heuristic"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.core.Heuristic</span></code></a></p>
<p>This heuristic is based on the sum of unigram costs of consumed
words. Unigram statistics are collected via a <code class="docutils literal"><span class="pre">UnigramTable</span></code>.</p>
<p>Creates a new <code class="docutils literal"><span class="pre">StatsHeuristic</span></code> instance. The constructor
initializes the unigram table.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>heuristic_scores_file</strong> (<em>string</em>) &#8211; Path to the unigram scores
which are used if this
predictor estimates future
costs</li>
<li><strong>collect_stats_strategy</strong> (<em>string</em>) &#8211; best, full, or all. Defines
how unigram estimates are
collected for heuristic</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cam.sgnmt.decoding.heuristics.StatsHeuristic.estimate_future_cost">
<code class="descname">estimate_future_cost</code><span class="sig-paren">(</span><em>hypo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/heuristics.html#StatsHeuristic.estimate_future_cost"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.heuristics.StatsHeuristic.estimate_future_cost" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns the sum of heuristic unigram estimates of the words
in the translation prefix of <code class="docutils literal"><span class="pre">hypo</span></code>. Combined with the hypo
score, this leads to using the ratio between actual hypo score
and an idealistic score (product of unigrams) to discriminate
partial hypotheses.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.heuristics.StatsHeuristic.initialize">
<code class="descname">initialize</code><span class="sig-paren">(</span><em>src_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/heuristics.html#StatsHeuristic.initialize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.heuristics.StatsHeuristic.initialize" title="Permalink to this definition">¶</a></dt>
<dd><p>Calls <code class="docutils literal"><span class="pre">reset</span></code> to reset collected statistics from previous
sentences</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>src_sentence</strong> (<em>list</em>) &#8211; Not used</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.heuristics.StatsHeuristic.notify">
<code class="descname">notify</code><span class="sig-paren">(</span><em>message</em>, <em>message_type=1</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/heuristics.html#StatsHeuristic.notify"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.heuristics.StatsHeuristic.notify" title="Permalink to this definition">¶</a></dt>
<dd><p>Passing through to the unigram table <code class="docutils literal"><span class="pre">self.estimates</span></code>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-cam.sgnmt.decoding.interpolation">
<span id="cam-sgnmt-decoding-interpolation-module"></span><h2>cam.sgnmt.decoding.interpolation module<a class="headerlink" href="#module-cam.sgnmt.decoding.interpolation" title="Permalink to this headline">¶</a></h2>
<p>This module contains interpolation strategies. This is commonly
specified via the &#8211;interpolation_strategy parameter.</p>
<dl class="class">
<dt id="cam.sgnmt.decoding.interpolation.EntropyInterpolationStrategy">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.interpolation.</code><code class="descname">EntropyInterpolationStrategy</code><span class="sig-paren">(</span><em>vocab_size</em>, <em>cross_entropy</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/interpolation.html#EntropyInterpolationStrategy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.interpolation.EntropyInterpolationStrategy" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.interpolation.InterpolationStrategy" title="cam.sgnmt.decoding.interpolation.InterpolationStrategy"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.interpolation.InterpolationStrategy</span></code></a></p>
<p>The entropy interpolation strategy assigns weights to predictors
according the entropy of their posteriors to the other posteriors.
We first build a n x n square matrix of (cross-)entropies between
all predictors, and then weight according the row sums.</p>
<p>We assume that predictor weights are log probabilities.</p>
<p>Constructor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>vocab_size</strong> (<em>int</em>) &#8211; Vocabulary size</li>
<li><strong>cross_entropy</strong> (<em>bool</em>) &#8211; If true, use cross entropy to other
predictors. Otherwise, just use
predictor distribution entropy.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cam.sgnmt.decoding.interpolation.EntropyInterpolationStrategy.find_weights">
<code class="descname">find_weights</code><span class="sig-paren">(</span><em>pred_weights</em>, <em>non_zero_words</em>, <em>posteriors</em>, <em>unk_probs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/interpolation.html#EntropyInterpolationStrategy.find_weights"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.interpolation.EntropyInterpolationStrategy.find_weights" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.decoding.interpolation.FixedInterpolationStrategy">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.interpolation.</code><code class="descname">FixedInterpolationStrategy</code><a class="reference internal" href="_modules/cam/sgnmt/decoding/interpolation.html#FixedInterpolationStrategy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.interpolation.FixedInterpolationStrategy" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.interpolation.InterpolationStrategy" title="cam.sgnmt.decoding.interpolation.InterpolationStrategy"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.interpolation.InterpolationStrategy</span></code></a></p>
<p>Null-object (GoF design pattern) implementation.</p>
<dl class="method">
<dt id="cam.sgnmt.decoding.interpolation.FixedInterpolationStrategy.find_weights">
<code class="descname">find_weights</code><span class="sig-paren">(</span><em>pred_weights</em>, <em>non_zero_words</em>, <em>posteriors</em>, <em>unk_probs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/interpolation.html#FixedInterpolationStrategy.find_weights"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.interpolation.FixedInterpolationStrategy.find_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns <code class="docutils literal"><span class="pre">pred_weights</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.interpolation.FixedInterpolationStrategy.is_fixed">
<code class="descname">is_fixed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/interpolation.html#FixedInterpolationStrategy.is_fixed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.interpolation.FixedInterpolationStrategy.is_fixed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.decoding.interpolation.InterpolationStrategy">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.interpolation.</code><code class="descname">InterpolationStrategy</code><a class="reference internal" href="_modules/cam/sgnmt/decoding/interpolation.html#InterpolationStrategy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.interpolation.InterpolationStrategy" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Base class for interpolation strategies.</p>
<dl class="method">
<dt id="cam.sgnmt.decoding.interpolation.InterpolationStrategy.find_weights">
<code class="descname">find_weights</code><span class="sig-paren">(</span><em>pred_weights</em>, <em>non_zero_words</em>, <em>posteriors</em>, <em>unk_probs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/interpolation.html#InterpolationStrategy.find_weights"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.interpolation.InterpolationStrategy.find_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Find interpolation weights for the current prediction.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>pred_weights</strong> (<em>list</em>) &#8211; A priori predictor weights</li>
<li><strong>non_zero_words</strong> (<em>set</em>) &#8211; All words with positive probability</li>
<li><strong>posteriors</strong> &#8211; Predictor posterior distributions calculated
with <code class="docutils literal"><span class="pre">predict_next()</span></code></li>
<li><strong>unk_probs</strong> &#8211; UNK probabilities of the predictors, calculated
with <code class="docutils literal"><span class="pre">get_unk_probability</span></code></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list of floats. The predictor weights for this prediction.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="docutils literal"><span class="pre">NotImplementedError</span></code> &#8211; if the method is not implemented</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.interpolation.InterpolationStrategy.is_fixed">
<code class="descname">is_fixed</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/interpolation.html#InterpolationStrategy.is_fixed"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.interpolation.InterpolationStrategy.is_fixed" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.decoding.interpolation.MoEInterpolationStrategy">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.interpolation.</code><code class="descname">MoEInterpolationStrategy</code><span class="sig-paren">(</span><em>num_experts</em>, <em>args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/interpolation.html#MoEInterpolationStrategy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.interpolation.MoEInterpolationStrategy" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.interpolation.InterpolationStrategy" title="cam.sgnmt.decoding.interpolation.InterpolationStrategy"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.interpolation.InterpolationStrategy</span></code></a></p>
<p>This class implements a predictor-level Mixture of Experts (MoE)
model. In this scenario, we have a neural model which predicts
predictor weights from the predictor outputs. See the sgnmt_moe
project on how to train this gating network with TensorFlow.</p>
<p>Creates the computation graph of the MoE network and loads
the checkpoint file. Following fields are fetched from <code class="docutils literal"><span class="pre">args</span></code></p>
<blockquote>
<div><dl class="docutils">
<dt>moe_config: Comma-separated &lt;key&gt;=&lt;value&gt; pairs specifying</dt>
<dd>the MoE network. See the command line arguments of
sgnmt_moe for a full description. Available keys:
vocab_size, embed_size, activation, hidden_layer_size,
preprocessing.</dd>
</dl>
<p>moe_checkpoint_dir (string): Checkpoint directory
n_cpu_threads (int): Number of CPU threads for TensorFlow</p>
</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>num_experts</strong> (<em>int</em>) &#8211; Number of predictors under the MoE model</li>
<li><strong>args</strong> (<em>object</em>) &#8211; SGNMT configuration object</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cam.sgnmt.decoding.interpolation.MoEInterpolationStrategy.find_weights">
<code class="descname">find_weights</code><span class="sig-paren">(</span><em>pred_weights</em>, <em>non_zero_words</em>, <em>posteriors</em>, <em>unk_probs</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/interpolation.html#MoEInterpolationStrategy.find_weights"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.interpolation.MoEInterpolationStrategy.find_weights" title="Permalink to this definition">¶</a></dt>
<dd><p>Runs the MoE model to find interpolation weights.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>pred_weights</strong> (<em>list</em>) &#8211; A prior predictor weights</li>
<li><strong>non_zero_words</strong> (<em>set</em>) &#8211; All words with positive probability</li>
<li><strong>posteriors</strong> &#8211; Predictor posterior distributions calculated
with <code class="docutils literal"><span class="pre">predict_next()</span></code></li>
<li><strong>unk_probs</strong> &#8211; UNK probabilities of the predictors, calculated
with <code class="docutils literal"><span class="pre">get_unk_probability</span></code></li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first">list of floats. The predictor weights for this prediction.</p>
</td>
</tr>
<tr class="field-odd field"><th class="field-name">Raises:</th><td class="field-body"><p class="first last"><code class="docutils literal"><span class="pre">NotImplementedError</span></code> &#8211; if the method is not implemented</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-cam.sgnmt.decoding.lenbeam">
<span id="cam-sgnmt-decoding-lenbeam-module"></span><h2>cam.sgnmt.decoding.lenbeam module<a class="headerlink" href="#module-cam.sgnmt.decoding.lenbeam" title="Permalink to this headline">¶</a></h2>
<p>Implementation of the lenbeam search strategy</p>
<dl class="class">
<dt id="cam.sgnmt.decoding.lenbeam.LengthBeamDecoder">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.lenbeam.</code><code class="descname">LengthBeamDecoder</code><span class="sig-paren">(</span><em>decoder_args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/lenbeam.html#LengthBeamDecoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.lenbeam.LengthBeamDecoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.core.Decoder" title="cam.sgnmt.decoding.core.Decoder"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.core.Decoder</span></code></a></p>
<p>This beam decoder variant finds hypotheses for all lengths up
to the maximum hypo length. At each time step, all EOS extensions
are added to the results set.</p>
<p>Creates a new beam decoder instance. The following values
are fetched from <cite>decoder_args</cite>:</p>
<blockquote>
<div><dl class="docutils">
<dt>beam (int): Absolute beam size. A beam of 12 means</dt>
<dd>that we keep track of 12 active hypotheses</dd>
</dl>
</div></blockquote>
<dl class="method">
<dt id="cam.sgnmt.decoding.lenbeam.LengthBeamDecoder.decode">
<code class="descname">decode</code><span class="sig-paren">(</span><em>src_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/lenbeam.html#LengthBeamDecoder.decode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.lenbeam.LengthBeamDecoder.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decodes a single source sentence using beam search.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="module-cam.sgnmt.decoding.mbrbeam">
<span id="cam-sgnmt-decoding-mbrbeam-module"></span><h2>cam.sgnmt.decoding.mbrbeam module<a class="headerlink" href="#module-cam.sgnmt.decoding.mbrbeam" title="Permalink to this headline">¶</a></h2>
<p>This beam search uses an MBR-based criterion at each time step.</p>
<dl class="class">
<dt id="cam.sgnmt.decoding.mbrbeam.MBRBeamDecoder">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.mbrbeam.</code><code class="descname">MBRBeamDecoder</code><span class="sig-paren">(</span><em>decoder_args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/mbrbeam.html#MBRBeamDecoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.mbrbeam.MBRBeamDecoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.beam.BeamDecoder" title="cam.sgnmt.decoding.beam.BeamDecoder"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.beam.BeamDecoder</span></code></a></p>
<p>The MBR-based beam decoder does not select the n most likely
hypotheses in each timestep. Instead, it tries to find the translation
with the best expected BLEU. Two strategies control the behavior of
mbrbeam: the <cite>evidence_strategy</cite> and the <cite>selection_strategy</cite>.
Available evidence strategies:</p>
<blockquote>
<div><dl class="docutils">
<dt>&#8216;renorm&#8217;: Only makes use of the n-best expansions of the hypos in the</dt>
<dd>current beam. It renormalizes the scores, and count ngrams in
the n^2 hypos.</dd>
<dt>&#8216;maxent&#8217;: Applies the MaxEnt rule to the evidence space. It makes use of</dt>
<dd>all partial hypos seen so far and updates its belief about the
probability of an ngram based on that. Following MaxEnt we
assume that translations outside the explored space are
uniformly distributed.</dd>
</dl>
</div></blockquote>
<dl class="docutils">
<dt>Available selection strategies:</dt>
<dd><p class="first">&#8216;bleu&#8217;: Select the n hypotheses with the best expected BLEU
&#8216;oracle_bleu&#8217;: Select&#8217;a subset with n elements which maximizes the</p>
<blockquote class="last">
<div>expected maximum BLEU of one of the selected hypos. In
other words, we optimize the oracle BLEU of the n-best
list at each time step, where the n-best list consists
of the active hypotheses in the beam.</div></blockquote>
</dd>
</dl>
<p>Creates a new MBR beam decoder instance. We explicitly
set early stopping to False since risk-free pruning is not
supported by the MBR-based beam decoder. The MBR-based
decoder fetches the following fields from <code class="docutils literal"><span class="pre">decoder_args</span></code>:</p>
<blockquote>
<div>min_ngram_order (int): Minimum n-gram order
max_ngram_order (int): Maximum n-gram order
mbrbeam_smooth_factor (float): Smoothing factor for evidence space
mbrbeam_evidence_strategy (String): Evidence strategy
mbrbeam_selection_strategy (String): Selection strategy</div></blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>decoder_args</strong> (<em>object</em>) &#8211; Decoder configuration passed through
from the configuration API.</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cam.sgnmt.decoding.mbrbeam.MBRBeamDecoder.decode">
<code class="descname">decode</code><span class="sig-paren">(</span><em>src_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/mbrbeam.html#MBRBeamDecoder.decode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.mbrbeam.MBRBeamDecoder.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decodes a single source sentence using beam search.</p>
</dd></dl>

</dd></dl>

<dl class="function">
<dt id="cam.sgnmt.decoding.mbrbeam.is_sublist">
<code class="descclassname">cam.sgnmt.decoding.mbrbeam.</code><code class="descname">is_sublist</code><span class="sig-paren">(</span><em>needle</em>, <em>haystack</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/mbrbeam.html#is_sublist"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.mbrbeam.is_sublist" title="Permalink to this definition">¶</a></dt>
<dd><p>True if needle is a sublist of haystack, False otherwise.
Could be more efficient with Boyer-Moore-Horspool but our needles
are usually ngrams (ie. short), so this is a O(nm) implementation.</p>
</dd></dl>

</div>
<div class="section" id="module-cam.sgnmt.decoding.multisegbeam">
<span id="cam-sgnmt-decoding-multisegbeam-module"></span><h2>cam.sgnmt.decoding.multisegbeam module<a class="headerlink" href="#module-cam.sgnmt.decoding.multisegbeam" title="Permalink to this headline">¶</a></h2>
<p>Implementation of beam search for predictors with multiple
tokenizations.</p>
<dl class="class">
<dt id="cam.sgnmt.decoding.multisegbeam.Continuation">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.multisegbeam.</code><code class="descname">Continuation</code><span class="sig-paren">(</span><em>parent_hypo</em>, <em>pred_stubs</em>, <em>key=''</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/multisegbeam.html#Continuation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.multisegbeam.Continuation" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>A continuation is a partial hypothesis plus the next word. A
continuation can be incomplete if predictors use finer grained
tokenization and the score is not final yet.</p>
<p>Create a new continuation.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>parent_hypo</strong> (<a class="reference internal" href="#cam.sgnmt.decoding.core.PartialHypothesis" title="cam.sgnmt.decoding.core.PartialHypothesis"><em>PartialHypothesis</em></a>) &#8211; hypo object encoding the
state at the last word
boundary</li>
<li><strong>pred_stubs</strong> (<em>list</em>) &#8211; List of <code class="docutils literal"><span class="pre">PredictorStub</span></code> objects, one
for each predictor</li>
<li><strong>key</strong> (<em>string</em>) &#8211; The lead key for this continuation. All stubs
must be consistent with this key</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cam.sgnmt.decoding.multisegbeam.Continuation.calculate_score">
<code class="descname">calculate_score</code><span class="sig-paren">(</span><em>pred_weights</em>, <em>defaults=[]</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/multisegbeam.html#Continuation.calculate_score"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.multisegbeam.Continuation.calculate_score" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the full word score for this continuation using
the predictor stub scores.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>pred_weights</strong> (<em>list</em>) &#8211; Predictor weights. Length of this list
must match the number of stubs</li>
<li><strong>defaults</strong> (<em>list</em>) &#8211; Score which should be used if a predictor
stub is set to None</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">float. Full score of this continuation, or an optimistic
estimate if the continuation is not complete.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.multisegbeam.Continuation.expand">
<code class="descname">expand</code><span class="sig-paren">(</span><em>decoder</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/multisegbeam.html#Continuation.expand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.multisegbeam.Continuation.expand" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.multisegbeam.Continuation.generate_expanded_hypo">
<code class="descname">generate_expanded_hypo</code><span class="sig-paren">(</span><em>decoder</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/multisegbeam.html#Continuation.generate_expanded_hypo"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.multisegbeam.Continuation.generate_expanded_hypo" title="Permalink to this definition">¶</a></dt>
<dd><p>This can be used to create a new <code class="docutils literal"><span class="pre">PartialHypothesis</span></code> which
reflects the state after this continuation. This involves
expanding the history by <code class="docutils literal"><span class="pre">word</span></code>, updating score and <a href="#id1"><span class="problematic" id="id2">score_</span></a>
breakdown, and consuming the last tokens in the stub to save
the final predictor states. If the continuation is complete,
this will result in a new word level hypothesis. If not, the
generated hypo will indicate an incomplete word at the last
position by using the word ID -1.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.multisegbeam.Continuation.is_complete">
<code class="descname">is_complete</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/multisegbeam.html#Continuation.is_complete"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.multisegbeam.Continuation.is_complete" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if all predictor stubs are completed, i.e.
the continuation can be mapped unambiguously to a word and the
score is final.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.decoding.multisegbeam.EOWTokenizer">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.multisegbeam.</code><code class="descname">EOWTokenizer</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/multisegbeam.html#EOWTokenizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.multisegbeam.EOWTokenizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.multisegbeam.Tokenizer" title="cam.sgnmt.decoding.multisegbeam.Tokenizer"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.multisegbeam.Tokenizer</span></code></a></p>
<p>This tokenizer reads word maps with explicit &lt;/w&gt; endings. This
can be used for subword unit based tokenizers.</p>
<dl class="method">
<dt id="cam.sgnmt.decoding.multisegbeam.EOWTokenizer.is_word_begin_token">
<code class="descname">is_word_begin_token</code><span class="sig-paren">(</span><em>token</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/multisegbeam.html#EOWTokenizer.is_word_begin_token"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.multisegbeam.EOWTokenizer.is_word_begin_token" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.multisegbeam.EOWTokenizer.key2tokens">
<code class="descname">key2tokens</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/multisegbeam.html#EOWTokenizer.key2tokens"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.multisegbeam.EOWTokenizer.key2tokens" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.multisegbeam.EOWTokenizer.tokens2key">
<code class="descname">tokens2key</code><span class="sig-paren">(</span><em>tokens</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/multisegbeam.html#EOWTokenizer.tokens2key"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.multisegbeam.EOWTokenizer.tokens2key" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.decoding.multisegbeam.MixedTokenizer">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.multisegbeam.</code><code class="descname">MixedTokenizer</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/multisegbeam.html#MixedTokenizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.multisegbeam.MixedTokenizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.multisegbeam.Tokenizer" title="cam.sgnmt.decoding.multisegbeam.Tokenizer"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.multisegbeam.Tokenizer</span></code></a></p>
<p>This tokenizer allows to mix word- and character-level
tokenizations like proposed by Wu et al. (2016). Words with
&lt;b&gt;, &lt;m&gt;, and &lt;e&gt; prefixes are treated as character-level
tokens, all others are completed word-level tokens</p>
<dl class="method">
<dt id="cam.sgnmt.decoding.multisegbeam.MixedTokenizer.is_word_begin_token">
<code class="descname">is_word_begin_token</code><span class="sig-paren">(</span><em>token</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/multisegbeam.html#MixedTokenizer.is_word_begin_token"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.multisegbeam.MixedTokenizer.is_word_begin_token" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.multisegbeam.MixedTokenizer.key2tokens">
<code class="descname">key2tokens</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/multisegbeam.html#MixedTokenizer.key2tokens"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.multisegbeam.MixedTokenizer.key2tokens" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.multisegbeam.MixedTokenizer.tokens2key">
<code class="descname">tokens2key</code><span class="sig-paren">(</span><em>tokens</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/multisegbeam.html#MixedTokenizer.tokens2key"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.multisegbeam.MixedTokenizer.tokens2key" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.decoding.multisegbeam.MultisegBeamDecoder">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.multisegbeam.</code><code class="descname">MultisegBeamDecoder</code><span class="sig-paren">(</span><em>decoder_args</em>, <em>hypo_recombination</em>, <em>beam_size</em>, <em>tokenizations</em>, <em>early_stopping=True</em>, <em>max_word_len=25</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/multisegbeam.html#MultisegBeamDecoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.multisegbeam.MultisegBeamDecoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.core.Decoder" title="cam.sgnmt.decoding.core.Decoder"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.core.Decoder</span></code></a></p>
<p>This is a version of beam search which can handle predictors
with differing tokenizations. We assume that all tokenizations are
consistent with words, i.e. no token crosses word boundaries. The
search simulates beam search on the word level. At each time step,
we keep the n best hypotheses on the word level. Predictor scores
on finer-grained tokens are collapsed into a single score s.t. they
can be combined with scores from other predictors. This decoder can
produce words without entry in the word map. In this case, words
are added to <code class="docutils literal"><span class="pre">io.trg_wmap</span></code>. Consider using the <code class="docutils literal"><span class="pre">output_chars</span></code>
option to avoid dealing with the updated word map in the output.</p>
<p>Creates a new beam decoder instance for predictors with
multiple tokenizations.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>decoder_args</strong> (<em>object</em>) &#8211; Decoder configuration passed through
from the configuration API.</li>
<li><strong>hypo_recombination</strong> (<em>bool</em>) &#8211; Activates hypo recombination</li>
<li><strong>beam_size</strong> (<em>int</em>) &#8211; Absolute beam size. A beam of 12 means
that we keep track of 12 active hypothesis</li>
<li><strong>tokenizations</strong> (<em>string</em>) &#8211; Comma separated strings describing
the predictor tokenizations</li>
<li><strong>early_stopping</strong> (<em>bool</em>) &#8211; If true, we stop when the best
scoring hypothesis ends with &lt;/S&gt;.
If false, we stop when all hypotheses
end with &lt;/S&gt;. Enable if you are
only interested in the single best
decoding result. If you want to
create full 12-best lists, disable</li>
<li><strong>max_word_len</strong> (<em>int</em>) &#8211; Maximum length of a single word</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cam.sgnmt.decoding.multisegbeam.MultisegBeamDecoder.decode">
<code class="descname">decode</code><span class="sig-paren">(</span><em>src_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/multisegbeam.html#MultisegBeamDecoder.decode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.multisegbeam.MultisegBeamDecoder.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decodes a single source sentence using beam search.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.decoding.multisegbeam.PredictorStub">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.multisegbeam.</code><code class="descname">PredictorStub</code><span class="sig-paren">(</span><em>tokens</em>, <em>pred_state</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/multisegbeam.html#PredictorStub"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.multisegbeam.PredictorStub" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>A predictor stub models the state of a predictor given a
continuation.</p>
<p>Creates a new stub for a certain predictor.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>tokens</strong> (<em>list</em>) &#8211; List of token IDs which correspond to the
key</li>
<li><strong>pred_state</strong> (<em>object</em>) &#8211; Predictor state before consuming
the last token in <code class="docutils literal"><span class="pre">tokens</span></code></li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cam.sgnmt.decoding.multisegbeam.PredictorStub.expand">
<code class="descname">expand</code><span class="sig-paren">(</span><em>token</em>, <em>token_score</em>, <em>pred_state</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/multisegbeam.html#PredictorStub.expand"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.multisegbeam.PredictorStub.expand" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a new predictor stub by adding a (scored) token.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>token</strong> (<em>int</em>) &#8211; Token ID to add</li>
<li><strong>token_score</strong> (<em>float</em>) &#8211; Token score of the added token</li>
<li><strong>pred_state</strong> (<em>object</em>) &#8211; predictor state before consuming
the added token</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.multisegbeam.PredictorStub.has_full_score">
<code class="descname">has_full_score</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/multisegbeam.html#PredictorStub.has_full_score"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.multisegbeam.PredictorStub.has_full_score" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if the full token sequence has been scored with
the predictor, i.e. <code class="docutils literal"><span class="pre">self.score</span></code> is the final predictor
score.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.multisegbeam.PredictorStub.score_next">
<code class="descname">score_next</code><span class="sig-paren">(</span><em>token_score</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/multisegbeam.html#PredictorStub.score_next"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.multisegbeam.PredictorStub.score_next" title="Permalink to this definition">¶</a></dt>
<dd><p>Can be called when the continuation is expanded and the
score of the next token is available</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>token_score</strong> (<em>float</em>) &#8211; Predictor score of
self.tokens[self.score_pos]</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.decoding.multisegbeam.Tokenizer">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.multisegbeam.</code><code class="descname">Tokenizer</code><a class="reference internal" href="_modules/cam/sgnmt/decoding/multisegbeam.html#Tokenizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.multisegbeam.Tokenizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>A tokenizer translates between token sequences and string keys.
It is mainly responsible for matching token sequences from
different predictors together.</p>
<dl class="method">
<dt id="cam.sgnmt.decoding.multisegbeam.Tokenizer.is_word_begin_token">
<code class="descname">is_word_begin_token</code><span class="sig-paren">(</span><em>token</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/multisegbeam.html#Tokenizer.is_word_begin_token"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.multisegbeam.Tokenizer.is_word_begin_token" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if <code class="docutils literal"><span class="pre">token</span></code> is only allowed at word begins.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.multisegbeam.Tokenizer.key2tokens">
<code class="descname">key2tokens</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/multisegbeam.html#Tokenizer.key2tokens"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.multisegbeam.Tokenizer.key2tokens" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a key to a sequence of tokens. If this mapping is
ambiguous, return one of the shortest mappings. Use UNK to
match any (sub)string without token correspondence.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>key</strong> (<em>string</em>) &#8211; key to look up</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">list. List of token IDs</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.multisegbeam.Tokenizer.tokens2key">
<code class="descname">tokens2key</code><span class="sig-paren">(</span><em>tokens</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/multisegbeam.html#Tokenizer.tokens2key"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.multisegbeam.Tokenizer.tokens2key" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert a token sequence to a string key.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>tokens</strong> (<em>list</em>) &#8211; List of token IDs</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">String. The key for the token sequence</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.decoding.multisegbeam.WordMapper">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.multisegbeam.</code><code class="descname">WordMapper</code><a class="reference internal" href="_modules/cam/sgnmt/decoding/multisegbeam.html#WordMapper"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.multisegbeam.WordMapper" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<dl class="docutils">
<dt>This class is responsible for the mapping between keys and word</dt>
<dd>IDs. The multiseg beam search can produce words which are not in
the original word map. This mapper adds these words to</dd>
</dl>
<p><code class="docutils literal"><span class="pre">io.trg_wmap</span></code>.</p>
<blockquote>
<div>This class uses the GoF design pattern singleton.</div></blockquote>
<p>Creates a new mapper instance and synchronizes it with
<code class="docutils literal"><span class="pre">io.trg_wmap</span></code>.</p>
<dl class="staticmethod">
<dt id="cam.sgnmt.decoding.multisegbeam.WordMapper.get_singleton">
<em class="property">static </em><code class="descname">get_singleton</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/multisegbeam.html#WordMapper.get_singleton"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.multisegbeam.WordMapper.get_singleton" title="Permalink to this definition">¶</a></dt>
<dd><p>Get singleton instance of the word mapper. This method
implements lazy initialization.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Returns:</th><td class="field-body">WordMapper. Singleton <code class="docutils literal"><span class="pre">WordMapper</span></code> instance.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.multisegbeam.WordMapper.get_word_id">
<code class="descname">get_word_id</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/multisegbeam.html#WordMapper.get_word_id"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.multisegbeam.WordMapper.get_word_id" title="Permalink to this definition">¶</a></dt>
<dd><p>Finds a word ID for the given key. If no such key is in the
current word map, create a new entry in <code class="docutils literal"><span class="pre">io.trg_wmap</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>key</strong> (<em>string</em>) &#8211; key to look up</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">int. Word ID corresponding to <code class="docutils literal"><span class="pre">key</span></code>. Add new word ID if
the key cannot be found in <code class="docutils literal"><span class="pre">io.trg_wmap</span></code></td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="attribute">
<dt id="cam.sgnmt.decoding.multisegbeam.WordMapper.singleton">
<code class="descname">singleton</code><em class="property"> = None</em><a class="headerlink" href="#cam.sgnmt.decoding.multisegbeam.WordMapper.singleton" title="Permalink to this definition">¶</a></dt>
<dd><p>Singleton instance. Access via <code class="docutils literal"><span class="pre">get_singleton()</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.multisegbeam.WordMapper.synchronize">
<code class="descname">synchronize</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/multisegbeam.html#WordMapper.synchronize"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.multisegbeam.WordMapper.synchronize" title="Permalink to this definition">¶</a></dt>
<dd><p>Synchronizes the internal state of this mapper with
<code class="docutils literal"><span class="pre">io.trg_wmap</span></code>. This includes updating the reverse lookup
table and finding the lowest free word ID which can be assigned
to new words.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.decoding.multisegbeam.WordTokenizer">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.multisegbeam.</code><code class="descname">WordTokenizer</code><span class="sig-paren">(</span><em>path</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/multisegbeam.html#WordTokenizer"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.multisegbeam.WordTokenizer" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.multisegbeam.Tokenizer" title="cam.sgnmt.decoding.multisegbeam.Tokenizer"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.multisegbeam.Tokenizer</span></code></a></p>
<p>This tokenizer implements a purly word-level tokenization.
Keys are generated according a standard word map.</p>
<dl class="method">
<dt id="cam.sgnmt.decoding.multisegbeam.WordTokenizer.is_word_begin_token">
<code class="descname">is_word_begin_token</code><span class="sig-paren">(</span><em>token</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/multisegbeam.html#WordTokenizer.is_word_begin_token"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.multisegbeam.WordTokenizer.is_word_begin_token" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.multisegbeam.WordTokenizer.key2tokens">
<code class="descname">key2tokens</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/multisegbeam.html#WordTokenizer.key2tokens"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.multisegbeam.WordTokenizer.key2tokens" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.multisegbeam.WordTokenizer.tokens2key">
<code class="descname">tokens2key</code><span class="sig-paren">(</span><em>tokens</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/multisegbeam.html#WordTokenizer.tokens2key"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.multisegbeam.WordTokenizer.tokens2key" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="function">
<dt id="cam.sgnmt.decoding.multisegbeam.is_key_complete">
<code class="descclassname">cam.sgnmt.decoding.multisegbeam.</code><code class="descname">is_key_complete</code><span class="sig-paren">(</span><em>key</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/multisegbeam.html#is_key_complete"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.multisegbeam.is_key_complete" title="Permalink to this definition">¶</a></dt>
<dd><p>Returns true if the key is complete. Complete keys are marked
with a blank symbol at the end of the string. A complete key
corresponds to a full word, incomplete keys cannot be mapped to
word IDs.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>key</strong> (<em>string</em>) &#8211; The key</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body">bool. Return true if the last character in <code class="docutils literal"><span class="pre">key</span></code> is blank.</td>
</tr>
</tbody>
</table>
</dd></dl>

</div>
<div class="section" id="module-cam.sgnmt.decoding.predlimitbeam">
<span id="cam-sgnmt-decoding-predlimitbeam-module"></span><h2>cam.sgnmt.decoding.predlimitbeam module<a class="headerlink" href="#module-cam.sgnmt.decoding.predlimitbeam" title="Permalink to this headline">¶</a></h2>
<p>Implementation of beam search with explicit limits on culmulative
predictor scores at each node expansion.</p>
<dl class="class">
<dt id="cam.sgnmt.decoding.predlimitbeam.PredLimitBeamDecoder">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.predlimitbeam.</code><code class="descname">PredLimitBeamDecoder</code><span class="sig-paren">(</span><em>decoder_args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/predlimitbeam.html#PredLimitBeamDecoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.predlimitbeam.PredLimitBeamDecoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.beam.BeamDecoder" title="cam.sgnmt.decoding.beam.BeamDecoder"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.beam.BeamDecoder</span></code></a></p>
<p>Beam search variant with explicit limits on the culmulative
predictor scores at each node expansion.</p>
<p>Creates a new beam decoder with culmulative predictor score
limits. In addition to the constructor of <cite>BeamDecoder</cite>, the
following values are fetched from <cite>decoder_args</cite>:</p>
<blockquote>
<div><dl class="docutils">
<dt>pred_limits (string): Comma-separated list of predictor</dt>
<dd>score limits.</dd>
</dl>
</div></blockquote>
</dd></dl>

</div>
<div class="section" id="module-cam.sgnmt.decoding.restarting">
<span id="cam-sgnmt-decoding-restarting-module"></span><h2>cam.sgnmt.decoding.restarting module<a class="headerlink" href="#module-cam.sgnmt.decoding.restarting" title="Permalink to this headline">¶</a></h2>
<p>Implementation of the restarting search strategy</p>
<dl class="class">
<dt id="cam.sgnmt.decoding.restarting.RestartingChild">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.restarting.</code><code class="descname">RestartingChild</code><span class="sig-paren">(</span><em>word</em>, <em>score</em>, <em>score_breakdown</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/restarting.html#RestartingChild"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.restarting.RestartingChild" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Helper class for <code class="docutils literal"><span class="pre">RestartingDecoder`</span></code> representing a child
object in the search tree.</p>
<p>Creates a new child instance</p>
</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.decoding.restarting.RestartingDecoder">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.restarting.</code><code class="descname">RestartingDecoder</code><span class="sig-paren">(</span><em>decoder_args</em>, <em>hypo_recombination</em>, <em>max_expansions=0</em>, <em>low_memory_mode=True</em>, <em>node_cost_strategy='difference'</em>, <em>stochastic=False</em>, <em>always_single_step=False</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/restarting.html#RestartingDecoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.restarting.RestartingDecoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.core.Decoder" title="cam.sgnmt.decoding.core.Decoder"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.core.Decoder</span></code></a></p>
<p>This decoder first creates a path to the final node greedily.
Then, it looks for the node on this path with the smallest
difference between best and second best child, and restarts greedy
decoding from this point. In order to do so, it maintains a
priority queue of all visited nodes, which is ordered by the
difference between the worst expanded child and the best unexpanded
one. If this queue is empty, we have visited the best path. This
algorithm is similar to DFS but does not backtrace to the last call
of the recursive function but to the one which is most promising.</p>
<p>Note that this algorithm is exact. It tries to exploit the problem
characteristics of NMT search: Reloading predictor states can be
expensive, node expansion is even more expensive but for free from
visited nodes, and there is no good admissible heuristic.</p>
<p>Note2: Does not work properly if predictor scores can be positive
because of admissible pruning</p>
<p>Creates new Restarting decoder instance.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>decoder_args</strong> (<em>object</em>) &#8211; Decoder configuration passed through
from the configuration API.</li>
<li><strong>hypo_recombination</strong> (<em>bool</em>) &#8211; Activates hypo recombination</li>
<li><strong>max_expansions</strong> (<em>int</em>) &#8211; Maximum number of node expansions for
inadmissible pruning.</li>
<li><strong>low_memory_mode</strong> (<em>bool</em>) &#8211; Switch on low memory mode at cost
of some computational overhead as
the set of open nodes is reduced
after each decoding pass</li>
<li><strong>node_cost_strategy</strong> (<em>string</em>) &#8211; How to decide which node to
restart from next</li>
<li><strong>stochastic</strong> (<em>bool</em>) &#8211; If true, select the next node to restart
from randomly. If false, take the one
with the best node score</li>
<li><strong>always_single_step</strong> (<em>bool</em>) &#8211; If false, do greedy decoding
when restarting. If true, expand
the hypothesis only by a single
token</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="cam.sgnmt.decoding.restarting.RestartingDecoder.create_initial_node">
<code class="descname">create_initial_node</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/restarting.html#RestartingDecoder.create_initial_node"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.restarting.RestartingDecoder.create_initial_node" title="Permalink to this definition">¶</a></dt>
<dd><p>Create the root node for the search tree.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.restarting.RestartingDecoder.decode">
<code class="descname">decode</code><span class="sig-paren">(</span><em>src_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/restarting.html#RestartingDecoder.decode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.restarting.RestartingDecoder.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decodes a single source sentence using Restarting search.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.restarting.RestartingDecoder.greedy_decode">
<code class="descname">greedy_decode</code><span class="sig-paren">(</span><em>hypo</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/restarting.html#RestartingDecoder.greedy_decode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.restarting.RestartingDecoder.greedy_decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Helper function for greedy decoding from a certain point in
the search tree.</p>
</dd></dl>

</dd></dl>

<dl class="class">
<dt id="cam.sgnmt.decoding.restarting.RestartingNode">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.restarting.</code><code class="descname">RestartingNode</code><span class="sig-paren">(</span><em>hypo</em>, <em>children</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/restarting.html#RestartingNode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.restarting.RestartingNode" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <code class="xref py py-class docutils literal"><span class="pre">object</span></code></p>
<p>Helper class for <code class="docutils literal"><span class="pre">RestartingDecoder`</span></code> representing a node
in the search tree.</p>
<p>Creates a new node instance</p>
</dd></dl>

</div>
<div class="section" id="module-cam.sgnmt.decoding.sepbeam">
<span id="cam-sgnmt-decoding-sepbeam-module"></span><h2>cam.sgnmt.decoding.sepbeam module<a class="headerlink" href="#module-cam.sgnmt.decoding.sepbeam" title="Permalink to this headline">¶</a></h2>
<p>Implementation of beam search which does not combine all predictor
scores but keeps only one predictor alive for each hypo in the
beam. Good for approximate and efficient ensembling.</p>
<dl class="class">
<dt id="cam.sgnmt.decoding.sepbeam.SepBeamDecoder">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.sepbeam.</code><code class="descname">SepBeamDecoder</code><span class="sig-paren">(</span><em>decoder_args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/sepbeam.html#SepBeamDecoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.sepbeam.SepBeamDecoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.beam.BeamDecoder" title="cam.sgnmt.decoding.beam.BeamDecoder"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.beam.BeamDecoder</span></code></a></p>
<p>This beam search implementation breaks with the predictor
abstraction via the <code class="docutils literal"><span class="pre">Decoder.apply_predictors()</span></code> and
<code class="docutils literal"><span class="pre">Decoder.consume()</span></code> interfaces. We do not use combined scores
of all predictors, but link single predictors to hypotheses in
the beam. On hypo expansion, we call <code class="docutils literal"><span class="pre">predict_next()</span></code> only on
this predictor. This is suitable for approximated ensembling as
it reduces the runtime nearly to a single system run.</p>
<p>Note that <code class="docutils literal"><span class="pre">PartialHypothesis.predictor_states</span></code> holds a list
with <code class="docutils literal"><span class="pre">None</span></code> objects except for one position.</p>
<p>Also note that predictor weights are ignored for this decoding
strategy.</p>
<p>Creates a new beam decoder instance for system level
combination. See the docstring of the BeamDecoder constructor
for a description of which arguments are fetched from
<cite>decoder_args</cite>.</p>
</dd></dl>

</div>
<div class="section" id="module-cam.sgnmt.decoding.syncbeam">
<span id="cam-sgnmt-decoding-syncbeam-module"></span><h2>cam.sgnmt.decoding.syncbeam module<a class="headerlink" href="#module-cam.sgnmt.decoding.syncbeam" title="Permalink to this headline">¶</a></h2>
<p>Implementation of beam search with explicit synchronization symbol</p>
<dl class="class">
<dt id="cam.sgnmt.decoding.syncbeam.SyncBeamDecoder">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.syncbeam.</code><code class="descname">SyncBeamDecoder</code><span class="sig-paren">(</span><em>decoder_args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/syncbeam.html#SyncBeamDecoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.syncbeam.SyncBeamDecoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.beam.BeamDecoder" title="cam.sgnmt.decoding.beam.BeamDecoder"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.beam.BeamDecoder</span></code></a></p>
<p>This beam search implementation is a two level approach.
Hypotheses are not compared after each iteration, but after
consuming an explicit synchronization symbol. This is useful
when SGNMT runs on the character level, but it makes more sense
to compare hypos with same lengths in terms of number of words
and not characters. The end-of-word symbol &lt;/w&gt; can be used as
synchronization symbol.</p>
<p>Creates a new beam decoder instance with explicit
synchronization symbol. In addition to the constructor of
<cite>BeamDecoder</cite>, the following values are fetched from
<cite>decoder_args</cite>:</p>
<blockquote>
<div><dl class="docutils">
<dt>sync_symb (int): Synchronization symbol. If negative,</dt>
<dd>consider a hypothesis as closed when it
ends with a terminal symbol (see
syntax_min_terminal_id and
syntax_max_terminal_id)</dd>
</dl>
<p>max_word_len (int): Maximum length of a single word</p>
</div></blockquote>
</dd></dl>

</div>
<div class="section" id="module-cam.sgnmt.decoding.syntaxbeam">
<span id="cam-sgnmt-decoding-syntaxbeam-module"></span><h2>cam.sgnmt.decoding.syntaxbeam module<a class="headerlink" href="#module-cam.sgnmt.decoding.syntaxbeam" title="Permalink to this headline">¶</a></h2>
<p>The syntax beam secoding strategy ensures diversity in the terminals.</p>
<dl class="class">
<dt id="cam.sgnmt.decoding.syntaxbeam.SyntaxBeamDecoder">
<em class="property">class </em><code class="descclassname">cam.sgnmt.decoding.syntaxbeam.</code><code class="descname">SyntaxBeamDecoder</code><span class="sig-paren">(</span><em>decoder_args</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/syntaxbeam.html#SyntaxBeamDecoder"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.syntaxbeam.SyntaxBeamDecoder" title="Permalink to this definition">¶</a></dt>
<dd><p>Bases: <a class="reference internal" href="#cam.sgnmt.decoding.beam.BeamDecoder" title="cam.sgnmt.decoding.beam.BeamDecoder"><code class="xref py py-class docutils literal"><span class="pre">cam.sgnmt.decoding.beam.BeamDecoder</span></code></a></p>
<p>The syntax beam search strategy is an extension of beam search
which ensures diversity amongst the terminals in the active
hypotheses. The decoder clusters hypotheses by their terminal
history. Each cluster cannot have more than beam_size hypos, and
the number of clusters is topped by beam_size. This means that
the effective beam size varies between beam_size and beam_size^2,
and there are always beam_size different terminal histories in the
active beam.</p>
<p>Creates a new beam decoder instance for system level
combination. In addition to the constructor of
<cite>BeamDecoder</cite>, the following values are fetched from
<cite>decoder_args</cite>:</p>
<blockquote>
<div>syntax_min_terminal_id (int): All IDs smaller than this are NTs
syntax_max_terminal_id (int): All IDs larger than this are NTs</div></blockquote>
<dl class="method">
<dt id="cam.sgnmt.decoding.syntaxbeam.SyntaxBeamDecoder.decode">
<code class="descname">decode</code><span class="sig-paren">(</span><em>src_sentence</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/syntaxbeam.html#SyntaxBeamDecoder.decode"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.syntaxbeam.SyntaxBeamDecoder.decode" title="Permalink to this definition">¶</a></dt>
<dd><p>Decodes a single source sentence using beam search.</p>
</dd></dl>

<dl class="method">
<dt id="cam.sgnmt.decoding.syntaxbeam.SyntaxBeamDecoder.is_terminal">
<code class="descname">is_terminal</code><span class="sig-paren">(</span><em>tok</em><span class="sig-paren">)</span><a class="reference internal" href="_modules/cam/sgnmt/decoding/syntaxbeam.html#SyntaxBeamDecoder.is_terminal"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#cam.sgnmt.decoding.syntaxbeam.SyntaxBeamDecoder.is_terminal" title="Permalink to this definition">¶</a></dt>
<dd></dd></dl>

</dd></dl>

</div>
<div class="section" id="module-cam.sgnmt.decoding">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-cam.sgnmt.decoding" title="Permalink to this headline">¶</a></h2>
<p>This package contains the central interfaces for the decoder (in the
<code class="docutils literal"><span class="pre">core</span></code> module ), and the implementations of search strategies
(<code class="docutils literal"><span class="pre">Decoder</span></code>).</p>
</div>
</div>


           </div>
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="cam.sgnmt.misc.html" class="btn btn-neutral float-right" title="cam.sgnmt.misc package" accesskey="n">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="cam.sgnmt.html" class="btn btn-neutral" title="cam.sgnmt package" accesskey="p"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2019, University of Cambridge.

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'./',
            VERSION:'1.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="_static/jquery.js"></script>
      <script type="text/javascript" src="_static/underscore.js"></script>
      <script type="text/javascript" src="_static/doctools.js"></script>

  

  
  
    <script type="text/javascript" src="_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>